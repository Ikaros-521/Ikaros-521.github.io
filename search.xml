<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++操作符重载相关知识</title>
      <link href="/2019/09/05/c-cao-zuo-fu-chong-zai-xiang-guan-zhi-shi/"/>
      <url>/2019/09/05/c-cao-zuo-fu-chong-zai-xiang-guan-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、操作符函数重载"><a href="#一、操作符函数重载" class="headerlink" title="一、操作符函数重载"></a>一、操作符函数重载</h2><pre><code>什么是操作符函数：在C++中针对类类型的对象的运算符，由于它们肯定不支持真正的运算操作，因此编译器会将它们翻译成函数，这种就叫做操作符函数（运算符函数）。编译器把运算翻译成运算符函数，可以针对自定义的类类型设计它独有的运算功能。其实各种运算符已经具备一些功能，再次实现它的就是叫作运算符重载。双目运算符：    a+b    成员函数        a.operator+(b);    全局函数        operator+(a,b);单目运算符：    !a    成员函数        a.operator!(void);    全局函数        operator!(a);</code></pre><h2 id="二、双目操作符函数重载"><a href="#二、双目操作符函数重载" class="headerlink" title="二、双目操作符函数重载"></a>二、双目操作符函数重载</h2><pre><code>成员函数：const 类对象 operator#(const 类&amp; that) const{    return 类(参数#参数);}注意：双目录运算符的运算结果是个右值，返回值应该加 const ，然后为了const对象能够调用，参数应写const，函数也应该具备const属性。全局函数：const 类 operator#(const 类&amp; a,const 类&amp; b){}注意：全局函数不是成员函数，可能会需要访问到类的私有成员，解决这种问题可以把函数声明为类的友元函数（友元不是成员）。友元：在类的外部想访问类的私有成员（public/protected/private）时，需要把所在的函数声明为友元，但是友元只是朋友，因此它只有访问权，没有实际的拥有权（其根本原因是它没有this指针）。友元声明：把函数的声明写一份到类中，然后在声明前加上friend 关键字。使用友元即可把操作符函数定义为全局的，也可以确保类的封装性。注意：友元函数与成员函数不会构成重载关系，因此它们不在同一个作用域内。</code></pre><h2 id="三、赋值类型的双目操作符"><a href="#三、赋值类型的双目操作符" class="headerlink" title="三、赋值类型的双目操作符"></a>三、赋值类型的双目操作符</h2><pre><code>成员    类 operator#(void)    {    }全局    类 operator#(const 类&amp; that)    {    }1、获取单参构造成赋值运算的调用方式。String str = "xxx"; // 会调用单参构造，而不调用赋值运算符str = "hhh";2、左操作数据不能具有const属性    1.成员函数不能是常函数    2.全局函数第一个参数不能有const属性3、返回值应该都（成员/全局）具备const属性</code></pre><h2 id="四、单目操作符函数重载"><a href="#四、单目操作符函数重载" class="headerlink" title="四、单目操作符函数重载"></a>四、单目操作符函数重载</h2><pre><code>-,~,!,&amp;,*,-&gt;,++,--成员    const 类 operator#(void) const    {    }全局    const 类 operator#(const 类&amp; that)    {    }前++/--    类&amp; operator#(void)    {    }    类&amp; operator#(类&amp; that)    {    }后++/--(哑元)    const 类&amp; operator#(int)    {    }    const 类&amp; operator#(类&amp; that,int)    {    }</code></pre><h2 id="五、输入输出操作符重载"><a href="#五、输入输出操作符重载" class="headerlink" title="五、输入输出操作符重载"></a>五、输入输出操作符重载</h2><pre><code>cout 是 ostream 类型的对象，cin 是 istream 类型的对象。如果&lt;&lt;/&gt;&gt;运算实现为成员函数，那么调用者应该是ostream/istream,而我们无权增加标准库的代码，因此输入/输出运算符只能定义为全局函数。ostream&amp; operator&lt;&lt;(ostream&amp; os,const 类&amp; n){}istream&amp; operator&gt;&gt;(istream&amp; os,类&amp; n){}</code></pre><h2 id="六、特殊操作符的重载（笔试面试比较重要）"><a href="#六、特殊操作符的重载（笔试面试比较重要）" class="headerlink" title="六、特殊操作符的重载（笔试面试比较重要）"></a>六、特殊操作符的重载（笔试面试比较重要）</h2><pre><code>1、下标操作符 []，常用于在容器类型中以下标方式获取元素。类型&amp; operator[](int i){}2、函数操作符()，一个类如果重载函数操作符，那么它的对象就可以像函数一样使用，参数的个数、返回值类型，可以不确定，它是唯一一个可以参数有缺省参数的操作符。</code></pre><pre><code>#include &lt;iostream&gt;#include &lt;stdlib.h&gt;using namespace std;class Array{    int* arr;    size_t len;public:    Array(size_t len):len(len)    {        arr = new int[len];    }    void operator()(void)    {        cout&lt;&lt;"emmm"&lt;&lt;endl;    }    int&amp; operator[](int i)    {        if(i &lt; 0 || i &gt;= len)        {            cout&lt;&lt;"下标错误"&lt;&lt;endl;            exit(0);        }        return arr[i];    }};int main(){    Array arr(100);    for(int i=0; i&lt;10; i++)    {        arr[i] = i;        cout&lt;&lt; arr[i] &lt;&lt; endl;    }    arr();}</code></pre><pre><code>3、解引用操作符*，成员访问操作符-&gt;    如果一个类重载了*和-&gt;，那么它的对象就可以像指针一样使用。    所谓的智能指针就是一种类对象，它支持解引用和成员访问操作符。4、智能指针    常规指针的缺点：        当一个常规指针离开它的作用域时，只有该指针所占用的空间会被释放，而它指向的内存空间能否被释放就不一定了，在一些特殊情况（人为、业务逻辑特殊）free或delete没有执行，就会形成内存泄漏。    智能指针的优点：        智能指针是一个封装了常规指针的类类型对象，当它离开作用域时，它的析构函数会自动执行，它的析构函数会负责释放常规指针所指向的动态内存（以正确方式创建的智能指针，它的析构函数才会正确执行）。    智能指针和常规指针的相同点：都支持*和-&gt;运算。    智能指针和常规指针的不同点：        任何时候，一个对象只能使用一个智能指针来指向，而常规指针可以指向多次。        只能指针的赋值操作需要经过拷贝构造和赋值构造特殊处理（深拷贝）。</code></pre><pre><code>#include &lt;iostream&gt;using namespace std;class Int{public:    int val;    Int(int val=0):val(val){ }    void set_val(int val)    {        this-&gt;val = val;    }    int get_val(void)    {        return val;    }    Int&amp; operator=(const int val)    {        this-&gt;val = val;        return *this;    }    ~Int(void)    {        cout&lt;&lt;"我是Int的析构函数"&lt;&lt;endl;    }    friend ostream&amp; operator&gt;&gt;(ostream&amp; os,Int&amp; n);};ostream&amp; operator&lt;&lt;(ostream&amp; os,Int&amp; n){    return os&lt;&lt;n.val;}class IntPointer{    Int* ptr;public:    IntPointer(Int* ptr):ptr(ptr){ }    Int&amp; operator*(void)    {        return *ptr;    }    ~IntPointer(void)    {        delete ptr;    }};int main(){    Int* num =new Int(100);    IntPointer p = num;    *p = 20;    cout&lt;&lt;*p &lt;&lt;endl;    *p = 10;    cout&lt;&lt;*p &lt;&lt;endl;}</code></pre><pre><code>auto_ptr:标准库中封装好的智能指针，实现了常规指针的基本功能，头文件 #include &lt;memory&gt;    用法：auto_ptr&lt;指向的类型&gt; 指针变量名(对象的地址)    auto_ptr的局限性：        不能跨作用域使用，一旦离开作用域指针变量会释放它指向的对象也会释放。        不能放入标准容器。        不能指向对象数组。</code></pre><pre><code>#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;class A{public:    A(void)    {        cout&lt;&lt;"构造"&lt;&lt;endl;    }    ~A(void)    {        cout&lt;&lt;"析构"&lt;&lt;endl;    }    void show(void)    {        cout&lt;&lt;"A's show"&lt;&lt;endl;    }};int main(){    auto_ptr&lt;A&gt; ptr(new A);    (*ptr).show();}</code></pre><pre><code>5、new/delete/new[]/delete[]运算符重载    1.C++缺省的堆内存管理器速度较慢，重载new/delete底层使用malloc/free可以提高运行速度。    2.new在失败会产生异常，而每次使用new时为了安全都应该进行异常捕获，而重载new操作符只需要在操作符函数中进行一次错误处理即可。    3.在一些占字节数比较小的类，频繁使用new，可能会产生大量的内存碎片，而重载new操作符后，可以适当的扩大每次申请的字节数，减少内存碎片产生的机率。    4.重载 new/delete 可以记录堆内存使用的信息    5.重载 delete 可以检查到释放内存失败时的信息，检查到内存泄漏。</code></pre><h2 id="七、重载操作符的限制"><a href="#七、重载操作符的限制" class="headerlink" title="七、重载操作符的限制"></a>七、重载操作符的限制</h2><pre><code>1、不能重载的操作符    域限定符 ::    直接成员访问操作符 .    三目操作符 ?:    字节长度操作符 sizeof    类型信息操作符 typeid2、重载操作符不能修改操作符的优先级3、无法重载所有基本类型的操作符运算4、不能修改操作符的参数个数5、不能发明新的操作符</code></pre><h2 id="关于操作符重载的建议："><a href="#关于操作符重载的建议：" class="headerlink" title="关于操作符重载的建议："></a>关于操作符重载的建议：</h2><pre><code>1、在重载操作符时要根据操作符实际的功能和意义来确定具体参数，返回值，是否具有const属性，返回值是否是引用或者临时对象。2、重载操作符要符合情理（要有意义），要以实际用途为前提。3、重载操作符的意义是为了让对象的操作更简单、方便，提高代码的可读性，而不是为了炫技。4、重载操作符要与默认的操作符的功能、运算规则一致，不要出现反人类的操作。#define ture 0#define false 1</code></pre><p>相关测试代码：</p><pre><code>#include &lt;iostream&gt;using namespace std;class Point{    int x;    int y;public:    Point(int _x=0,int _y=0)    {        x = _x;        y = _y;    }/*    void show(void) const    {        cout&lt;&lt; "(x:" &lt;&lt;x &lt;&lt;",y:" &lt;&lt;y&lt;&lt; ")"&lt;&lt;endl;    }*/    friend const Point operator+(const Point&amp; a,const Point&amp; b);    friend const Point operator-(const Point&amp; a,const Point&amp; b);    friend const Point operator*(const Point&amp; a,int b);    friend const Point operator*(int a,const Point&amp; b);    const Point operator/(const int that) const    {        return Point(x/that,y/that);    }/*    const Point operator+(const Point&amp; that) const    {        return Point(that.x+x,that.y+y);    }*/    const Point&amp; operator+=(const Point&amp; that)    {        x += that.x;        y += that.y;        cout&lt;&lt;"___";        return *this;    }    Point operator-(void)    {        return Point(-x,-y);    }    // 前++    Point&amp; operator++(void)    {        x++;        y++;        return *this;    }    // 后++ (哑元)/*    Point operator++(int)    {        Point temp(x,y);        x++;        y++;        return temp;    }*/    friend Point operator++(Point&amp; that,int);//友元    Point operator--(int)    {        Point temp(x,y);        x--;        y--;        return temp;    }    friend ostream&amp; operator&lt;&lt;(ostream&amp; os,const Point&amp; p);    friend istream&amp; operator&gt;&gt;(istream&amp; is,Point&amp; p);};ostream&amp; operator&lt;&lt;(ostream&amp; os,const Point&amp; p){    return os &lt;&lt;p.x&lt;&lt;","&lt;&lt;p.y;}istream&amp; operator&gt;&gt;(istream&amp; is,Point&amp; p){    cout &lt;&lt; "请输入x的值:";    is &gt;&gt; p.x;    cout&lt;&lt;"请输入y的值：";    is &gt;&gt; p.y;    return is;}Point operator++(Point&amp; that,int){    Point temp(that.x,that.y);    that.x++;    that.y++;    return temp;}const Point operator+(const Point&amp; a,const Point&amp; b){    return Point(a.x+b.x,a.y+b.y);}const Point operator-(const Point&amp; a,const Point&amp; b){    return Point(a.x-b.x,a.y-b.y);}const Point operator*(const Point&amp; a,int b){    return Point(a.x*b,a.y*b);}const Point operator*(int a,const Point&amp; b){    return Point(a*b.x,a*b.y);}int main(){    Point p(3,9);    Point p1(1,3);    Point p2 = p1+p+p1;    cout&lt;&lt;"+:";    cout&lt;&lt;p2&lt;&lt;endl;    Point p4(6,6);    cin&gt;&gt;p4;    cout&lt;&lt;p4&lt;&lt;endl;//    p2.show();    p2 = p2-p1;    cout&lt;&lt;"-:";    cout&lt;&lt;p2&lt;&lt;endl;//    p2.show();    p2 = p1*3;    cout&lt;&lt;"*:";    cout&lt;&lt;p2&lt;&lt;endl;//    p2.show();    p2 = 3*p1;//    p2.show();    cout&lt;&lt;p2&lt;&lt;endl;    cout&lt;&lt;(-p1)&lt;&lt;endl;//    (-p1).show();    p2 = p1;//    p2.show();//    (++p1).show();    cout&lt;&lt;(++p1)&lt;&lt;endl;//    (p2++).show();    cout&lt;&lt;"p2:"&lt;&lt;(p2++)&lt;&lt;endl;    cout&lt;&lt;"p2:"&lt;&lt;p2&lt;&lt;endl;//    p2.show();    cout&lt;&lt;"p2:"&lt;&lt;(p2--)&lt;&lt;endl;    cout&lt;&lt;"p2:"&lt;&lt;p2&lt;&lt;endl;//    (p2--).show();//    p2.show();    p2 = p2/3;//    p2.show();    cout&lt;&lt;"p2:"&lt;&lt;p2&lt;&lt;endl;}</code></pre><p>如有错误，望指出，谢谢~</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UML相关知识</title>
      <link href="/2019/09/04/uml-xiang-guan-zhi-shi/"/>
      <url>/2019/09/04/uml-xiang-guan-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、UML概述"><a href="#一、UML概述" class="headerlink" title="一、UML概述"></a>一、UML概述</h2><pre><code>1、什么是UML    统一建模语言（Unified Modeling Language）。用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的开发方法。UML展现了一系列最佳工程实践，这些最佳实践在对大规模，复杂系统进行建模方面，特别是在软件架构层次已经被验证有效。    项目开发的说明书（设计图）。2、UML是做什么的    帮助建立软件开发过程和各种模型    主要目的是为了让开发者之间进行有效的交流。        开发者与设计者之间的交流        开发者与开发者之间的交流        开发者与管理者之间的交流    适合大型项目和大型团队的开发3、UML的应用领域    UML的目标是以面向对象的方式来描述任何类型的系统，常用于建立软件的模型。4、我对UML的看法    不建议用UML生成代码。    没有完美的UML图，够用就行，图是死的，人是活的。    UML主要功能是为了更好的让开发团队与用户之间进行沟通交流。    先结对学习UML目的以应用、看懂为主(有利于后期工作)，以画图为辅。    但需要长期学习，为后期成为系统分析师、架构师、产品经理、项目经理打下基础。</code></pre><h2 id="二、Rational-Rose四种视图与UML的8中图形关系"><a href="#二、Rational-Rose四种视图与UML的8中图形关系" class="headerlink" title="二、Rational Rose四种视图与UML的8中图形关系"></a>二、Rational Rose四种视图与UML的8中图形关系</h2><pre><code>    Rose启动后自动创建四种视图：        用例视图： Use Case View            帮助理解和使用系统，这种图展示了系统的参与者和用例是怎么相互作用的，包括了系统中的所有角色。            用例图：Use Case Digram            时序图：Sequence Digram            协作图：Collaboration Digram            活动图：Activity Digram            这种视图的主要使用都是用户、分析人员、项目管理人员。        逻辑视图： Logical View            逻辑视图关注的是系统如何实现用例中提出的功能，它提供系统的详细图形，描述了组件间如何关联。            类图：Call Digram            状态图：Statechart Dirgam            这种视图的主要使用者是开发人员，开发人员包括：程序员、需求分析师、测试工程师、项目经理。        构件视图： Component View            这种视图关注的是代码模板间的关系，通过组件视图可以知道哪些代码是组件，哪些是代码库，哪些是运行组件，会默认有一个Component图表。            这种视图的主要使用者是负责控制代码、编译、部署应用程序的人员。        部署视图： Deployment View            这种视图关注的是系统的实际部署，进程和设备间的实际连接。            这种视图的使用者是用户和软件的发布人员。</code></pre><h2 id="三、用例图：详细表示所有的用例需求，不考虑细节"><a href="#三、用例图：详细表示所有的用例需求，不考虑细节" class="headerlink" title="三、用例图：详细表示所有的用例需求，不考虑细节"></a>三、用例图：详细表示所有的用例需求，不考虑细节</h2><pre><code> 1、用例图的作用        主要用它来描述需求，画图时要从用户的角度出发，主要用于与用户之间的交流。    2、用例图的要点        正确反应用户的需求        每个用例的内部实现        细节不是本阶段要考虑的问题    3、用例图包括        参与者        用例        用例之间的关系    4、如何确定参与者        谁使用系统        谁负责启动、关闭系统        谁查询数据        谁提供数据        谁安装、升级系统    5、什么是用例        是系统的使用过程，一个用例就是一个功能需求。</code></pre><h2 id="四、类图：主要表示类与类之间的关系，不用详细考虑类的属性和方法"><a href="#四、类图：主要表示类与类之间的关系，不用详细考虑类的属性和方法" class="headerlink" title="四、类图：主要表示类与类之间的关系，不用详细考虑类的属性和方法"></a>四、类图：主要表示类与类之间的关系，不用详细考虑类的属性和方法</h2><pre><code>    1、类图的主要作用        主要用来描述类的内部结构和类与类之间的关系。        类图中不显示暂时性的消息，是面向对象剑魔时的主要组成部分。    2、类图主要包括        名称：类名        属性：类的成员变量            访问权限            变量名            类型        操作：类的成员函数            访问权限            函数名            参数名            参数类型            返回值类型        职责：说明此类具体负责的任务，解决什么问题    3、类之间的关系        继承关系：空心箭头实线来表示继承关系，子类指向父类            一个类Test继承Base类的属性和行为，并可以增加自己的属性和行为。        实现关系：空心箭头虚线来表示继承关系，子类指向父类            一个类Test继承一个抽象类，父类中的函数定义为纯虚函数，子类继承后覆盖所有纯虚函数。        依赖关系：箭头和虚线来表示依赖关系，依赖者指向被依赖者            一个类A中使用到类B（类A中的函数的参数或返回值类型是类B），这种关系是一种偶然、临时的，是一种非常弱的关系。        关联关系：箭头和实线来表示关联关系，依赖者指向被依赖者            是一种强依赖关系，类A的属性（成员变量）是类B。        聚合关系：实心菱形和箭头实线来表示聚合关系，菱形指向整体，箭头指向部分。            聚合关系是一种关联关系的特例，它体现的是整体与部分。            整体与部分之间是可分离，它们可以具有各自的生命周期。            从代码层面来讲与关联是一致的。        组合关系：实心菱形和箭头实线来表示组合关系，菱形指向整体，箭头指向部分。            组合关系也是一种聚合关系的特例，这种关系比聚合更强，也称为强聚合，同样也体现出整体与部分，但此时的整体与部分是不可分隔的。            从代码层面来讲与关联是一致的。        从代码实现层面只有继承、包含、依赖。    用例图和类表示对象之间消息的发送顺序，值考虑正确情况。</code></pre><h2 id="五、时序图：主要表示对象之间消息的发送顺序，只考虑正确情况。"><a href="#五、时序图：主要表示对象之间消息的发送顺序，只考虑正确情况。" class="headerlink" title="五、时序图：主要表示对象之间消息的发送顺序，只考虑正确情况。"></a>五、时序图：主要表示对象之间消息的发送顺序，只考虑正确情况。</h2><pre><code>用来表示对象之间的关系，同时强调对象之间的交互。时序图向用户表示时间随着时间的推移，清晰的可视化轨迹。时序图用来表示项目中的某个操作中如何进行的，具体的步骤是什么。</code></pre><h2 id="六、状态图"><a href="#六、状态图" class="headerlink" title="六、状态图"></a>六、状态图</h2><pre><code>用来表示对象的状态变化，用于帮助开发人员理解系统中对象的行为。主要有状态，生命周期，条件，状态转换，事件和动作。</code></pre><h2 id="七、活动图"><a href="#七、活动图" class="headerlink" title="七、活动图"></a>七、活动图</h2><pre><code>活动图的本质就是流程图，它描述了系统的活动、判断点和分支。侧重于操作而不是对象，重点表示逻辑变化。一个动作的流程图一般包括起点、终点、操作。泳道：用于多种角色参与一个过程，一个活动只能属于一个泳道。</code></pre><h2 id="八、协作图"><a href="#八、协作图" class="headerlink" title="八、协作图"></a>八、协作图</h2><pre><code>主要用来描述对象之间的交互关系，强调参与交互的各对象的组织。需要按照组织对控制流程进行建模时选择画协作图。协作图与时序图的区别：    时序图描述了交互过程中的时间顺序，但没有表达对象之间的关系。    协作图描述了对象间的关系但时间顺序必须从时序图中获得。合格的协作图和时序图主义相同，可互换，而不丢失信息。</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> UML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的项目的相关问题</title>
      <link href="/2019/09/04/wo-de-xiang-mu-de-xiang-guan-wen-ti/"/>
      <url>/2019/09/04/wo-de-xiang-mu-de-xiang-guan-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>由于个人编程是，使用的自己的getch.h头文件，导致可能部分项目无法成功通过编译。<br>Linux系统，需要将getch.h添加到user/include下<br>Windows系统，需要将getch.h头文件换为conio.h</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中的虚函数表、强制类型转换、I/O流等</title>
      <link href="/2019/09/03/c-zhong-de-xu-han-shu-biao-qiang-zhi-lei-xing-zhuan-huan-i-o-liu-deng/"/>
      <url>/2019/09/03/c-zhong-de-xu-han-shu-biao-qiang-zhi-lei-xing-zhuan-huan-i-o-liu-deng/</url>
      
        <content type="html"><![CDATA[<h2 id="一、虚函数表"><a href="#一、虚函数表" class="headerlink" title="一、虚函数表"></a>一、虚函数表</h2><pre><code>什么是虚函数表，在C++的类中，一旦成员函数中有虚函数，这个类中就会多一个虚函数表指针，这个指针指向一个虚函数表，表里面记录了这个类中所有的虚函数，当这个类被继承，它的子类中也会有一个虚函数表（不管子类中有没有虚函数），如果子类的成员函数中有函数签名与父类的虚函数一样，就会用子类中的函数体寒它在虚函数表中的位置，这样就达到了覆盖的效果。当通过类指针或引用调用函数时，会根据对象中实际的虚函数表记录来调用函数，这样就达到了多态的效果。</code></pre><h2 id="二、虚析构"><a href="#二、虚析构" class="headerlink" title="二、虚析构"></a>二、虚析构</h2><pre><code>当使用delete释放一个父类指针时，不管实际指向的对象是子类还是父类都只会调用父类的析构函数（多态肯定会出现的问题）。如果子类的析构函数有需要负责释放的内存，就会造成内存泄漏。为了解决这个问题，可以把父类的析构函数设置为虚函数，析构函数进行覆盖时不会比较函数名。当父类的析构函数为虚函数时，通过父类指针或引用释放子类对象时，会自动调用子类的析构函数，子类的析构函数执行完成后也会调用父类的析构函数。注意：析构函数可以是虚函数，但构造函数不行</code></pre><h2 id="三、强制类型转换"><a href="#三、强制类型转换" class="headerlink" title="三、强制类型转换"></a>三、强制类型转换</h2><pre><code>注意：C++中为了兼容C语言，(目标类型)源类型 依然可以继续使用，但C语言的强制类型转换安全性差，因此建议使用C++中的强制类型转换。注意：C++之父认为如果代码设计的完善，根本不需要用到强制类型转换，而C++的强制类型转换之所以设计的很复杂，是为了让程序员多关注代码本身的设计，尽量少使用。C++中的强制类型转换保证没有很大安全隐患。static_cast&lt;目标类型&gt;(源类型)   编译器会对源类型和目标类型做兼容性检查，不通过则报错。dynamic_cast&lt;目标类型&gt;(源类型)  编译器会对源类型和目标类是否同为指针或引用，并且存在多态型的继承关系。const_cast&lt;目标类型&gt;(源类型)    编译器会对源类型和目标类检查，是否同为指针或引用，除了常属性外其他必须完全相同，否则报错。reinterpret_cast&lt;目标类型&gt;(源类型)  编译器会对源类型和目标类是否为指针或整数进行检查，也就是说把整数转换成指针或把指针转换为整数。</code></pre><p>拓展：<br>    静态编译：指针或引用的目标是确定的，在编译时期就确定了所有的类型检查、函数调用。<br>    动态编译：指针或引用的目标是不确定的（多态），只有在函数调用的时候才确定具体是哪一个子类。</p><h2 id="四、I-O流"><a href="#四、I-O流" class="headerlink" title="四、I/O流"></a>四、I/O流</h2><pre><code>I/O流的打开模式：    ios::in     以读权限打开文件，不存在则失败，存在不清空    ios::out    以写权限打开文件，不存在则创建，存在则清空    ios::app    打开文件用于追加，不存在则创建，存在不清空    ios::binary 以二进制模式进行读写    ios::ate    打开时定位到文件末尾    ios::trunc  打开文件时清空fstream/ifstream/ofstream 类用于进行文件操作。    构造函数或成员函数 open 用于打开文件    good成员函数检查流是否可用    eof成员函数用于输入流是否结束操作符 &gt;&gt;  用于从文件中读取数据到变量 操作符 &lt;&lt;  用于输出数据到文件IO流有一系列格式化控制函数，类似：左对齐、右对齐、宽度、填充、小数点位数。</code></pre><pre><code>#include &lt;iostream&gt;#include &lt;fstream&gt;using namespace std;int main(){    fstream fsi("test.txt",ios::in);    //fs.open("test.txt",ios::in);    if(!fsi.good())    {        cout &lt;&lt;"打开失败"&lt;&lt;endl;    }    else    {        cout &lt;&lt;"打开成功"&lt;&lt;endl;    }    string str,s1,s2,s3;    int num = 0;/*    fsi &gt;&gt; str;    //读到空格或换行就停止    fsi &gt;&gt; num &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; s3;    cout&lt;&lt;str&lt;&lt;"-"&lt;&lt;num&lt;&lt;"-"&lt;&lt;s1&lt;&lt;"-"&lt;&lt;s2&lt;&lt;"-"&lt;&lt;s3&lt;&lt;endl;*/    string arr[10];    int i = 0;    while(1)    {        fsi &gt;&gt; arr[i];        if(arr[i].size() == 0)        {            break;        }        i++;    }    for(int j=0; j&lt;i; j++)    {        cout &lt;&lt; arr[j] &lt;&lt;"-";    }    fstream fso("test.txt",ios::out);    fso &lt;&lt; "hehe" &lt;&lt; " " &lt;&lt; 100 &lt;&lt;" " &lt;&lt;"adsadsad"&lt;&lt;endl;}</code></pre><pre><code>二进制读写：read/write    read (char_type *__s,streamsize __n)    write (char_type *__s,streamsize __n)gcount成员函数可以获取上次流的二进制读写操作的字节数。随机读写：    seekp (off_type,ios_base::seekdir)    功能：设置文件的位置指针。    off_type：偏移值        正值向右，负值向左    seekdir：基础位置        ios::beg    文件开头        ios::cur    当前位置        ios::end    文件末尾</code></pre><pre><code>#include &lt;iostream&gt;#include &lt;fstream&gt;using namespace std;int main(){    fstream fs("test.txt",ios::in);    if(!fs.good())    {        cout &lt;&lt; "文件打开失败" &lt;&lt; endl;        return -1;    }    // 调整文件的位置指针到末尾    fs.seekp(0,ios::end);    cout &lt;&lt; "文件的字节数：" &lt;&lt; fs.tellp() &lt;&lt; endl;    fs.close();}</code></pre><pre><code>练习：使用C++标准IO，实现带覆盖检查的cp命令。    ./cp src dest</code></pre><pre><code>#include &lt;iostream&gt;#include &lt;fstream&gt;using namespace std;int main(int argc,char* argv[])// 写的有点问题0.0{    if(argc != 3)    {        cout &lt;&lt; "命令错误" &lt;&lt; endl;    }    // 读写    fstream fi(argv[1],ios::in);    fstream fo(argv[2],ios::out);    if(!fi.good())    {        cout &lt;&lt; "源文件不存在" &lt;&lt; endl;    }    cout &lt;&lt; "是否要覆盖目标文件,y/n" &lt;&lt; endl;    while(1)    {        string a;        cin &gt;&gt; a;        if(a == "y")        {            break;        }        else if(a == "n")        {            return 0;        }        else        {            cout &lt;&lt; "指令错误" &lt;&lt; endl;            continue;        }    }    while(1)    {        string str;        fi &gt;&gt; str;        if(str.size() == 0)        {            break;        }        fo &lt;&lt; str &lt;&lt;" "; // 文件末尾多个空格，需要删除，并且没有换行功能    }}</code></pre><h2 id="五、类型信息-typeid"><a href="#五、类型信息-typeid" class="headerlink" title="五、类型信息 typeid"></a>五、类型信息 typeid</h2><pre><code>用于获取数据的类型信息。name成员函数，可以获取类型的名字，内建类型名字使用缩写。同时还支持 == != 用来比较是否是同一种类型。如果用于判断父子类的指针或引用，它不能准确判断出实际的对象类型。但可以判断出具有多态继承关系的父子类的指针或引用，它的实际对象。</code></pre><pre><code>#include &lt;iostream&gt;#include &lt;typeinfo&gt;using namespace std;class Base{public:    virtual ~Base(void)    {    }};class Test:public Base{};int main(){    Base b;    Test t;    cout &lt;&lt; typeid(b).name() &lt;&lt; endl;    cout &lt;&lt; (typeid(t) == typeid(b)) &lt;&lt; endl;    cout &lt;&lt; endl;    Base* p = new Test;    cout &lt;&lt; (typeid(*p) == typeid(Test)) &lt;&lt; endl;    cout &lt;&lt; (typeid(p) == typeid(Test*)) &lt;&lt; endl;}</code></pre><pre><code>扩展：    sudo find / -name filename    sudo find / | grep "std"    grep 'Base' *               当前目录查找包含此字符的文件    grep -r 'Base' *            当前目录及所有子级目录，查找包含此字符的文件    grep -r 'Base' * dir        指定目录下及所有子级目录，查找包含此字符的文件</code></pre><h2 id="六、异常处理"><a href="#六、异常处理" class="headerlink" title="六、异常处理"></a>六、异常处理</h2><pre><code>抛异常    throw 数据    抛异常对象    抛基本类型    注意：不能抛出局部对象的指针或引用（构造函数和析构函数不能抛出异常）。    注意：如果异常没有被捕获处理，程序就会停止。捕获异常try{    可以抛出异常的代码}catch(类型 变量名) // 根据数据类型进行捕获{    处理异常，如果无法处理可以继续抛出异常}注意：捕获异常的顺序是自上而下的，而不是最精准的匹配，针对子类异常捕获时要放在父类的前面。函数的异常声明：    返回值类型 函数名(参数列表)throw(类型1,类型2,...)    注意：如果不写异常声明表示什么类型的异常都可能抛出。    注意：如果写了异常声明表示只抛出某些类型的异常，一旦超出异常声明的范围，程序会直接停止，无法捕获。    注意：throw() 表示什么类型都不会抛出设计异常类：</code></pre><pre><code>      class Error      {          int errno;          char errmsg[255];      public:          Error(int errno = -1,const char* msg = "未知错误")          {              this-&gt;errno = errno;              strcpy(errmsg,msg);          }          int getError(void)          {              return errno;          }          const char* getErrmsg(void)          {              return errmsg;          }      }</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中STL相关知识</title>
      <link href="/2019/08/31/c-zhong-stl-xiang-guan-zhi-shi/"/>
      <url>/2019/08/31/c-zhong-stl-xiang-guan-zhi-shi/</url>
      
        <content type="html"><![CDATA[<p><strong>STL介绍</strong><br>    STL标准模板库，由惠普实验室提供，里面集成了常用的数据结构类模板和算法函数模板等。<br>    容器：用来存储各种类型数据的数据结构。<br>    迭代器：类似于专门用来指向容器成员的指针，用来遍历、操作、管理容器中的成员，可以大大提高容器的访问速度。<br>    算法：STL实现了常见的排序、查找算法。</p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/20190827150134261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lrYXJvc181MjE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="List：双端链表容器"><a href="#List：双端链表容器" class="headerlink" title="List：双端链表容器"></a>List：双端链表容器</h2><pre><code>iterator：用来指向容器中的元素    begin() 获取指向第一个元素的迭代器    end() 获取指向最后一个元素的下一个位置相关使用参考：https://blog.csdn.net/Ikaros_521/article/details/100091859</code></pre><p><img src="https://img-blog.csdnimg.cn/20190827150153998.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lrYXJvc181MjE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="vector：向量容器，俗称数组"><a href="#vector：向量容器，俗称数组" class="headerlink" title="vector：向量容器，俗称数组"></a>vector：向量容器，俗称数组</h2><pre><code>    #include &lt;iostream&gt;    #include &lt;vector&gt;    using namespace std;    void show(vector&lt;int&gt;&amp; arr)    {        for(int i=0; i&lt;arr.size(); i++)        {            cout &lt;&lt; arr[i] &lt;&lt; " ";        }        cout &lt;&lt; endl;    }    int main()    {        // 创建向量，设置容量并初始化        vector&lt;int&gt; arr(12,0);        show(arr);        // 向量支持[]运算符，所以被称为数组        for(int i=0; i&lt;10; i++)        {            arr[i] = i;        }        show(arr);        vector&lt;int&gt; arr1(10,0);            // 支持比较运算符        cout &lt;&lt; (arr[0]==arr1[0]) &lt;&lt; endl;        // at成员函数,相当于[]操作        for(int i=0; i&lt;arr.size(); i++)        {            cout &lt;&lt; arr.at(i) &lt;&lt; " ";        }        cout &lt;&lt; endl;        // 获取向量的容量         cout &lt;&lt; arr.capacity() &lt;&lt; endl;    }</code></pre><p><img src="https://img-blog.csdnimg.cn/20190827150209482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lrYXJvc181MjE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>  <img src="https://img-blog.csdnimg.cn/2019082715022572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lrYXJvc181MjE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="stack、queue：栈和队列"><a href="#stack、queue：栈和队列" class="headerlink" title="stack、queue：栈和队列"></a>stack、queue：栈和队列</h2><p>   <img src="https://img-blog.csdnimg.cn/20190827150318915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lrYXJvc181MjE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="double-ended-queues：双端队列，用法与向量基本一致，但可以在头和尾快速插入和删除元素"><a href="#double-ended-queues：双端队列，用法与向量基本一致，但可以在头和尾快速插入和删除元素" class="headerlink" title="double-ended queues：双端队列，用法与向量基本一致，但可以在头和尾快速插入和删除元素"></a>double-ended queues：双端队列，用法与向量基本一致，但可以在头和尾快速插入和删除元素</h2><pre><code>    #include &lt;iostream&gt;    #include &lt;deque&gt;    using namespace std;    int main()    {        deque&lt;int&gt; d(10,0);        for(int i=0; i&lt;d.size(); i++)        {            d[i] = i;        }        for(int i=0; i&lt;d.size(); i++)        {            cout &lt;&lt; d[i] &lt;&lt; " ";        }        cout &lt;&lt; endl;    }</code></pre><p><img src="https://img-blog.csdnimg.cn/20190827150335763.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lrYXJvc181MjE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="set：集合容器，集合中的数据会自动排序，不能重复（赋重复值也没用）。"><a href="#set：集合容器，集合中的数据会自动排序，不能重复（赋重复值也没用）。" class="headerlink" title="set：集合容器，集合中的数据会自动排序，不能重复（赋重复值也没用）。"></a>set：集合容器，集合中的数据会自动排序，不能重复（赋重复值也没用）。</h2><pre><code>    #include &lt;iostream&gt;    #include &lt;set&gt;    using namespace std;    int main()    {        int arr[5] = {4,3,2,2,5};        set&lt;int&gt; s;        // 在集合中插入元素        s.insert(arr,arr+5);        set&lt;int&gt;::iterator it;        for(it=s.begin(); it!=s.end(); it++)        {            cout &lt;&lt; *it &lt;&lt; " ";        }        // 返回某个值元素的个数        cout &lt;&lt; endl &lt;&lt; s.count(2) &lt;&lt;" "&lt;&lt;s.count(1)&lt;&lt; endl;        // 返回指向大于（或等于）某值的第一个元素的迭代器        cout &lt;&lt; *s.lower_bound(1) &lt;&lt; endl;    }</code></pre><p><img src="https://img-blog.csdnimg.cn/20190827150349668.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lrYXJvc181MjE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="map：是一种关联容器，在其他编程语言中叫字典，C-中叫映射，以key-value键值对的方式进行存储，key的值不能重复。"><a href="#map：是一种关联容器，在其他编程语言中叫字典，C-中叫映射，以key-value键值对的方式进行存储，key的值不能重复。" class="headerlink" title="map：是一种关联容器，在其他编程语言中叫字典，C++中叫映射，以key/value键值对的方式进行存储，key的值不能重复。"></a>map：是一种关联容器，在其他编程语言中叫字典，C++中叫映射，以key/value键值对的方式进行存储，key的值不能重复。</h2><pre><code>    #include &lt;iostream&gt;    #include &lt;map&gt;    using namespace std;    int main()    {        map&lt;int,string&gt; m;        // 插入元素        m.insert(make_pair(10010,"hehe"));        m.insert(make_pair(10011,"haaa"));        m.insert(make_pair(10012,"xixi"));        m.insert(make_pair(10013,"ohho"));        m.insert(make_pair(10013,"ohho"));        cout &lt;&lt; m.size() &lt;&lt; endl;        cout &lt;&lt; (*m.find(10011)).second &lt;&lt; endl;        map&lt;int,string&gt;::iterator it;        for(it=m.begin(); it!=m.end(); it++)        {            cout&lt;&lt; (*it).first &lt;&lt; " " &lt;&lt; (*it).second &lt;&lt; endl;        }    }</code></pre><p><img src="https://img-blog.csdnimg.cn/20190827150410951.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lrYXJvc181MjE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="multimap：多重映射，它与map很像，区别是它的key的值可以重复。"><a href="#multimap：多重映射，它与map很像，区别是它的key的值可以重复。" class="headerlink" title="multimap：多重映射，它与map很像，区别是它的key的值可以重复。"></a>multimap：多重映射，它与map很像，区别是它的key的值可以重复。</h2><pre><code>    #include &lt;iostream&gt;    #include &lt;map&gt;    using namespace std;    int main()    {        multimap&lt;int,string&gt; mm;        // 插入元素        mm.insert(make_pair(10010,"ha1"));        mm.insert(make_pair(10012,"ha2"));        mm.insert(make_pair(10010,"ha3"));        mm.insert(make_pair(10013,"ha4"));        mm.insert(make_pair(10010,"ha5"));        cout &lt;&lt; mm.size() &lt;&lt; endl;        multimap&lt;int,string&gt;::iterator it;        // 查找一个元素        it = mm.find(10010);        // 返回指定元素出现的次数        for(int i=0; i&lt;mm.count(10010); i++)        {            cout &lt;&lt; (*it).second &lt;&lt; endl;            it++;        }    }</code></pre><p><img src="https://img-blog.csdnimg.cn/20190827150451820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lrYXJvc181MjE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="multiset：多重集合，它与set很像，区别是它的值可以重复。"><a href="#multiset：多重集合，它与set很像，区别是它的值可以重复。" class="headerlink" title="multiset：多重集合，它与set很像，区别是它的值可以重复。"></a>multiset：多重集合，它与set很像，区别是它的值可以重复。</h2><pre><code>    #include &lt;iostream&gt;    #include &lt;set&gt;    using namespace std;    int main()    {        int arr[10] = {1,3,5,3,2,5,7,6,3,9};        multiset&lt;int&gt; ms(arr,arr+10);        cout &lt;&lt; ms.size() &lt;&lt; endl;        cout &lt;&lt; ms.count(3) &lt;&lt; endl;        multiset&lt;int&gt;::iterator it;        for(it=ms.begin(); it!=ms.end(); it++)        {            cout &lt;&lt; (*it) &lt;&lt; " ";        }    }</code></pre><p><img src="https://img-blog.csdnimg.cn/20190827150513935.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lrYXJvc181MjE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="priority-queue：优先队列，它会根据元素的比较结果进行排序。"><a href="#priority-queue：优先队列，它会根据元素的比较结果进行排序。" class="headerlink" title="priority_queue：优先队列，它会根据元素的比较结果进行排序。"></a>priority_queue：优先队列，它会根据元素的比较结果进行排序。</h2><pre><code>#include &lt;iostream&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;queue&gt;using namespace std;int com(int&amp; a,int&amp; b){    if(a &gt; b)        return 1;    else if(a &lt; b)        return -1;    else        return 0;}int main(){    srand(time(NULL));    priority_queue&lt;int&gt; pq;    for(int i=0; i&lt;10; i++)    {        int val = rand()%100;        cout &lt;&lt; val &lt;&lt; " ";        pq.push(val);    }    cout &lt;&lt; pq.size() &lt;&lt; endl;    while(!pq.empty())    {        cout &lt;&lt; pq.top() &lt;&lt; " ";        pq.pop();    }}</code></pre><p>   总结：<br>    1、vector和deque是支持[]运算，因此基本不需要迭代器，其他容器一律使用迭代器进行遍历。<br>    2、stack、queue、priority_queue容器没有迭代器。<br>    3、set、multiset、priority_queue会对元素进行排序，因它存储元素要支持比较运算符。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中的模板</title>
      <link href="/2019/08/31/c-zhong-de-mo-ban/"/>
      <url>/2019/08/31/c-zhong-de-mo-ban/</url>
      
        <content type="html"><![CDATA[<h2 id="一、为什么使用模板"><a href="#一、为什么使用模板" class="headerlink" title="一、为什么使用模板"></a>一、为什么使用模板</h2><pre><code>1、C/C++是一种静态类型语言（预处理-&gt;汇编-&gt;编译-&gt;链接），好处是速度快，缺点是实现通用代码麻烦。例如：实现支持所有类型的快速排序。2、借助函数重载实现通用代码，好处是实现简单，但代码段会增加。3、借助宏函数实现通用代码，类型检查不严格。4、借助回调函数实现通用代码，使用麻烦。5、由于以上原因C++之父在C++实现了模板技术，让C++能够支持泛型编程。</code></pre><a id="more"></a><h2 id="二、函数模板"><a href="#二、函数模板" class="headerlink" title="二、函数模板"></a>二、函数模板</h2><h3 id="1、函数模板的定义"><a href="#1、函数模板的定义" class="headerlink" title="1、函数模板的定义"></a>1、函数模板的定义</h3><pre><code>  template &lt;typename 类型参数1,typename 类型参数2,...&gt;  类型参数1 函数名(参数类型2 参数名)  {      return 返回值;  }  template &lt;typename T&gt;  T find(T* arr,size_t len)  {     return val;  }可以用任何标识符作为类型参数名，但使用‘T’ 是约定俗成的，它表示调用这个函数时所指定的任意类型。</code></pre><h3 id="2、函数模板的使用"><a href="#2、函数模板的使用" class="headerlink" title="2、函数模板的使用"></a>2、函数模板的使用</h3><pre><code>    C++编译的编译器并不是把模板编译成一个可以处理任何类型的单一实体，而是根据模板的使用者的参数，产生不同的函数的实体。    根据具体类型代表模板参数生成函数实体过程叫实例化。模板是在使用时才实例化，可以自动实例化，也可以手动实例化（在函数调用时函数名与小括号之间加&lt;类型参数&gt;)。每个函数模板都会进行二次编译，第一次编译在实例化之前，检查模板代码本身是否正确，第二次是实例化过程中，结合所使用类型参数，再次检查模板代码，是否所有的代码都有效。  注意：第二次编译才会生成二进制指令，第一次编译仅仅是在编译器内部生成一个用于描述模板的数据结构。</code></pre><pre><code>#include &lt;iostream&gt;using namespace std;template &lt;typename T,typename T1&gt;T Max(T val1,T1 val2){    return val1 &gt; val2 ? val1 : val2;}class A{    int val;public:    A(int val=0):val(val) {}    bool operator&gt;(A&amp; that)    {        return val &gt; that.val;    }};int main(){    cout &lt;&lt; Max('a',100) &lt;&lt; endl;    cout &lt;&lt; Max(100,99) &lt;&lt; endl;    cout &lt;&lt; Max(3.14,2.18) &lt;&lt; endl;    A a1,a2;    Max(a1,a2);}</code></pre><h3 id="3、函数模板的隐式推断"><a href="#3、函数模板的隐式推断" class="headerlink" title="3、函数模板的隐式推断"></a>3、函数模板的隐式推断</h3><pre><code>    函数模板虽然可以手动实例化，但使用麻烦，因此一般都根据参数类型进行隐式推断模板的参数。    注意：不能隐式推断的三种情况    1、函数参数与模板参数类型没有关系    2、不允许隐式类型转换    3、返回值类型不能隐式推断</code></pre><pre><code>#include &lt;iostream&gt;using namespace std;char arr[10];template &lt;typename T&gt;T Min(T v1,T v2){    cout &lt;&lt; "T" &lt;&lt; endl;    return v1 &lt;v2 ? v1 : v2;}char Min(char ch1,char ch2){    cout &lt;&lt; "char" &lt;&lt; endl;    return ch1 &lt; ch2 ? ch1 : ch2;}template &lt;typename T,typename R&gt;R func(T a){    return 10;}int main(){    //cout &lt;&lt; Min(3.14,12) &lt;&lt; endl;    cout &lt;&lt; Min('a','h') &lt;&lt; endl;    cout &lt;&lt; Min&lt;int&gt;(3.14,12) &lt;&lt; endl;    long temp = func&lt;int,long&gt;(100);}</code></pre><h3 id="4、函数模板与默认形参之间有冲突。"><a href="#4、函数模板与默认形参之间有冲突。" class="headerlink" title="4、函数模板与默认形参之间有冲突。"></a>4、函数模板与默认形参之间有冲突。</h3><h3 id="5、普通函数与同名的模板函数构成重载，编译器会优先调用普通函数，如果实现一个与模板函数功能一致的普通函数，那么这叫做模板函数的特化。"><a href="#5、普通函数与同名的模板函数构成重载，编译器会优先调用普通函数，如果实现一个与模板函数功能一致的普通函数，那么这叫做模板函数的特化。" class="headerlink" title="5、普通函数与同名的模板函数构成重载，编译器会优先调用普通函数，如果实现一个与模板函数功能一致的普通函数，那么这叫做模板函数的特化。"></a>5、普通函数与同名的模板函数构成重载，编译器会优先调用普通函数，如果实现一个与模板函数功能一致的普通函数，那么这叫做模板函数的特化。</h3><pre><code>注意：一般char*类型都需要特化。</code></pre><h2 id="三、类模板"><a href="#三、类模板" class="headerlink" title="三、类模板"></a>三、类模板</h2><h3 id="1、类模板的定义"><a href="#1、类模板的定义" class="headerlink" title="1、类模板的定义"></a>1、类模板的定义</h3><pre><code> template &lt;typename M,typename R,typename A,typename O...&gt; class Test { public:     M val;     Test(A a)     {         O var;     }     R func(void)     {     } };</code></pre><h3 id="2、类模板的使用"><a href="#2、类模板的使用" class="headerlink" title="2、类模板的使用"></a>2、类模板的使用</h3><pre><code>    类模板的参数不支持隐式推断，必须显示指定类型参数。    类名&lt;类型...&gt; 对象;类模板分为两步进行实例化：    编译期：编译器将类模板实例化类，并生成类对象创建指令。    运行期：处理器执行类对象创建指令，将类实例化为对象。    类模板也是一种静态多态。类模板中，只有那些被调用的成员函数才实例化出代码，即产生二进制指令（调用谁实例化谁）。</code></pre><h3 id="3、类模板中的静态成员"><a href="#3、类模板中的静态成员" class="headerlink" title="3、类模板中的静态成员"></a>3、类模板中的静态成员</h3><pre><code>    静态成员需要在类外定义，这一点不改变，但与普通类的定义不同。    template &lt;typename ...&gt; 类型 类名&lt;...&gt;::成员名;</code></pre><pre><code>#include &lt;iostream&gt;using namespace std;template &lt;typename A&gt;class Test{public:    static A a;    static int b;    Test(A arg)    {        cout &lt;&lt; arg &lt;&lt; endl;    }};template&lt;typename A&gt; A Test&lt;A&gt;::a;template&lt;typename A&gt; int Test&lt;A&gt;::b;int main(){    //Test* t = new Test(100);    Test&lt;int&gt; t(100);}</code></pre><h3 id="4、递归实例化"><a href="#4、递归实例化" class="headerlink" title="4、递归实例化"></a>4、递归实例化</h3><pre><code>    类模板的参数可以是任何类型，只有该类型提供类模板所需要的功能。    类模板的实例化已经是一个有效的类型了，因此它也可以当作类模板的参数，这种叫作递归实例化。    Vectors&lt;Vectors&lt;int&gt;&gt; //二维数组    Test&lt;Test&lt;int&gt;&gt;</code></pre><h3 id="5、类的局部特化"><a href="#5、类的局部特化" class="headerlink" title="5、类的局部特化"></a>5、类的局部特化</h3><pre><code>    当类的某个成员函数不能通用，需要对特殊类型(char*)实现一个特殊版本，这叫类的局部特化。    template&lt;&gt; 类型 返回值类型 类名&lt;类型&gt;::函数名(参数)    {    }    注意：在类外实现</code></pre><h3 id="6、全类特化"><a href="#6、全类特化" class="headerlink" title="6、全类特化"></a>6、全类特化</h3><pre><code>    当需要针对某种类型对类全部实现一个特殊版本，这种叫类的全类特化。template &lt;&gt; 类名&lt;类型&gt;{    ...};</code></pre><pre><code>#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;template &lt;typename T&gt;class Compare{    T a,b;public:    Compare(T a,T b):a(a),b(b) { }    const T&amp; max(void)    {        return a &gt; b ? a : b;    }    const T&amp; min(void)    {        return a &lt; b ? a : b;    }};/*template&lt;&gt; const char* const&amp; Compare&lt;const char*&gt;::max(void){    cout &lt;&lt; "------" &lt;&lt; endl;    if(1 == strcmp(a,b))        return a;    else        return b;}*/template&lt;&gt; class Compare&lt;const char*&gt;{    const char* str1;    const char* str2;public:    Compare(const char* str1,const char* str2)    {        this-&gt;str1 = str1;        this-&gt;str2 = str2;    }    const char* max(void)    {        if(1 == strcmp(str1,str2))            return str1;        else            return str2;    }    const char* min(void)    {        if(1 == strcmp(str1,str2))            return str2;        else            return str1;    }};int main(){    Compare&lt;const char*&gt; com("ad","adf");;    cout &lt;&lt; com.max() &lt;&lt; endl;}</code></pre><h3 id="7、类模板的缺省值"><a href="#7、类模板的缺省值" class="headerlink" title="7、类模板的缺省值"></a>7、类模板的缺省值</h3><pre><code>    类模板的类型参数可以设置默认值类型，规则与函数的默认形参基本一致（设置缺省值类型靠右）。    后面的类型参数可以使用前面的类型，但前面不能使用后面的。</code></pre><h3 id="8、普通数据也可以作为模板参数"><a href="#8、普通数据也可以作为模板参数" class="headerlink" title="8、普通数据也可以作为模板参数"></a>8、普通数据也可以作为模板参数</h3><pre><code>template &lt;typename T,类型 B&gt;{   int arr[B];}给类模板一个数据，在类中就可以像使用宏明一样使用参数。注意：实例化类中提供的数据必须是常量。</code></pre><pre><code>#include &lt;iostream&gt;#include &lt;typeinfo&gt;using namespace std;template &lt;typename A=int,typename B=A&gt;class Test{public:    Test(void)    {        cout &lt;&lt; typeid(A).name() &lt;&lt; " " &lt;&lt; typeid(B).name() &lt;&lt; endl;    }};int main(){    Test&lt;&gt; t;}</code></pre><h2 id="模板的技巧"><a href="#模板的技巧" class="headerlink" title="模板的技巧"></a>模板的技巧</h2><pre><code>1、typename可以用class代替2、不能直接使用模板父类的成员#include &lt;iostream&gt;using namespace std;template &lt;class T&gt;class Base{public:     void func(void)    {        cout &lt;&lt; "bbbb" &lt;&lt; endl;    }};template &lt;typename T&gt;class Test:public Base&lt;T&gt;{public:    Test(void)    {        Base&lt;T&gt;::func();    }};int main(){    Test&lt;int&gt; t;}3、在类模板中可以定义虚函数（多态），但虚函数不能是模板函数。</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中类的继承(二)</title>
      <link href="/2019/08/31/c-zhong-lei-de-ji-cheng-er/"/>
      <url>/2019/08/31/c-zhong-lei-de-ji-cheng-er/</url>
      
        <content type="html"><![CDATA[<h2 id="一、子类的构造、析构、拷贝"><a href="#一、子类的构造、析构、拷贝" class="headerlink" title="一、子类的构造、析构、拷贝"></a>一、子类的构造、析构、拷贝</h2><pre><code>1、子类的构造在执行它的构造函数前会根据继承表的顺序执行父类的构造函数。    默认执行父类的无参构造    显示调用有参构造，在子类的构造函数后，初始化列表中显示调用父类的有参构造函数。</code></pre><a id="more"></a><pre><code>2、子类在它的析构执行完后，会根据继承表的顺序，逆顺序执行父类的析构函数。    注意：父类的指针可以指向子类对象，当通过父类指针释放对象时，只会调用父类的析构函数，而这种析构方式有可能造成内存泄漏。3、当使用子类对象来初始化新的子类对象时，会自动调用子类缺省的拷贝构造函数，并且会先调用父类缺省的拷贝构造函数。    如果子类中实现的拷贝构造，需要显式调用父类拷贝构造，否则就会调用无参构造。</code></pre><h2 id="二、私有继承、保护继承"><a href="#二、私有继承、保护继承" class="headerlink" title="二、私有继承、保护继承"></a>二、私有继承、保护继承</h2><pre><code>使用 private 方式继承父类，公开的变成私有，其他的不变（有争议），这种继承方式防止父类的成员扩散。使用 protected 方式继承父类，公开成员在子类中会变成保护的，其他不变，这种继承方式可以有效防止父类的成员扩散。子类以私有或保护方式继承父类，会禁止向上造型（子类的指针或引用不能隐式转换成父类的指针或引用，要想实现多态只能以公开方式继承父类）。</code></pre><pre><code>#include &lt;iostream&gt;using namespace std;class Base{    int a;public:    int b;protected:    int c;};class A:private Base{public:    A(void)    {//        cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; " " &lt;&lt; c &lt;&lt; endl;    }};class B:public A{public:    B(void)    {        cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; " " &lt;&lt; c &lt;&lt; endl;    }};int main(){    Base* p = new A;//    A a;//    Base a;//    cout &lt;&lt; a.a &lt;&lt; " " &lt;&lt; a.b &lt;&lt; " " &lt;&lt; a.c &lt;&lt; endl;}</code></pre><h2 id="三、多重继承、钻石继承、虚继承"><a href="#三、多重继承、钻石继承、虚继承" class="headerlink" title="三、多重继承、钻石继承、虚继承"></a>三、多重继承、钻石继承、虚继承</h2><h3 id="1、多重载继承"><a href="#1、多重载继承" class="headerlink" title="1、多重载继承"></a>1、多重载继承</h3><pre><code>在C++中一个子类可以有多个父类，在继承表中按照顺序继承多个父类中的属性和行为，并按照顺序表，调用父类的构造函数。按照从低到高的地址顺序排序父类，子类中会标记每个父类存储位置。当子类指针转换成父类的隐式指针时候，编译器会自动计算父类中的内容在子类中的位置，地址会自动进行偏移计算。</code></pre><pre><code>#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;class A{public:    int a;};class B{public:    int b;};class C{public:    int c;};class Test:public A,public B,public C{public:    Test(void)    {        a = 1;        b = 2;        c = 3;    }};int main(){    Test* p = new Test;    A* ap = p;    B* bp = p;    C* cp = p;    printf("%p %p %p  p:%p\n",ap,bp,cp,p);    cout &lt;&lt; ap-&gt;a &lt;&lt; " " &lt;&lt; bp-&gt;b &lt;&lt; " " &lt;&lt; cp-&gt;c &lt;&lt; endl;}</code></pre><h3 id="2、名字冲突"><a href="#2、名字冲突" class="headerlink" title="2、名字冲突"></a>2、名字冲突</h3><pre><code>如果父类中有同名的成员，可以正常继承，但如果直接使用，会造成歧义，需要 类名::成员名 进行访问。</code></pre><pre><code>#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;class A{public:    int num;};class B{public:    int num;};class C{public:    int num;};class Test:public A,public B,public C{public:    Test(void)    {        cout &lt;&lt; A::num &lt;&lt; endl;    }};int main(){    Test* p = new Test;}</code></pre><h3 id="3、钻石继承"><a href="#3、钻石继承" class="headerlink" title="3、钻石继承"></a>3、钻石继承</h3><pre><code>假如有一个类A，类B继承类A，类C也继承类A，类D继承B和C。一个子类继承多个父类，这些父类有一个共同的祖先，这种继承叫钻石继承。注意：钻石继承不会导致继承错误，但访问祖先类中的成员时每次需要使用 类名::成员名 ，重点是这种继承会造成冗余。</code></pre><h3 id="4、虚继承-virtual"><a href="#4、虚继承-virtual" class="headerlink" title="4、虚继承 virtual"></a>4、虚继承 virtual</h3><pre><code>当进行钻石继承时，祖先类中的内容会有冗余，而进行虚继承后，在子类中的内容只会保留一份。注意：但使用虚继承时，子类中会多了一些内容（指向从祖先类继承来的成员）。</code></pre><h3 id="5、构造函数"><a href="#5、构造函数" class="headerlink" title="5、构造函数"></a>5、构造函数</h3><pre><code>一旦进行了虚继承祖先类的构造函数只执行一次，由孙子类直接调用，祖先类的有参构造也需要在孙子类中显示调用。</code></pre><h3 id="6、拷贝构造"><a href="#6、拷贝构造" class="headerlink" title="6、拷贝构造"></a>6、拷贝构造</h3><pre><code>在虚拟继承（钻石）中祖先类拷贝构造也由孙子类直接调用，子类中不再调用祖先类的拷贝构造，在手动实现的拷贝构造时（深拷贝），祖先类中的内容也由孙子类负责拷贝，同理赋值构造也一样。</code></pre><pre><code>#include &lt;iostream&gt;using namespace std;class A{public:    int a;    A(void)    {        cout &lt;&lt; "A类的构造函数" &lt;&lt; endl;    }    A(int num)    {        cout&lt;&lt;"A有参构造"&lt;&lt;endl;    }};class B:virtual public A{public:    B(void)    {        cout&lt;&lt;"B的构造"&lt;&lt;endl;    }};class C:virtual public A{public:    C(void)    {        cout &lt;&lt; "C的构造" &lt;&lt; endl;    }};class D:virtual public B,virtual public C{public:    D(void)    {        cout &lt;&lt; "D的构造" &lt;&lt; endl;    }};int main(){    //A a;    //B b;    //C c;    D d;//    cout &lt;&lt;sizeof(A) &lt;&lt;" "&lt;&lt; sizeof(B) &lt;&lt;" "&lt;&lt;sizeof(C)&lt;&lt;" " &lt;&lt;sizeof(D)&lt;&lt; endl;//    cout &lt;&lt; d.B::a &lt;&lt; endl;}</code></pre><h2 id="四、虚函数、覆盖、多态"><a href="#四、虚函数、覆盖、多态" class="headerlink" title="四、虚函数、覆盖、多态"></a>四、虚函数、覆盖、多态</h2><h3 id="1、虚函数"><a href="#1、虚函数" class="headerlink" title="1、虚函数"></a>1、虚函数</h3><pre><code>类的成员函数前加 virtual 这种函数就叫做虚函数。</code></pre><h3 id="2、覆盖"><a href="#2、覆盖" class="headerlink" title="2、覆盖"></a>2、覆盖</h3><pre><code>子类会覆盖父类的虚函数。</code></pre><h3 id="3、多态"><a href="#3、多态" class="headerlink" title="3、多态"></a>3、多态</h3><pre><code>当子类覆盖了父类的虚函数时，通过父类指针指向子类对象时，调用虚函数，会根据具体的对象是谁来决定执行谁的函数，这就是多态。</code></pre><pre><code>#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;using namespace std;class Base{public:    virtual void func(void)    {        cout &lt;&lt; "我是Base的func函数"&lt;&lt;endl;    }};class A:public Base{public:    void func(void)    {        cout&lt;&lt;"我是类A的func函数" &lt;&lt; endl;    }};class B:public Base{public:    void func(void)    {        cout&lt;&lt;"我是类B的func函数" &lt;&lt; endl;    }};class C:public Base{public:    void func(void)    {        cout&lt;&lt;"我是类C的func函数" &lt;&lt; endl;    }};int main(){/*覆盖    A* a = new A;    Base* p = a;    Base* b = new Base;    b-&gt;func(); // 并没有消失    a-&gt;func(); // 调用子类函数    p-&gt;func(); // 如果父类的函数是虚函数，调用子类函数*/    srand(time(NULL));    // 这就是多态    Base* arr[] = {new A,new B,new C};    arr[rand()%3]-&gt;func();}</code></pre><h2 id="五、覆盖和多态的条件"><a href="#五、覆盖和多态的条件" class="headerlink" title="五、覆盖和多态的条件"></a>五、覆盖和多态的条件</h2><h3 id="1、覆盖的条件"><a href="#1、覆盖的条件" class="headerlink" title="1、覆盖的条件"></a>1、覆盖的条件</h3><pre><code>    必须是虚函数    必须是父子类之间    函数签名必须相同（参数列表完全一致，const属性也会影响覆盖的结果）    返回值必须是同类型或父子类（子类的返回值要能向父类隐式转换）    访问属性不会影响覆盖    常函数属性也会影响覆盖</code></pre><pre><code>#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;using namespace std;class Base{public:    virtual Base* func(void)    //virtual void func(void)    {        cout &lt;&lt; "我是Base的func函数"&lt;&lt;endl;    }};class A:public Base{public:    A* func(void)    //在覆盖版本的函数中，所得到的this指针依然是实际对象地址，依然能够调用子类中的函数。    //void func(int num,char* str)    {        cout&lt;&lt;"我是类A的func函数" &lt;&lt; endl;    }};int main(){    A* a = new A;    Base* p = a;    p-&gt;func();}    </code></pre><h3 id="2、重载、隐藏、覆盖（重写）的区别"><a href="#2、重载、隐藏、覆盖（重写）的区别" class="headerlink" title="2、重载、隐藏、覆盖（重写）的区别"></a>2、重载、隐藏、覆盖（重写）的区别</h3><pre><code>    重载：同一作用域下的同名函数，函数签名不同（类型、个数、顺序、常函数等），构成重载关系。    覆盖：符合一系列条件。    隐藏：父子类之间的同名成员如果没有形成覆盖，且能通过编译，必定构成隐藏。</code></pre><h3 id="3、多态的条件"><a href="#3、多态的条件" class="headerlink" title="3、多态的条件"></a>3、多态的条件</h3><pre><code>    1.父子类之间有的函数有覆盖关系。    2.父类的指针或引用指向子类的对象。</code></pre><h3 id="4、在构造、析构函数中调用虚函数"><a href="#4、在构造、析构函数中调用虚函数" class="headerlink" title="4、在构造、析构函数中调用虚函数"></a>4、在构造、析构函数中调用虚函数</h3><pre><code>    在父类的构造函数中调用虚函数，此时子类还没有创建完成（回顾构造函数的调用过程），因此只能调用父类的虚函数，而不是覆盖版本的虚函数。    在父类的析构函数中调用虚函数，此时子类已经释放完成，因此只能调用父类的虚函数，而不是覆盖版本的虚函数。</code></pre><pre><code>#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;using namespace std;class Base{public:    Base(void)    {        func();    }    virtual void func(void)    {        cout &lt;&lt; "我是Base的func函数"&lt;&lt;endl;    }    ~Base(void)    {        func();    }};class A:public Base{public:    A(void)    {        func();    }    void func(void)    {        cout&lt;&lt;"我是类A的func函数" &lt;&lt; endl;    }    ~A(void)    {        func();    }};int main(){    A aa;//    A* a = new A;//    Base* p = a;//    p-&gt;func();}</code></pre><h2 id="六、纯虚函数和抽象类"><a href="#六、纯虚函数和抽象类" class="headerlink" title="六、纯虚函数和抽象类"></a>六、纯虚函数和抽象类</h2><h3 id="1、纯虚函数"><a href="#1、纯虚函数" class="headerlink" title="1、纯虚函数"></a>1、纯虚函数</h3><pre><code>在虚函数的声明的后面添加=0，这种虚函数就叫做纯虚函数，可以不实现，但如果实现必须在类外（只能在父类的构造函数、析构函数中调用）。virtual 返回值 函数名(参数) = 0;</code></pre><pre><code>#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;class Base{public:    Base(void)    {        func();    }    // 纯虚函数    virtual void func(void) = 0;    ~Base(void)    {        func();    }};class A:public Base{public:    void func(void)    {        cout &lt;&lt; "我是纯虚函数的覆盖"&lt;&lt;endl;    }};void Base::func(void){    cout&lt;&lt; "我是虚函数" &lt;&lt; endl;}int main(){    A a;    a.func();    //Base b;    //b.func();}</code></pre><h3 id="2、抽象类"><a href="#2、抽象类" class="headerlink" title="2、抽象类"></a>2、抽象类</h3><pre><code>成员函数中有纯虚函数，这种类叫抽象类，抽象类不能实例化（不能创建对象）。抽象类必须被继承且纯虚函数被覆盖后，由子类实例化对象。如果继承抽象类，但没有覆盖纯虚函数，那么子类也将成为抽象类，不能实例化。</code></pre><h3 id="3、纯抽象类"><a href="#3、纯抽象类" class="headerlink" title="3、纯抽象类"></a>3、纯抽象类</h3><pre><code>所有成员函数都是纯虚函数，这种只能被继承的类叫纯抽象类。这种类一般用来设计接口，这种类在子类被替换后不需要修改或少量的修改即可继续使用。</code></pre><pre><code>#include &lt;iostream&gt;using namespace std;class Base{public:    virtual void show(void) = 0;};class A:public Base{public:    void show(void)    {        cout &lt;&lt; "我是类A的show函数" &lt;&lt; endl;    }};class B:public Base{public:    void show(void)    {        cout &lt;&lt; "我是类B的show函数" &lt;&lt; endl;    }};class C:public Base{public:    void show(void)    {        cout &lt;&lt; "我是类C的show函数" &lt;&lt; endl;    }};enum ClassType{typeA,typeB,typeC};// 工厂类模式Base* creat_object(ClassType type){    switch(type)    {        case typeA: return new A;        case typeB: return new B;        case typeC: return new C;        default: return NULL;    }}int main(){    Base* p = creat_object(typeA);    p-&gt;show();}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 类 </tag>
            
            <tag> 继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中类的继承(一)</title>
      <link href="/2019/08/31/c-zhong-lei-de-ji-cheng-yi/"/>
      <url>/2019/08/31/c-zhong-lei-de-ji-cheng-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、类的继承"><a href="#一、类的继承" class="headerlink" title="一、类的继承"></a>一、类的继承</h2><pre><code>1、共性与个性    表达不同类型事物之间公有的属性和行为。    个性用于刻画每种事物特有的属性和行为。2、共性表示为父类（基类），个性表示为子类（派生类）。    子类继承自父类    基类派生出子类</code></pre><a id="more"></a><h2 id="二、继承的基本语法"><a href="#二、继承的基本语法" class="headerlink" title="二、继承的基本语法"></a>二、继承的基本语法</h2><pre><code>1、继承表一个子类可以同时继承零到多个父类，每个父类的继承方式可以相同也可以不同。class 子类：继承方式1 父类1,继承方式2 父类2,...{}2、继承方式    public 公有继承：父类的特性可通过子类向外扩展。    private 私有继承：父类的特性只能为子类所有。    protected 保护继承：父类的特性只能在继承链内扩展。</code></pre><h2 id="三、继承的基本特点"><a href="#三、继承的基本特点" class="headerlink" title="三、继承的基本特点"></a>三、继承的基本特点</h2><pre><code>1、公共特点（所有继承都有的特点）    子类对象可以当作父类对象使用，子类对象与父类没有本质上的区别。    子类的逻辑空间小于父类，但它的物理空间要大于等于父类。    子类对象 IS A 父类对象2、向上和向下转换（造型）    从子类到父类：子类的指针或引用可以隐式转换成父类的指针或引用，这是一种缩小类型的转换，对于编译器来说是安全的。    从父类到子类：父类的指针或引用不可以转换成子类的指针或引用，这是一种扩大类型的转换，在编译器看来是危险的。（子类的指针指向父类的对象，不安全）    编译器仅仅是检查指针或引用的数据类型，而对实际引用的目标对象不关心（构成多态的基础）。    类型一致：父类的指针或引用实际的目标类型是否需要转换成实际的指针或引用由程序自己决定。3、子类会继承父类的所有成员（公有，私有，保护）4、子类会隐藏父类的同名成员    1.可以通过域限定符 父类::隐藏成员 进行访问父类中的隐藏成员    2.可以使用父类的指针或引用来指向子类对象，然后访问父类中的隐藏成员。5、虽然子类继承所有父类中的成员，但不能访问父类中的私有成员。</code></pre><h2 id="四、继承方式影响访问控制"><a href="#四、继承方式影响访问控制" class="headerlink" title="四、继承方式影响访问控制"></a>四、继承方式影响访问控制</h2><p><img src="https://img-blog.csdnimg.cn/20190819182508729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lrYXJvc181MjE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190819164034499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lrYXJvc181MjE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><pre><code>#include &lt;iostream&gt;using namespace std;class A{private:    int a;    friend void f_show(A a);public:    int b;    A(void)    {        a = 1;        b = 2;        c = 3;        cout&lt;&lt;"A构造"&lt;&lt;endl;    }    void show(void)    {        cout &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt;endl;    }protected:    int c;};void f_show(A a){    cout&lt;&lt;  a.a&lt;&lt;a.b&lt;&lt;a.c &lt;&lt;endl;}class B:public A{public:    int b;    B(void)    {        b = 4;        //cout &lt;&lt; a &lt;&lt; endl;        cout&lt;&lt;"B构造 "&lt;&lt;" "&lt;&lt;b&lt;&lt;" "&lt;&lt;c&lt;&lt;endl;    }    void show(void)    {        cout&lt;&lt; A::b &lt;&lt; " "&lt;&lt; b&lt;&lt;" "&lt;&lt; c &lt;&lt;endl;    }};/*class B:private A{};class B:protected A{};*/int main(){    B b;    // 子类的指针或引用可以隐式转换成父类的指针或引用    A* a = &amp;b;    A aa;    f_show(aa);    cout&lt;&lt;b.b&lt;&lt;endl;    a-&gt;show();    b.show();    //cout&lt;&lt;b.c&lt;&lt;endl;    b.A::show();    // 父类的指针或引用不能转换成子类的指针或引用    //error  B* p = a;    cout&lt;&lt; sizeof(B)&lt;&lt;endl;}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 类 </tag>
            
            <tag> 继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言基础知识</title>
      <link href="/2019/08/29/c-yu-yan-ji-chu-zhi-shi/"/>
      <url>/2019/08/29/c-yu-yan-ji-chu-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="C语言关键字："><a href="#C语言关键字：" class="headerlink" title="C语言关键字："></a>C语言关键字：</h2><pre><code>unsigned signed bool void char short int long double float struct enum union typedef sizeofif else for switch case default while do break continue gotoextern register volatile auto const static return</code></pre><a id="more"></a><h2 id="常用的Linux系统命令："><a href="#常用的Linux系统命令：" class="headerlink" title="常用的Linux系统命令："></a>常用的Linux系统命令：</h2><pre><code>touch/cat/more/head/tall/rm/cp/mvmkdir/rmdir/cd/ls/tarifconfig/ping/telnet/ssh/ftp</code></pre><h2 id="vim文本编辑器："><a href="#vim文本编辑器：" class="headerlink" title="vim文本编辑器："></a>vim文本编辑器：</h2><pre><code>在终端下依靠键盘操作使用的文本编辑器。三大主要模式：正常模式、插入模式、命令模式常用快捷键：Ctrl+x Ctrl+z Ctrl+c教程：vimtutor</code></pre><h2 id="C语言介绍："><a href="#C语言介绍：" class="headerlink" title="C语言介绍："></a>C语言介绍：</h2><pre><code>发明C语言的目的是什么长盛不衰优缺点、特点C语言三剑客：《C语言陷阱和缺陷》、《C和指针》、《C专家编程》、《C程序设计语言》、</code></pre><p>《C Primer Plus》、《必然》、《白说》</p><h2 id="编译器介绍："><a href="#编译器介绍：" class="headerlink" title="编译器介绍："></a>编译器介绍：</h2><pre><code>编译器就一个特殊的程序，把负责把C代码（文本文件）编译成可执行的二进制文件。它由：预处理器、编译器、链接器组成常用的参数：-E -c -S -o -std -l -D -Werror -WallE    激活预处理；头文件、宏等展开（.i文件）S    激活预处理、编译；生成汇编代码（.s文件）c    激活预处理、编译、汇编；生成目标文件（.o文件）o    生成目标Wall    打开编译告警（所有）g    嵌入调试信息，方便gdb调试《程序员的自我修养》</code></pre><h2 id="数据类型："><a href="#数据类型：" class="headerlink" title="数据类型："></a>数据类型：</h2><pre><code>整型：unsigned、signedchar,short,int,long,long long实型：float,double,long double字符：char布尔：bool取值范围：char,short,int各类型的字节数：各类型的占位符：long double（%LF）</code></pre><h2 id="进制转换："><a href="#进制转换：" class="headerlink" title="进制转换："></a>进制转换：</h2><pre><code>为什么需要二进制：因为现在的计算机由大规模集成电路构成，计算单元只能识别高低电流这种数据，因此只能使用二进制数据。为什么需要八进制：为了方便记录二进制，由于历史原因八进制数据还在使用。为什么需要十六进制：相当于升级版的八进制，由于计算机的高速发展，八进制已经无法满足需要。十进制转换成二进制：    求余：把十进制数据不停的用2求余，逆序记录求余的结果。        189 % 2 = 1        94 % 2 = 0        47 % 2 = 1        23 % 2 = 1        11 % 2 = 1        5 % 2 = 1        2 % 2 = 0        1 % 2 = 1        10111101    求权：128 64 32 16 8 4 2 1二进制转换成十进制：    2的不同次方相加。二进制转换成八进制：三位二进制转换成一位八进制    10 111 101 = 0275    128 56 5 = 189二进制转化成十六进制：四位二进制转换成一位十六进制    10 &lt;=&gt; a    1011 1101 = 0xbd0b10111101 二进制0275 八进制0xbd 十六进制数据在内存是如何存储的：    数据分为原码、反码、补码，内存中存储的是数据的补码。原码：数据直接转换成的二进制（无论正负）反码：将原码按位求反得到反码补码：    正：原码    负：反码+1补码：10111101 char    10111100    01000011 -67</code></pre><h2 id="常量与变量"><a href="#常量与变量" class="headerlink" title="常量与变量"></a>常量与变量</h2><pre><code>常量：程序运行过程中不可改变的数据    字面值    100 int类型    100L long    100U unsigned int    100LU unsigned long    100LL long long    100LLU unsigned long long    3.14 double    3.14F float    3.14LF long double    枚举值    宏常量    具有const属性的被初始化过的全局变量变量：类型 变量名；注意：取名规则，见名知意    容器、数据</code></pre><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><pre><code>if else,switch,for,while,do while,break,continue,goto注意：大括号不要省略，分号不要多加《C语言编码规范-华为》《C++语言编程规范-谷歌》如何判断XX类型是否是“零值”?float,bool,int,char,int* p;if(0.000001 &gt; f &amp;&amp; f &gt;-0.000001)if(flag)if(0 == num)if('\0' == ch)if(NULL = p)阅读、安全角度思考。</code></pre><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><pre><code>C语言中只有一维数组，多维数组都是使用一维数组模拟的。数组的越界：一切正常、段错误、脏数据。char str[11] = "hello,world";变长数组：数据的长度填写变量，编译时不能确定，程序运行期间可以变化，而执行数组定义语句时长度才固定下来。    优点:可根据实际情况定义数组的长度，从而节约内存    缺点：不能初始化。int arr[10];arr &lt;=&gt; int *int arr[3][4]arr &lt;=&gt; int (*)[4];</code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><pre><code>函数是C语言中管理代码的最小单位，命名空间独立，栈空间独立。函数被调用时开辟栈内存，函数结束后释放栈内存。声明：返回值 函数名（类型1，类型2，...）;定义：返回值 函数名（类型1 参数名1，类型2 参数名2，...){    函数体}注意:函数的定义如果出现调用之前，声明可以忽略注意：调用函数时如果没有找到函数声明，也没有定义，编译器也不报错，而是先猜测函数的格式，链接时在尝试寻找函数的定义。    return 语句只是把数据存储到一个特定的位置，当函数运行结束后，调用者就可以从这个位置获取到返回值。        函数有返回值（格式），而没写return语句，调用者会得到一个不确定的返回值。常见编译错误：    隐式声明函数，没有找到函数声明和定义。1    undefined reference to '',有函数声明，但无函数定义函数的本质：函数就是存储在代码段中的一段数据（二进制指令的集合），函数名就是这段数据的开始位置    因此函数名就是地址，可以定义指向这段数据的指针变量，    返回值 （*函数指针） （类型1，类型2，...）；    函数的传参：        1、只能值传递（内存拷贝），使用指针可提高效率（const int *）        2、函数之间共享变量，全局变量（尽量少用），指针（注意安全）        3、数组当作函数的参数时就蜕变成了指针（长度丢失），额外增加一个参数传递数组长度。</code></pre><h2 id="修饰变量的关键字"><a href="#修饰变量的关键字" class="headerlink" title="修饰变量的关键字"></a>修饰变量的关键字</h2><pre><code>auto：用来修饰自动创建、释放的变量（局部变量、块变量），不加就代表加。    注意：静态变量、全局变量不能用它来修饰。static：    限制作用域：全局变量、普通函数    改变存储位置：把局部变量、块变量的存储位置由栈改为bss、data    延长生命周期：把局部变量、块变量的生命周期延长与全局变量一样。    static int fun(void);const：为数据提供一种"保护"机制,变量被它修饰后就不能显示修改。    也可以修饰函数的参数、返回值等。    const int fun(void);volatile:告诉编译器此变量的值不稳定、易变（不优化变量的取值）。    多线程共享变量、硬件编程（裸机、驱动）register:申请把变量的存储位置改为寄存器，但申请不一定成功    注意：被它修饰过的变量不能取地址extern：声明变量，用于不同.c之间共享全局变量（只能解决编译时问题）注意：全局变量、局部变量、块变量的变量名可以同名，由于作用域不同，会互相屏蔽。    块变量 &gt; 局部变量 &gt; 全局变量 （块变量屏蔽同名的局部变量）</code></pre><h2 id="程序在内存的分段："><a href="#程序在内存的分段：" class="headerlink" title="程序在内存的分段："></a>程序在内存的分段：</h2><pre><code>代码段 test：存储的是代码所编译成的二进制指令、字符串字面值、常量    具有只读属性，一旦修改会发生段错误。全局数据段 data：初始化过的全局变量、静态变量bss段（静态数据段）：未初始化的全局变量、静态变量    程序运行前会清理为0；栈 stack：存储局部变量、块变量、大小有限，安全。    由操作系统管理，以函数为单位使用（函数调用结束后自动释放）。堆 heap：一般由程序员手动管理（让系统去映射)，与指针配合使用，足够大，使用麻烦，释放的时间受控制    但不安全，容易产生内存碎片、内存泄漏。</code></pre><h2 id="指针："><a href="#指针：" class="headerlink" title="指针："></a>指针：</h2><pre><code>什么是指针：指针是一种数据类型（无符号整数，代表内存编号），使用它定义指针变量。    0~4G（32个1）4294967295 byte什么情况下使用指针：    1、函数之间共享变量（全局变量有命名冲突，不会被释放，浪费内存)    2、优化传递效率        因为C语言采用的是值传递（内存拷贝），会随着变量字节数的增加而降低运行效率。        而传递变量的地址，永远只拷贝4|8字节。        void func(const int * p);        但使用指针变量的值可能会被修改，可以配合const进行保护。        3、配合堆内存如何使用指针：    定义：类型 *变量名_p;        1、与普通变量一样，默认值不确定，为了安全一般初始化NULL。        2、一个*只能定义一个指针变量            int *p1,*p2;        3、指针变量与普通的用法不同，为了避免混用，一般从名字上加以区别。        4、指针变量的类型决定了解决引用时访问的字节数。    赋值：变量名_p = 地址；        int* p = NULL;        1、注意地址的类型        2、void*可以与任意类型的指针进行自动转换（C++中不可以)        3、要保障地址与物理内存有对应关系（映射过）。    解引用：*p；        根据指针变量中存储的内存编号，而访问内存中的数据。        这个过程可以会有段错误，但这是由于赋值了有问题的地址。使用指针要注意的问题：    1、野指针：指向的目标不确定，解引用时不一定会出错，但未知的危险最可怕。        而且野指针一旦产生就无法分辨，而预防的方法就是不制造野指针。        1、定义指针时一定要初始化。        2、指向的目标被释放后，要及时置空。        3、不要指向随时可能被释放的目标。    2、空指针：指针变量的值等于NULL，对这个地址解引用访问时，一定会产生段错误。        因为它存储的是操作系统重启时所需要的数据。        而预防的方法就是解引用前判断（来历不明） if（NULL == p）指针的运算：    指针+/-整数 = 指针+/-(宽度)*整数    指针-指针 = (指针-指针)/宽度指针与数组名：    1、数组名就一个特殊的地址，它就代表数组的第一个元素的首地址，也能当指针使用。        arr[i] &lt;=&gt; *(地址+i);        因此指针也能使用[]运算符    2、指针与目标内存是指向关系，而数组名是对应关系。    3、数组当函数的参数就蜕变为了指针变量，长度丢失，安全性不保障。        void fun(int* const arr,size_t len);指针与const的配合使用：    const int* p;    int const * p;    int * const p;    const int * p;    int const * const p;指针的高级应用：    指针数组：可以把无序的离散的数据，归纳到一起。    数组指针：专门指向数组指针    二级指针：指向指针的指针    函数指针：指向函数的指针</code></pre><h2 id="字符串："><a href="#字符串：" class="headerlink" title="字符串："></a>字符串：</h2><pre><code>由字符组成的串型数据结构，它的结束标志是'\0'。字符串存在的形式：    字符数组：char arr[5] = {'a','b','c','d'};        一般存储在栈，也可以存储在堆。        要考虑'\0'的位置    字符串字面值：由双引号包括的若干个字符，"hehe"。        以地址形式存在，需要使用const char* str;指针指向。        数据存在只读段，如果强行修改只会出现段错误。        背后隐藏着'\0';    char str[] = "hehe";    一般使用字符串字面值来初始化字符数组。字符串的输出：    printf %s,puts,fprintf字符串的输入：    scanf %s:不能输入空格    gets:不限制长度    fgets：可能会接受到'\n',或者输入缓冲区中残留数据字符串常见的操作：    strlen/strcat/strcpy/strcmp    strncat/strncpy/strncmp    memset/memcpy/strstr/strchr    sprintf/sscanf 用于拼接/解析字符串，非常好用    字符数据 -&gt; 数据 计算 数据 -&gt; 字符数据</code></pre><h2 id="堆内存管理"><a href="#堆内存管理" class="headerlink" title="堆内存管理"></a>堆内存管理</h2><pre><code>C语言中没有内存管理的语句，只能借助标准库中的函数进行管理堆内存。void *malloc(size_t size);void free(void *ptr);void *calloc(size_t nmemb, size_t size);void *realloc(void *ptr, size_t size);当向malloc首次申请内存时，malloc手中也没有内存，malloc会向系统申请，系统会映射33页内存交给malloc管理，之后再向malloc申请内存，malloc会直接从33页内存中分配，直到33页用完，再向操作系统申请。    访问malloc分配的内存时，可以越界，但不要超过33页范围。内存泄漏：    1、指针管理失误，指向其他位置。    2、free语句没有执行到。    3、free语句忘记写。    就内存没释放，有申请新内存，导致可用的内存越来越少，速度越来越慢。    前提：程序没有结束，当程序结束后属于它的所有资源都会被系统回收。内存碎片：    已经释放的内存，但不能被再次使用，这叫内存叫做内存碎片。       内存碎片不是错误，它是由于内存的释放时间和分配时间不协调造成的。       内存碎片无法避免（天然形成的），只能尽量减少：           1、尽量使用栈内存，只有在数据量比较多的时候再使用堆内存。           2、尽量申请大块内存自己管理。           3、不要频繁的申请释放内存。</code></pre><h2 id="预处理指令："><a href="#预处理指令：" class="headerlink" title="预处理指令："></a>预处理指令：</h2><pre><code>把C代码翻译成标准的C代码叫预处理、负责翻译的程序叫预处理器、被翻译的代码叫预处理指令。查看预处理的结果：    gcc -E code.c 直接查看预处理的结果    gcc -E code.c -o code.i 把预处理的结果保存到文件中宏定义：    宏常量：用一个有意义的单词代表一个字面值数据在代码中使用，在预处理时把单词替换成数据        优点：提高可读性、安全、扩展方便    宏函数：宏函数不是真正的函数，是带参数的宏，只是使用的方法类似函数        预处理时参数会代入到表达式中，宏名会替换成后面的表达式。        优点:运行速度快（没有参数传递），类型通用，只有极精简的代码段才适合定义宏函数        缺点：不会进行类型检查，也没有返回值，只有一个计算结果，大量使用会增加代码段的冗余。    预定义的宏：        __FILENAME__        __func__        __DATE__        __TIME__        __LINE__    条件编译：        #if        #elif        #else        #endif        #ifndef        #ifndef        头文件卫士</code></pre><h2 id="复合数据类型："><a href="#复合数据类型：" class="headerlink" title="复合数据类型："></a>复合数据类型：</h2><pre><code>结构 struct设计数据类型typedef struct Student{    char name[20];    char sex;    short age:1;}Student;定义结构变量    Student stu;    Student* stup = malloc(sizeof(Student));访问结构成员    stu.name,stu.sex,stu.age    stup-&gt;name,stup-&gt;sex,stup-&gt;age计算结构的字节数：    注意：成员的顺序不同会影响结构的字节数。    对齐：假定从零地址开始，每成员的起始地址编号，必须是它本身字节数的整数倍。    补齐：结构的总字节数必须是它最大成员的整数倍。    注意：在Linux系统下计算补齐、对齐时，成员超过4字节按4字节计算联合 union    从语法上来说与结构的用法基本类似，每个成员都从零地址开始，所有成员共有一块内存。    1、使用联合判断大小端    2、联合的总字节数计算，不需要对齐，但有补齐枚举 enum    值受限的int类型，把变量合法的值列举出来，除此以外不能等于其他的值    枚举值是常量，可以直接使用在case后，常与switch语句配合使用</code></pre><h2 id="文件操作："><a href="#文件操作：" class="headerlink" title="文件操作："></a>文件操作：</h2><pre><code>文件分类：    文本文件：记录的是字符串的二进制    二进制文件：直接把数据补码记录到文件中文件打开：    FILE *fopen(const char *path, const char *mode);    "r"    以只读方式打开文件，如果文件不存在则打开失败，返回值为空。    "r+" 在"r"的基础上增加写权限。    "w" 以只写方式打开文件，如果文件不存在则创建，如果文件存在则把内容清空。    "w+" 在"w"的基础上增加读取权限。    "a" 以只写方式打开文件，如果文件不存在则创建，如果文件存在则把内容保留，与"w"区别是当有新数据写入，会追加到文件的末尾。    "a+" 在"a"的基础上增加读权限。     "b" 在linux系统下没有用，表示以二进制格式打开文件。        在Windows系统下不加b '\n' 写到文件中 系统会写入'\n\r',加b则写'\n'时只写入'\n'.读写文本内容：    int fprintf(FILE *stream, const char *format, ...);    功能：把数据以文本形式写入到文件中    stream：文件指针，fopen函数的返回值    format：格式化控制符，点位符等    ...：要写入的变量。    返回值：成功写入的变量个数。        int fscanf(FILE *stream, const char *format, ...);    功能：从文件中读取数据到变量，要求文件的内容是字符。    stream：文件指针，fopen函数的返回值    format：格式化控制符，点位符等    ...：变量的地址    返回值：成功读取到返回0，失败返回-1。        读写二进制内容：    size_t fwrite(const void *ptr, size_t size, size_t nmemb,FILE *stream);    功能：内存中的数据，以二进制形式写入到文件中。    ptr：要写入的内存的首地址    size：要写入的字节数    nmemb：要写入的次数    stream：文件指针，fopen函数的返回值    返回值：成功写入的次数        size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);    功能：从文件中以二进制方式读取数据到内存中。    ptr：用来存放数据的内存首地址    size：要读取的字节数    nmemb：要读取的次数    stream：文件指针，fopen函数的返回值    返回值：成功读取的次数文件位置指针：    每个打开的文件系统都会用一个指针记录着它的读写位置，这个指针指向哪里，    接下来对文件的读取就会从哪里继续，指针的位置会随着文件的读写自动发生变化文件结构体中有一个成员记录文件的读写位置，称它位文件位置指针，有些情况下需要调整它的位置，获取到正确的数据。    int fseek(FILE *stream, long offset, int whence);    功能：根据基础位置＋偏移值调整文件指针的位置。    stream：文件指针，fopen函数的返回值    offset：可以为正负,正往右(偏移值)    whence：(基础位置)        SEEK_SET 文件头        SEEK_CUR 当前位置        SEEK_END 文件尾    long ftell(FILE *stream);    功能：返回文件位置指针所在的位置。    void rewind(FILE *stream);    功能：把文件位置指针调整到开头</code></pre><h2 id="多文件编程："><a href="#多文件编程：" class="headerlink" title="多文件编程："></a>多文件编程：</h2><pre><code>随着代码量的增加，不得不把代码分成若干个.c文件编写，这样能够给文件。。。但缺点是不方便编译，需要借助编译脚本。如何进行多文件编译：根据功能、责任分成若干个.c文件，然后为每个.c文件配备一个辅助文件.h然后单独编译每个.c文件，    生成目标文件.o，然后再把.o文件合并成可执行文件。头文件中应该写什么：    1、头文件卫士    2、宏常量、宏函数    3、结构、联合、枚举的设计    4、变量、函数的声明    5、static函数的实现</code></pre><h2 id="编译脚本："><a href="#编译脚本：" class="headerlink" title="编译脚本："></a>编译脚本：</h2><pre><code>把用于编译的命令记录到文件中（makefile/Makefile），在终端里执行make程序时，make程序会自动读取当前目录中的。。。make程序会监控每个文件的最后修改时间，如果没有被修改的文件不需要重新编译，这样可以节约大量的时间注意：一定要使用tab缩进</code></pre><h2 id="GDB调试："><a href="#GDB调试：" class="headerlink" title="GDB调试："></a>GDB调试：</h2><pre><code>1、设置ubuntu系统，当段错误时产生core    ulimit -c unlimited2、编译时增加-g参数3、再次执行新编译的程序，重新产生core文件4、gdb a.out core 进行调试    run/where</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础知识(三)</title>
      <link href="/2019/08/29/c-ji-chu-zhi-shi-san/"/>
      <url>/2019/08/29/c-ji-chu-zhi-shi-san/</url>
      
        <content type="html"><![CDATA[<h2 id="一、this指针"><a href="#一、this指针" class="headerlink" title="一、this指针"></a>一、this指针</h2><pre><code>类的成员变量单独存储在每个类对象中，成员函数存储在代码段中，所有的类对象共享一份成员函数。成员函数是如何区别调用它的是哪个类对象的？答：借助了this指针，类的每个成员函数都有一个隐藏的参数this指针，它指向类对象。</code></pre><a id="more"></a><pre><code>类的构造函数中也同样有this指针，指向的就是正在构造的这个对象。在类中（成员、构造、析构函数）对成员变量、成员函数的访问都是借助了this指针。this指针是隐藏的，但也可以显示使用：    1、参数与成员一样时，使用this可以区别出成员与参数名。    2、在成员函数中如果想返回当前对象的指针、引用等，可以使用this指针实现。    3、将this指针作为函数的参数，从一个对象传递给另一个其它类对象，可以实现对象间的交互。</code></pre><pre><code>#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;class User{    char name[20];    char pass[7];public:    User(const char* name,const char* pass)    {        strcpy(this-&gt;name,name);        strcpy(this-&gt;pass,pass);        //show();    }    User&amp; func(void)    {        return *this;    }    void show(void)//隐藏this指针    {        cout&lt;&lt; name &lt;&lt; " "&lt;&lt; pass &lt;&lt;endl;    }    User* this = const this;};int main(){    User u1("aaa","123");    User u2("bbb","321");    User&amp; u3 = u1.func();    u1.show();    u2.show();    u3.show();}</code></pre><h2 id="二、常函数"><a href="#二、常函数" class="headerlink" title="二、常函数"></a>二、常函数</h2><pre><code>在函数的参数列表与函数体之间有const修饰的函数，这个const其实就是在修饰this指针。不能在常函数内修改成员变量的值，普通成员函数可以调用常函数，而常函数只能调用常函数。如果在常函数中真的需要修改某个成员变量的数据，那么需要这个成员被 mutable修饰。</code></pre><pre><code>mutable char name[20];void show(void) const//隐藏this指针{    strcpy(name,"------");    cout&lt;&lt; name &lt;&lt; " "&lt;&lt; pass &lt;&lt;endl;}</code></pre><p>   普通函数不能声明为常函数（因为没有this指针）。</p><h2 id="三、析构函数"><a href="#三、析构函数" class="headerlink" title="三、析构函数"></a>三、析构函数</h2><pre><code>1、特殊的成员函数     ~类名(void)    {    }    没有参数、没有返回值、不能重载2、谁来调用    析构函数会在销毁对象时自动调用，在对象的整个生命周期内最多被调用一次。3、析构函数负责什么    负责释放在构造函数期间获取的所有资源，它的执行过程：    1.先执行析构函数本身代码    2.调用成员类的析构函数    3.调用父类的析构函数</code></pre><pre><code>#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;using namespace std;class A{public:    A(void)    {        cout &lt;&lt; "A 's 构造" &lt;&lt;endl;    }    ~A(void)    {        cout&lt;&lt;"A 's 析构"&lt;&lt;endl;    }};class B{public:    B(void)    {        cout &lt;&lt; "B 's 构造" &lt;&lt;endl;    }    ~B(void)    {        cout&lt;&lt;"B 's 析构"&lt;&lt;endl;    }};class User : public A{    char* name;    char* pass;    B b;    //char name[20];    //char pass[10];public:    User(const char* name,const char* pass)    {        this-&gt;name = new char[strlen(name)+1];        strcpy(this-&gt;name,name);        this-&gt;pass = new char[strlen(pass)+1];        strcpy(this-&gt;pass,pass);        cout&lt;&lt; "构造"&lt;&lt;endl;        cout&lt;&lt;"-----"&lt;&lt;endl;    }/*    User(void)    {        cout&lt;&lt;"构造"&lt;&lt;endl;    }*/    ~User(void)    {        delete name;        delete pass;        cout&lt;&lt;"析构"&lt;&lt;endl;    }};int main(){    User* u1 = new User("asd","ads");    //exit(0);    delete u1;    //User u2;}</code></pre><p>   4.缺省的析构函数<br>        如果一个类没有实现析构函数，编译器会自动生成一个具有析构函数功能的二进制指令，它负责释放编译器能够看得到的资源（成员变量、<br>类成员、弗雷成员），这就是缺省析构。<br>        如果类中没有动态资源，也不需要做善后工作，缺省析构就完全共用了，不需要再实现新析构函数。<br>        注意：缺省析构无法释放动态资源（堆内存）【堆内存是动态资源，动态资源不一定是堆内存】</p><p>   类对象的创建过程与释放过程。</p><pre><code>    创建：分配内存（对象）-&gt; 父类构造-&gt; 成员构造-&gt; 自己构造        父类构造：按照继承表从左到右依次构造。        成员构造：按照声明顺序从上至下依次构造。    释放：自己析构-&gt; 成员析构-&gt; 父类析构-&gt; 释放内存（对象）        成员析构：按照声明顺序从下到上依次构造。        父类析构：按照继承表从右到左依次构造。</code></pre><h2 id="四、拷贝构造"><a href="#四、拷贝构造" class="headerlink" title="四、拷贝构造"></a>四、拷贝构造</h2><pre><code>拷贝构造又称为复制构造，是一种特殊的构造函数，它是使用一个现有的旧对象构造一个新的对象时调用的函数，只有一个引用型的参数（对象本身）。类名(类&amp; ){}拷贝构造的参数应该加 const 保护，但编译器并没有强行限制。编译器会自己生成一个拷贝构造函数，它负责把旧对象中的所有数据拷贝给新创建的对象。</code></pre><p>   深拷贝与浅拷贝的区别：<br>        如果类成员有指针，浅拷贝只拷贝指针变量的值，而深拷贝指针变量所指向的目标。<br>    什么情况下需要实现拷贝构造：<br>        当类成员中没有指针成员，此时默认的拷贝构造（浅拷贝）就无法完成任务，需要自己动手实现拷贝构造（深拷贝）。<br>    什么情况下会调用拷贝构造：<br>        1、使用旧对象给新对象赋值时<br>        User user1 = user;<br>        2、使用对象当作函数的参数，当调用函数时，就会一起调用拷贝构造。</p><pre><code>#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;class User{    char* name;    char pass[7];    int id;public:    User(const char* name,const char* pass)    {        this-&gt;name = new char[strlen(name)+1];        strcpy(this-&gt;name,name);        strcpy(this-&gt;pass,pass);    }    void show(void)    {        cout&lt;&lt;name &lt;&lt;" " &lt;&lt;pass &lt;&lt;endl;    }    ~User(void)    {        cout&lt;&lt;"析构"&lt;&lt;&amp;name &lt;&lt;endl;        delete[] name;    }    User(User&amp; that)    {        name = new char[strlen(that.name)];        strcpy(name,that.name);        strcpy(pass,that.pass);        cout &lt;&lt; "我是拷贝构造" &lt;&lt; endl;    }};void func(User&amp; user){    user.show();}int main(){    User u1("a","aa");    u1.show();    // 调用拷贝构造    User u2 = u1;    u2.show();    func(u1);}</code></pre><h2 id="五、赋值构造（赋值运算符）"><a href="#五、赋值构造（赋值运算符）" class="headerlink" title="五、赋值构造（赋值运算符）"></a>五、赋值构造（赋值运算符）</h2><pre><code>当一类对象给另一个类对象赋值时，就会调用赋值构造void opeator = (类&amp;){}什么时会调用：对象 = 对象；编译器会生成一个缺省的赋值构造，它负责把一个对象的内存拷贝给另一个对象。什么情况需要实现赋值构造：    当需要深拷贝时，需要自己动手实现赋值构造，也就是拷贝构造与赋值构造需要同时实现。编译器会自动生成四个成员函数：构造、析构、赋值构造、拷贝构造。    </code></pre><pre><code>#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;class User{    char* name;    char pass[7];public:    User(const char* name,const char* pass)    {        this-&gt;name = new char[strlen(name)+1];        strcpy(this-&gt;name,name);        strcpy(this-&gt;pass,pass);    }    void show(void)    {        cout&lt;&lt;name &lt;&lt;" " &lt;&lt;pass &lt;&lt;endl;    }    ~User(void)    {        cout&lt;&lt;"析构"&lt;&lt;&amp;name &lt;&lt;endl;        delete[] name;    }    User(User&amp; that)    {        name = new char[strlen(that.name)];        strcpy(name,that.name);        strcpy(pass,that.pass);        cout &lt;&lt; "我是拷贝构造" &lt;&lt; endl;    }    User&amp; operator = (const User&amp; that)    {        cout&lt;&lt; this &lt;&lt;" "&lt;&lt; &amp;that &lt;&lt; endl;        if(this != &amp;that)        {            cout&lt;&lt;"我是赋值构造"&lt;&lt;endl;            // 释放旧空间            delete[] name;            // 申请新空间            name = new char[strlen(that.name)+1];            // 拷贝内容            strcpy(name,that.name);            strcpy(pass,that.pass);            /*            User temp(that);            swap(name,temp.name);            */        }        return *this;    }};int main(){    User u1("a","aa");    User u2("bbbb","bb");    User u3("ccc","cc");    //赋值构造    u1 = u1;    //u2 = u1 = u3;    u1.show();    u2.show();    u3.show();}</code></pre><h2 id="六、关于拷贝构造、赋值构造的建议"><a href="#六、关于拷贝构造、赋值构造的建议" class="headerlink" title="六、关于拷贝构造、赋值构造的建议"></a>六、关于拷贝构造、赋值构造的建议</h2><pre><code>1、缺省的拷贝构造、赋值构造函数不光会拷贝本类的数据，也会调用成员类对象和父类的拷贝构造和赋值构造，而不是单纯的按字节复制，</code></pre><p>因此尽量少用指针成员。<br>    2、在函数参数中，尽量使用类指针或引用来当参数（不要直接使用类对象），减少调用拷贝构造和赋值构造的机会，也可以降低数据传递的开销。<br>    3、如果由于特殊原因无法实现完整的拷贝构造、赋值构造，建议将它们私有化，防止误用。<br>    4、一旦为一个类实现了拷贝构造，那么也一定要实现赋值构造。（&lt;=&gt;）</p><h2 id="七、静态成员"><a href="#七、静态成员" class="headerlink" title="七、静态成员"></a>七、静态成员</h2><pre><code>类成员一旦被 static 修饰就会变成静态成员，而是单独一份存储在bss或data内存段中，所有的类对象共享（静态成员属于类，而不属于某个对象）。静态成员在类内声明，但必须在类外定义、初始化。与成员函数一样需要加“类名::”限定符表示它属于哪个类，但不需要再额外增加 static.</code></pre><p> 成员函数也可以被static修饰，这种函数叫静态成员函数，这种成员没有this指针，因此在静态函数中不能直接访问类的成员，但可以直接访问<br>静态成员，但可以直接访问静态成员变量、静态成员函数。<br>    静态成员变量、函数依然受访问控制限定符的影响。<br>    因为在代码编译完成后，静态成员已经定义完成（有了存储空间），一次可以不用活类对象而直接调用，类名::静态成员名</p><p>   静态成员变量可以被当做全局变量来使用（访问限定符必须是public），静态成员函数可以当作类的接口，实现对类的管理。</p><h2 id="八、单例模式"><a href="#八、单例模式" class="headerlink" title="八、单例模式"></a>八、单例模式</h2><pre><code>什么是单例模式，只能创建出一个类对象（只有一实际的实例）的叫单例模式。单例模式的应用场景：    Windows系统的任务管理器    Linux/Unix系统的日志系统    网站的访问计数器    服务端程序的连接池、线程池、数据池获取单一对象的方法：    1、定义全局（C语言），但不受控制，防君子不能防小人。    2、专门写一个类，把类的构造函数设置私有，借助静态成员函数提供一个接口，以此来获取唯一的实例。C++如何实现单例：    1、禁止类的外部创建类对象：构造函数设置私有    2、类自己维护一个唯一的实例：使用静态指针指向    3、提供一个获取实例的方法：静态成员函数获取静态指针</code></pre><p>   饿汉模式：<br>        将单例类的唯一实例对象定义为成员变量，当程序开始运行时，实例对象就已经创建完成<br>        优点：加载进程时，静态创建单例对象，线程安全。<br>        缺点：无论使用与否，总要创建，浪费内存。</p><pre><code>#include &lt;iostream&gt;using namespace std;class Singleton{private:    Singleton(void)    {    }    static Singleton object;public:    static Singleton get_object(void)    {        return object;    }    void show(void)    {        cout&lt;&lt; "我是对象："&lt;&lt;&amp;object &lt;&lt;endl;    }};Singleton Singleton::object;int main(){    Singleton sig = Singleton::get_object();    Singleton sig1 = Singleton::get_object();    sig.show();    sig1.show();}</code></pre><p>   懒汉模式：<br>        用静态成员指针来指向单例类的唯一实例对象，只有真正调用获取实例的静态接口时，实例对象才被创建。<br>        优点：什么时候用什么时候创建，节约内存。<br>        缺点：在第一次调用获取实例对象的静态接口时，才真正创建，如果在多线程操作情况下有可能被创建出多个实例对象（虽然可能性很低），存在线程不安全问题。</p><pre><code>#include &lt;iostream&gt;#include &lt;pthread.h&gt;using namespace std;//pthread_mutex_lock = PTHREAD_MUTEX_INITIALIZER;class Singleton{private:    Singleton(void)    {    }    static Singleton* object;public:    static Singleton&amp; get_object(void)    {        if(NULL == object)        {            object = new Singleton;        }        return *object;    }    void show(void)    {        cout&lt;&lt; "我是对象："&lt;&lt;object &lt;&lt;endl;    }};Singleton* Singleton::object;int main(){    Singleton sig = Singleton::get_object();    Singleton sig1 = Singleton::get_object();    sig.show();    sig1.show();}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础知识(二)</title>
      <link href="/2019/08/29/c-ji-chu-zhi-shi-er/"/>
      <url>/2019/08/29/c-ji-chu-zhi-shi-er/</url>
      
        <content type="html"><![CDATA[<h2 id="十、函数重载（重载、隐藏、重写）"><a href="#十、函数重载（重载、隐藏、重写）" class="headerlink" title="十、函数重载（重载、隐藏、重写）"></a>十、函数重载（重载、隐藏、重写）</h2><pre><code>1、函数重载    在同一作用域下，函数名相同，参数列表不同的函数，构成重载关系。</code></pre><a id="more"></a><pre><code>#include &lt;iostream&gt;using namespace std;void f(const int* p){    cout&lt;&lt;"f const"&lt;&lt;endl;}void f(int* p){    cout&lt;&lt;"f"&lt;&lt;endl;}int main(){    const int num = 0;    f(&amp;num);}</code></pre><p>   2、重载实现的机制<br>        C++代码在编译时会把函数的参数类型添加到参数名中，借助这个方式来实现函数重载，也就是C++的函数在编译期间经历换名的过程。<br>    因此，C++代码不能调用C函数（C语言编译器编译出的函数）<br>    3、extern “C” {}<br>        告诉C++编译器按照C语言的方式声明函数，这样C++就可以调用C编译器编译出的函数了（C++目标文件可以与C目标文件合并生成可执行程序）。<br>        如果C想调用C++编译出的函数，需要将C++函数的定义用extern “C”包括一下。<br>        注意：如果两个函数名一样，一定会冲突。<br>    4、重载和作用域<br>        函数的重载关系发生在同一作用域下，不同作用域下的同名函数，构成隐藏关系。<br>    5、重载解析<br>        当调用函数时，编译器根据实参的类型和形参的匹配情况，选择一个确定的重载版本，这个过程叫重载解析。<br>        实参的类型和形参的匹配情况有三种：<br>            1、编译器找到与实参最佳的匹配函数，编译器将生成调用代码。<br>            2、编译找不到匹配函数，编译器将给出错误信息。<br>            3、编译器找到多个匹配函数，但没有一个最佳的，这种错误叫二义性。<br>        在大多数情况下编译器都能立即找到一个最佳的调用版本，但如果没有，编译就会进行类型提升，这样备选函数中就可能具有多个可调用<br>的版本，这样就可能产生二义性错误。<br>    6、确定存在函数的三个步骤<br>        1）候选函数<br>        函数调用的第一步就是确定所有可调用的函数的集合（函数名、作用域），该集合中的函数就是候选函数。<br>        2）选择可行函数<br>        从候选函数中选择一个或多个函数，选择的标准是参数个数相同，而且通过类型提升实参可被隐式转换为形参。<br>        3）寻找最佳匹配<br>        优先每个参数都完全匹配的方案，其次参数完全匹配的个数，再其次是浪费内存的字节数。<br>    7、指针类型会对函数重载造成影响<br>        C++函数的形参如果是指针类型，编译时函数名中会追加Px。</p><pre><code>#include &lt;iostream&gt;using namespace std;void sum(short a,short b){    cout&lt;&lt; a+b &lt;&lt; "  3" &lt;&lt; endl;}void sum(int a,short b){    cout&lt;&lt; a+b &lt;&lt; "  1" &lt;&lt; endl;}void sum(short a,long b){    cout &lt;&lt; a+b &lt;&lt;"  2"&lt;&lt; endl;}int main(){    short a=3, b=7;    sum(a,b);}</code></pre><h2 id="十一、默认形参"><a href="#十一、默认形参" class="headerlink" title="十一、默认形参"></a>十一、默认形参</h2><pre><code>1、在C++中函数的形参可以设置默认值，调用函数，如果没有提供实参数，则使用默认形参。2、如果形参只有一部分设置了默认形参，则必须靠右排列。3、函数的默认形参是在编译阶段确定的，因此只能使用常量、常量表达式、全局变量数据作为默认值。4、如果函数的声明和定义需要分开，那么默认形参设置在声明、定义，还是声明定义都需要设置。5、默认形参会对函数重载造成影响，设置默认形参时一定要慎重。</code></pre><pre><code>#include &lt;iostream&gt;using namespace std;void fun(int b,int a=100);int main(){    fun(10,20);    fun(50);}void fun(int b,int a){    cout &lt;&lt;"b:" &lt;&lt; b &lt;&lt; endl;    cout &lt;&lt;"a:" &lt;&lt; a &lt;&lt; endl;}</code></pre><h2 id="十二、内联函数"><a href="#十二、内联函数" class="headerlink" title="十二、内联函数"></a>十二、内联函数</h2><pre><code>1、普通函数调用时是生成调用指令（跳转），然后当代码执行到调用位置时跳转到函数所在的代码段执行。2、内联函数就把函数编译好的二进制指令直接复制到函数的调用位置。3、内联函数的优点就是提高程序的运行速度（因为没有跳转，也不需要返回），但这样会导致可执行文件增大（冗余），也就是牺牲空间来换取时间。4、内联分为显示内联和隐式内联    显示内联：在函数前 inline（C语言C99标准也支持）    隐式内联：结构、类中内部直接定义的成员函数，则该类型函数会被优化成内联函数。5、宏函数在调用时会把函数体直接替换到调用位置，与内联函数一样也是使用空间来换取时间，所以宏函数与内联函数的区别（优缺点）？    1.宏函数不是真正的函数，只是代码替换，不会有参数压栈、出栈以及返回值，也不会检查参数类型，因此所有类型都能使用，但这样会</code></pre><p>有安全隐患。<br>        2.内联函数是真正的函数，被调用时会进行传参，会进行压栈、出栈，可以有返回值，并会严格检查参数类型，这样就不能通用，如果被<br>多种类型调用需要重载。<br>    6、内联适用的条件<br>        由于内联会造成可执行文件变大，并增加内存开销，因此只有频繁调用的简单函数适合作为内联。<br>        调用比较少的复杂函数，内联后并不显著提高性能，不足以抵消牺牲空间带来的损失，所以不适合内联。<br>        带有递归特性和动态绑定特性的函数，无法实施内联，因此编译器会忽略声明部分的inline关键字。</p><h2 id="十三、引用"><a href="#十三、引用" class="headerlink" title="十三、引用"></a>十三、引用</h2><pre><code>引用就是取艺名（别名）。</code></pre><pre><code>#include &lt;iostream&gt;using namespace std;int main(){    int wqq = 18;    int&amp; xiu = wqq;    //int&amp; xiu; 不存在空引用,错误    //int const &amp; xi = 20; 无名对象    cout &lt;&lt; wqq &lt;&lt;" "&lt;&lt;xiu&lt;&lt;endl;}</code></pre><pre><code>1、引用的基本特性    引用就是取别名，声明一个标识符为引用，就表示该标识符是另一个对象的外号。    1）引用必须初始化，不存在空引用，但有悬空引用（变量死了，名还留着）。    2）可以引用无名对象和临时对象，但必须使用常引用。    3）引用不能更换目标    引用一旦完成了定义和初始化就和普通变量名一样，它就代表了目标，一经引用终身不能再引用其他目标。2、引用型参数    引用当作函数的参数能达到指针同样的效果，但不具备指针的危险，还比指针方便。    引用可以非常简单的实现函数间共享变量的目的，而且是否使用引用由被调函数说了算。    引用当作函数的参数还能提高传递参数效率，指针至少还需要4字节内存，而引用只需要增加一条标识符与内存之间的绑定（映射）。3、引用型返回值    不要返回局部变量的引用，会造成悬空引用。    如果返回值是一个临时值（右值），如果非要使用引用接收的话，必须使用常引用。注意：C++中的引用时一种取别名的机制，而C语言中的指针是一种数据类型（代表内存编号的无符号整数）。练习1：实现一个C++版本的swap函数。指针和引用的相同点和不同点：    相同点：跨函数共享变量，优化传参效率，避免传参的时候调用拷贝构造    不同点：指针有自己的存储空间，借助指针可以使用堆内存，引用不行。引用取别名，指针是数据类型。指针可以为空，引用不可以为    空。指针可以不初始化，引用必须初始化。指针可以改变指向，引用不能引用其他对象（可以定义指针的指针，不能定义引用的引用。    可以定义指针的引用，不能定义引用的指针。可以定义指针的数组，但不能定义引用的数组。可以定义数组的引用）。</code></pre><pre><code>#include &lt;iostream&gt;using namespace std;void swap(int&amp; a,int&amp; b) //引用{    int temp = a;    a = b;    b = temp;}int main(){    int a=3,b=4;    swap(a,b);    cout&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;endl;}</code></pre><h2 id="十四、C-的内存管理"><a href="#十四、C-的内存管理" class="headerlink" title="十四、C++的内存管理"></a>十四、C++的内存管理</h2><pre><code>1、new/delete C++具备申请/释放堆内存功能的运算符    相当于C语言中的malloc和free。    new 类型：会自动计算类型所需要字节数，然后从堆中分配对应字节数的内存，并返回内存的首地址（具备类型）。    delete 指针：会自动释放堆内存。    注意：new/delete与malloc/free不能混用，因为new和delete会自动调用类、结构的构造函数、析构函数。2、数组的分配与释放    new 类型[n]； n表示数组长度，如果类、结构会自动调用n次构造函数。    delete[] 指针；通过new[] 分配的内存，必须通过delete[]释放。    new[] 返回值前4个字节中存放着数组的长度。3、重复释放    delete/delete[]不能重复释放同一块内存。    delete/delete[]释放野指针的后果不确定，但释放空指针是安全的。</code></pre><pre><code>#include &lt;iostream&gt;using namespace std;struct Student{    Student(void)    {        cout&lt;&lt;"我是构造函数，创建对象时，我就会执行" &lt;&lt; endl;    }    ~Student(void)    {        cout&lt;&lt; "我是析构函数，释放对象时，我就会执行" &lt;&lt; endl;    }};int main(){    int* p = new int;    *p = 10;    cout&lt;&lt; *p &lt;&lt;endl;    Student stu;    Student* s = new Student;    delete(s);    cout &lt;&lt; endl;    Student* a = new Student[3];    p = (int*)a;    cout &lt;&lt; *(p-1) &lt;&lt; endl;    delete[] a;    }</code></pre><p>   4、内存分配失败<br>        当分配的内存过大，没有能满足需求的整块内存就会抛出异常，std::bad_alloc。<br>        new/delete和C语言的malloc/free的相同点和不同点（区别）？<br>        不同点：<br>            身份     运算符               标准库函数<br>            参数     类型（自动计算）      字节数（手动计算）<br>            返回值   带类型的地址          void*地址<br>            调用构造 自动调用              不能调用构造/析构函数<br>            出错     抛出异常              返回NULL<br>        相同点：<br>            1、都能管理堆内存<br>            2、不能重复释放<br>            3、可以释放NULL</p><p>   注意：在C++中尽量使用引用、new/delete</p><pre><code>#include &lt;iostream&gt;using namespace std;int main(){    int *p = NULL;    try{        p = new int[~0];    }    catch(std::bad_alloc&amp; ex)    {        cout &lt;&lt; "error" &lt;&lt; endl;    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础知识(一)</title>
      <link href="/2019/08/29/c-ji-chu-zhi-shi-yi/"/>
      <url>/2019/08/29/c-ji-chu-zhi-shi-yi/</url>
      
        <content type="html"><![CDATA[<p>思考题：C与C++的区别？</p><h2 id="一、C-介绍"><a href="#一、C-介绍" class="headerlink" title="一、C++介绍"></a>一、C++介绍</h2><pre><code>本贾尼·斯特劳斯特卢普，与1979年4月份贝尔实验室的本贾尼博士在分析UNIX系统分布内核流量分析时，希望有一种有效的更加模块化的工具。1979年10月完成了预处理器Cpre，为C增加了类机制，也就是面向对象，1983年完成了C++的第一个版本，C with classes也就是C++。C++与C的不同点：1、C++完全兼容C的所有语法（内容）2、支持面向对象的编程思想3、支持运算符重载4、支持泛型编程、模板5、支持异常处理6、类型检查严格</code></pre><a id="more"></a><h2 id="二、第一个C-程序"><a href="#二、第一个C-程序" class="headerlink" title="二、第一个C++程序"></a>二、第一个C++程序</h2><pre><code>1、文件扩展名    .cpp .cc .C .cxx2、编译器    g++ 大多数系统需要额外安装，Ubuntu系统下的安装命令：        sudo apt-get update        sudo apt-get install g++    gcc也可以继续使用，但需要增加参数 -xC++ -lstdc++3、头文件    #include &lt;iostream&gt;    #include &lt;stdio.h&gt; 可以继续使用，但C++建议使用 #include &lt;cstdio&gt;4、输入/输出    cin &lt;&lt; 输入数据    cout &gt;&gt; 输出数据    cin/cout会自动识别类型    scanf/printf可以继续使用    注意：cout和cin是类对象，而scanf/printf是标准库函数。5、增加了名字空间    std::cout    using namespace std;</code></pre><h2 id="三、名字空间"><a href="#三、名字空间" class="headerlink" title="三、名字空间"></a>三、名字空间</h2><pre><code>1、什么是名字空间在C++中经常使用多个独立开发的库来完成项目，由于库的作者或开发人员没见过面，因此命名冲突在所难免。2、为什么需要名字空间在项目中函数名、全局变量、结构、联合、枚举、类，非常有可能名字冲突，而名字空间就对这些命名进行逻辑空间划分（不是物理单元划分），为了解决命名冲突，C++之父为防止命名冲突给C++设计一个名字空间的机制。通过使用namespace XXX把库中的变量、函数、类型、结构等包含在名字空间中，形成自己的作用域，避免名字冲突。namespace xxx{}// 没有分号注意：名字空间也是一种标识符，在同一作用域下不能重名。3、同名的名字空间有自动合并（为了声明和定义可以分开写）同名的名字空间中如果有重名的依然会命名冲突4、名字空间的使用方法::域限定符空间名::标识符 // 使用麻烦，但是非常安全using namespace 空间名; 把空间中定义的标识符导入到当前代码中    不建议这样使用，相当于把垃圾分类后，又倒入同一个垃圾车，依然会冲突</code></pre><pre><code>#include &lt;iostream&gt;namespace test{int cout = 100;int cin = 99;}int main(){    std::cout&lt;&lt;test::cout&lt;&lt;' '&lt;&lt;test::cin&lt;&lt;std::endl;}</code></pre><p>   5、无名名字空间<br>    不属于任何名字空间中的标识符，隶属于无名名字空间。<br>    无名名字空间中的成员使用 ::标识符 进行访问。<br>    如何访问被屏蔽的全局变量。</p><p>   6、名字空间的嵌套<br>    名字空间内部可以再定义名字空间，这种名字空间嵌套<br>    内层的名字空间与外层的名字空间的成员，可以重名，内层会屏蔽外层的同名标识符。<br>    多层的名字空间在使用时逐层分解。</p><pre><code>    n1::n2::num;    namespace n1    {        int num = 1;        namespace n2        {               int num = 2;            namespace n3            {            }        }    }</code></pre><p>   7、可以给名字空间取别名<br>    由于名字空间可以嵌套，这样就会导致在使用内层成员时过于麻烦，可以给名字空间取别名来解决这类问题。<br>    namespace n123 = n1::n2::n3;</p><h2 id="四、C-的结构"><a href="#四、C-的结构" class="headerlink" title="四、C++的结构"></a>四、C++的结构</h2><p>   1、不再需要 typedef ，在定义结构变量时，可以省略struct关键字<br>    2、成员可以是函数（成员函数），在成员函数中可以直接访问成员变量，不需要.或-&gt;，但是C的结构成员可以是函数指针。<br>    3、有一些隐藏的成员函数（构造、析构、拷贝构造、赋值构造）。<br>    4、可以继承，可以设置成员的访问权限（面向对象）。</p><pre><code>#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;struct Man{    char id[18];};struct Student:public Man{    char name[20];    char sex;    short age;    Student(void)    {        cout&lt;&lt; "我被调用了..." &lt;&lt; endl;    }    void show(void)    {        cout &lt;&lt; "我是秀" &lt;&lt; name &lt;&lt; " " &lt;&lt; sex &lt;&lt; " " &lt;&lt; age &lt;&lt; endl;    }};int main(){    Student stu;    strcpy(stu.name,"hehe");    stu.sex = 'm';    stu.age = 12;    strcpy(stu.id,"1235214141231");    cout &lt;&lt; stu.name &lt;&lt; " " &lt;&lt; stu.sex &lt;&lt; " " &lt;&lt; stu.age &lt;&lt; endl;    cout&lt;&lt;stu.id&lt;&lt;endl;    stu.show();}</code></pre><h2 id="五、C-的联合"><a href="#五、C-的联合" class="headerlink" title="五、C++的联合"></a>五、C++的联合</h2><p>   1、不再需要 typedef ，在定义结构变量时，可以省略union关键字<br>    2、成员可以是函数（成员函数），在成员函数中可以直接访问成员变量，不需要.或-&gt;，但是C的结构成员可以是函数指针。<br>    3、有一些隐藏的成员函数（构造、析构、拷贝构造、赋值构造）。</p><pre><code>#include &lt;iostream&gt;using namespace std;union Data{    char ch[5];    int num;    Data(void)    {        cout&lt;&lt;"我被调用了？"&lt;&lt;endl;    }    void show(void)    {        cout &lt;&lt; ch &lt;&lt;" " &lt;&lt; num &lt;&lt; endl;    }    ~Data(void)    {        cout&lt;&lt;"析构"&lt;&lt;endl;    }};int main(){    Data d;    d.show();    cout &lt;&lt; sizeof(d) &lt;&lt; endl;}</code></pre><h2 id="六、C-的枚举"><a href="#六、C-的枚举" class="headerlink" title="六、C++的枚举"></a>六、C++的枚举</h2><p>   1、定义、使用方法与C语言基本一致。<br>    2、类型检查比C语言更严格</p><pre><code>#include &lt;iostream&gt;using namespace std;enum Color{    RED,    YELLOW,    BLUE,    WHITE,    BLACK};int main(){    Color r;    r = BLUE;    //r = 0; error 类型检查更严格    cout &lt;&lt; r &lt;&lt; endl;}</code></pre><h2 id="七、C-的布尔类型"><a href="#七、C-的布尔类型" class="headerlink" title="七、C++的布尔类型"></a>七、C++的布尔类型</h2><p>   1、C++具有真的布尔类型，bool是C++中的关键字，在C语言中使用布尔类型需要导入头文件stdbool.h（在C11中bool应该是数据类型了）。<br>    2、在C++中 true false 是关键字，而在C语言中不是。<br>    3、在C++中 true false 是1字节，而C语言中是4字节。</p><pre><code>#include &lt;iostream&gt;using namespace std;int main(){    bool flag = 0;    cout &lt;&lt; flag &lt;&lt; " " &lt;&lt; sizeof(flag) &lt;&lt; endl;}</code></pre><h2 id="八、C-的void"><a href="#八、C-的void" class="headerlink" title="八、C++的void*"></a>八、C++的void*</h2><p>   1、C语言中void* 可以与任意类型指针 自动转换。</p><pre><code>#include &lt;stdio.h&gt;int main(){    void* p = NULL;    char* p1 = p;    int* p2 = p;    double* p3 = p;    p = p1;    p = p3;}</code></pre><p>   2、C++中void<em>不能给其他类型的指针直接赋值，必须强制类型转换，但其他类型的指针可以自动给void</em>赋值。<br>    3、C++为什么这样修改void*？<br>        为了更安全，所以C++类型检查更严格。<br>        C++可以自动识别类型，对万能指针的需求不再那么强烈。</p><h2 id="九、操作符别名"><a href="#九、操作符别名" class="headerlink" title="九、操作符别名"></a>九、操作符别名</h2><p>   某些特殊语言的键没有~,&amp;符合，所以C++标准委员会为了让C++更有竞争力，为符号定义了一些别名，让这些小语种也可以愉快编写C++代码</p><pre><code>and       &amp;&amp;or      ||not     !{       &lt;%    }       %&gt;#       :%</code></pre><pre><code>%:include &lt;iostream&gt;using namespace std;int main()&lt;%    cout &lt;&lt; "hello" &lt;&lt;endl;%&gt;</code></pre><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&amp;id=28481591&amp;auto=1&amp;height=66"></iframe><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/08/28/hello-world/"/>
      <url>/2019/08/28/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
