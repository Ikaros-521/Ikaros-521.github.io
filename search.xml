<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>多路复用IO</title>
      <link href="/2019/09/21/duo-lu-fu-yong-io/"/>
      <url>/2019/09/21/duo-lu-fu-yong-io/</url>
      
        <content type="html"><![CDATA[<h2 id="一、IO模型介绍"><a href="#一、IO模型介绍" class="headerlink" title="一、IO模型介绍"></a>一、IO模型介绍</h2><pre><code>    1、阻塞IO，常用的scanf、printf、read、write、cout、cin    2、非阻塞IO，recv、send和Qt中read、write     3、多路复用IO       4、信号驱动IO        5、异步IO</code></pre><h2 id="二、多路复用IO"><a href="#二、多路复用IO" class="headerlink" title="二、多路复用IO"></a>二、多路复用IO</h2><pre><code>在不创建新的进程和线程的情况下监控多个文件描述符，多应用于网络编程时一个服务端程序为多个客户端程序提供服务，多用于在业务逻辑简单，客户端需要的服务时间短，响应时间无太高要求的场景。</code></pre><h2 id="三、使用select函数实现多路复用IO"><a href="#三、使用select函数实现多路复用IO" class="headerlink" title="三、使用select函数实现多路复用IO"></a>三、使用select函数实现多路复用IO</h2><pre><code>int select(int nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, struct timeval *timeout);功能：监控多个文件描述符的 读、写、异常 操作nfds：最大文件描述符+1readfds：监控读操作文件描述符集合writefds：监控写操作文件描述符集合exceptfds：监控异常操作文件描述符集合timeout：设置超时时间返回值：监控到文件描述符的个数,超时返回0，出错返回-1void FD_CLR(int fd, fd_set *set);功能：从集合吕删除文件描述符int FD_ISSET(int fd, fd_set *set);功能：测试集合中是否有文件描述符存在void FD_SET(int fd, fd_set *set);功能：向集合中添加文件描述符void FD_ZERO(fd_set *set);功能：清空文件描述符集合select设计不合理的地方：    1、所有被监视的文件描述符都需要检查（效率不高）。    2、每次调用select都需要向它传递新的监视对象信息 select的优点是：    程序的兼容性高  int pselect(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timespec *timeout, const sigset_t *sigmask);功能：与select的功能大致类似区别：    1、select函数用的timeout参数，是一个timeval的结构体（包含秒和微秒），然而pselect用的是一个timespec结构体（包含秒和纳秒）    2、select函数可能会为了指示还剩多长时间而更新timeout参数，然而pselect不会改变timeout参数    3、select函数没有sigmask参数，当pselect的sigmask参数为null时，两者行为时一致的。有sigmask的时候，pselect相当于如下的select()函数，在进入select()函数之前手动将信号的掩码改变，并保存之前的掩码值；select()函数执行之后，再恢复为之前的信号掩码值。</code></pre><h2 id="四、使用poll函数实现多路复用IO"><a href="#四、使用poll函数实现多路复用IO" class="headerlink" title="四、使用poll函数实现多路复用IO"></a>四、使用poll函数实现多路复用IO</h2><pre><code>int poll(struct pollfd *fds, nfds_t nfds, int timeout);fds：所有被监控的文件描述符结构体数组nfds：数组的长度timeout：超时时间，毫秒单位struct pollfd{    int fd;     //被监控文件描述符    short events; // 等待的需要监控事件    short revents; // 实际发生了的事件，也就是返回结果};events:    POLLIN      普通或优先级带数据可读    POLLPRI     高优先级数据可读       POLLOUT     普通数据可写    POLLRDHUP   对方socket关闭    POLLERR     发生错误    POLLHUP     发生挂起    POLLNVAL    描述字不是一个打开的文件poll特点：    1.文件描述符没有最大限制 -数据结构：链表    2.每次调用都需要将fd集合从用户态拷贝到内核态     3.内核需要遍历所有fd，效率低</code></pre><h2 id="五、使用epoll函数实现多路复IO"><a href="#五、使用epoll函数实现多路复IO" class="headerlink" title="五、使用epoll函数实现多路复IO"></a>五、使用epoll函数实现多路复IO</h2><pre><code>int epoll_create(int size);功能：创建用于保存被监控文件描述符的空间int epoll_ctl(int epfd, int op, int fd, struct  epoll_event *event);  功能：向文件中添加、删除，文件描述符int epoll_wait(int epfd, struct epoll_event *events,  int maxevents, int timeout); 功能：监控文件描述符1.文件描述符没有最大限制 --数据结构：红黑树2.只需拷贝一次fd到内核态 3.内核只需判断就绪链表是否为空，不需要遍历所有fd，效率高，并把就绪fd拷贝到用户空间</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多路复用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础知识(四)</title>
      <link href="/2019/09/19/c-ji-chu-zhi-shi-si/"/>
      <url>/2019/09/19/c-ji-chu-zhi-shi-si/</url>
      
        <content type="html"><![CDATA[<p>面向过程编程：<br>    关注是问题解决的过程步骤，算法</p><p>面向对象编程：<br>    关注的是谁能解决问题（类），需要什么样的数据（成员变量），具备什么样的技能（成员函数）才能解决问题。<br>    抽象：找出一个能够解决问题的“对象”（观察研究对象），找出解决所必须的数据（属性）、功能（成员函数）。<br>    封装：把抽象的结果，归结为一个类（数据类型），然后实例化出类对象，设置对象的属性，调用对象的功能达到解决问题的目的。<br>    继承：在解决问题前，先寻找之前的类能不能解决问题，或解决部分问题，如果可以则把旧的类继承后再次拓展，来缩短解决问题的时间，降低<br>解决问题的难度。<br>    多态：对象的多种形态，外部看到一个对象发出指令，对象会根据自身情况做出独特的反应。</p><h2 id="一、类和对象"><a href="#一、类和对象" class="headerlink" title="一、类和对象"></a>一、类和对象</h2><h3 id="1、通过分析对象的属性和行为设计出一个类。"><a href="#1、通过分析对象的属性和行为设计出一个类。" class="headerlink" title="1、通过分析对象的属性和行为设计出一个类。"></a>1、通过分析对象的属性和行为设计出一个类。</h3><h3 id="2、类就是数据类型"><a href="#2、类就是数据类型" class="headerlink" title="2、类就是数据类型"></a>2、类就是数据类型</h3><pre><code>    简单类型：只能表示一个属性（变量），C/C++内建数据类型    数组类型：可以表示多个属性（变量），类型必须相同。    结构类型：可以表示多个属性（变量），但缺少行为（函数）。    类类型：即能表示属性，也能表示行为，一直复合数据类型。</code></pre><h3 id="3、对象就是类这种数据类型创建出的实例，相当于结构变量。"><a href="#3、对象就是类这种数据类型创建出的实例，相当于结构变量。" class="headerlink" title="3、对象就是类这种数据类型创建出的实例，相当于结构变量。"></a>3、对象就是类这种数据类型创建出的实例，相当于结构变量。</h3><pre><code>class Student{    属性(成员变量);    行为（成员函数）;};Student stu;</code></pre><h2 id="二、类的定义与实例化"><a href="#二、类的定义与实例化" class="headerlink" title="二、类的定义与实例化"></a>二、类的定义与实例化</h2><h3 id="1、类的一般形式"><a href="#1、类的一般形式" class="headerlink" title="1、类的一般形式"></a>1、类的一般形式</h3><pre><code>class 类名 : 继承方式 父类{public/private/protected: // 访问控制限制符    成员变量;    // 构造函数    类名(形参表)    {    }    // 析构函数    ~类名(void)    {    }};</code></pre><h3 id="2、类的访问控制限定符"><a href="#2、类的访问控制限定符" class="headerlink" title="2、类的访问控制限定符"></a>2、类的访问控制限定符</h3><pre><code>public：公有成员，在任何位置都可以访问private：私有成员，只能在类（自己）的成员函数中访问protected：受保护成员，只能在类（自己）和子类中访问注意：类中的成员变量、成员函数默认是 private，结构中的成员和成员函数默认是 public。注意：C++中类和结构的区别只有成员函数和成员变量的默认访问权限不同。</code></pre><h3 id="3、构造函数"><a href="#3、构造函数" class="headerlink" title="3、构造函数"></a>3、构造函数</h3><pre><code>    1）什么是构造函数：类的同名函数就是构造函数，没有返回值。    2）什么时候调用，谁调用，调用几次？        创建类对象时会被自动调用（每创建一个类对象，就会调用一次），对象整个生命周期中一定会被调用一次，只能被调用一次。    3）负责干什么        成员变量的初始化，分配相关资源，设置对象的初始状态。    class 类名 : 继承方式 父类    {        // 构造函数     类名(形参表)        {        }    };</code></pre><h3 id="4、类型的创建过程"><a href="#4、类型的创建过程" class="headerlink" title="4、类型的创建过程"></a>4、类型的创建过程</h3><pre><code>    1.分配类型所需要空间，无论栈还是堆。    2.传递实参调用构造函数，完成如下任务：        1）根据继承表依次调用父类的构造函数        2）根据成员变量的顺序依次调用成员变量的构造函数。        3）执行构造函数体中的代码。注意：执行构造函数的代码是整个构造函数的最后一步。要保证构造函数代码所需要的一切资源和先决条件在该代码执行前已经准备充分，并得到正确的初始化。</code></pre><h3 id="5、对象的创建方法"><a href="#5、对象的创建方法" class="headerlink" title="5、对象的创建方法"></a>5、对象的创建方法</h3><pre><code>    1.在栈上创建：类名 对象；// 不需要括号        类名 对象(实参);    2.在堆上创建：类名* 对象指针 = new 类名；        类名* 对象指针 = new 类名(实参)；    3.创建多个对象：        类名 对象 = {类名(实参)，类名(实参)，类名(实参)};        类名* 对象指针 = new 类名[n]{类名(实参),类名(实参)};    注意：通过malloc创建的类对象不能调用构造函数。    注意：通过new[]创建的对象，一定要通过delete[]释放。</code></pre><h3 id="6、类的声明、实现、调用"><a href="#6、类的声明、实现、调用" class="headerlink" title="6、类的声明、实现、调用"></a>6、类的声明、实现、调用</h3><pre><code>    1.在头文件中声明    class 类名 : 继承方式 父类    {        成员变量;    public: // 访问控制限制符        // 构造函数        类名(形参表);        // 析构函数        ~类名(void);        // 其他成员函数        返回值 函数名(参数列表);    };    2.源文件实现类的相关函数    返回值 类名::函数名（参数列表）    {    }    3.调用时只需要导入头文件，然后与类函数所在的源文件一起编译即可。    注意：如果一个类内容不多，可以考虑在头文件中完全实现。        也可以只在头文件中实现一些简单的成员函数。    注意：类中自动生成的函数，在源文件中实现时，也需要在头文件中声明。class和struct的区别？    class的默认继承和访问权限是private，struct的默认继承和访问权限是public。class能做模板的参数，struct不行。</code></pre><h2 id="三、构造函数与初始化列表"><a href="#三、构造函数与初始化列表" class="headerlink" title="三、构造函数与初始化列表"></a>三、构造函数与初始化列表</h2><h3 id="1、构造函数可以被重载（同一个名字的函数有多个不同版本）"><a href="#1、构造函数可以被重载（同一个名字的函数有多个不同版本）" class="headerlink" title="1、构造函数可以被重载（同一个名字的函数有多个不同版本）"></a>1、构造函数可以被重载（同一个名字的函数有多个不同版本）</h3><h3 id="2、缺省构造是编译器自动生成的一个什么都不做的构造函数（唯一的作用就是避免编译错误）。"><a href="#2、缺省构造是编译器自动生成的一个什么都不做的构造函数（唯一的作用就是避免编译错误）。" class="headerlink" title="2、缺省构造是编译器自动生成的一个什么都不做的构造函数（唯一的作用就是避免编译错误）。"></a>2、缺省构造是编译器自动生成的一个什么都不做的构造函数（唯一的作用就是避免编译错误）。</h3><pre><code>注意：当类实现一个有参构造时，缺省构造就不会再自动生成，如果有需要必须显示地写出来。</code></pre><h3 id="3、无参构造未必无参，当给有参构造的所有参数设置默认形参，调用这种构造函数就不需要传参。"><a href="#3、无参构造未必无参，当给有参构造的所有参数设置默认形参，调用这种构造函数就不需要传参。" class="headerlink" title="3、无参构造未必无参，当给有参构造的所有参数设置默认形参，调用这种构造函数就不需要传参。"></a>3、无参构造未必无参，当给有参构造的所有参数设置默认形参，调用这种构造函数就不需要传参。</h3><pre><code>注意：所谓的“编译器生成的某某函数”其实不是真正语法意义上的函数，而是功能意义上的函数，编译器作为可执行指令的生成者，它会直接生成具有某项功能的二进制指令，不需要借助高级语言语义上的函数完成此任务。注意：如果一个类是其他类的成员变量，那么一定要保证它有一个无参构造，当B的构造函数执行时会执行成员变量的无参构造，而此时类B是无法给类A成员变量提供参数的。</code></pre><h3 id="4、单参构造与类型转换"><a href="#4、单参构造与类型转换" class="headerlink" title="4、单参构造与类型转换"></a>4、单参构造与类型转换</h3><pre><code>    如果构造函数的参数只有一个，那么Test t = n语句就不会出错，它会自动调用单参构造来达到类型转换的效果。    如果想禁止这种类型转换需要在单参构造前加 explicit</code></pre><h3 id="5、初始化列表"><a href="#5、初始化列表" class="headerlink" title="5、初始化列表"></a>5、初始化列表</h3><pre><code>    为类成员进行初始化用的。    构造函数(参数):成员1(参数1),成员2(参数2)...    const int num;    Test(int n):num(n)    {    }    通过初始化列表可以给类成员变量传递参数，以此调用类成员的有参构造。    初始化列表也可以给 const 成员、引用成员进行初始化。</code></pre><pre><code>#include &lt;iostream&gt;using namespace std;class A{public:    int num;    A(int _num)    {        num = _num;        cout&lt;&lt;"我A的有参构造"&lt;&lt;endl;    }};class Test{public:    string str;    const int num;    int&amp; xiu;    A a;    Test(int num,const char* str,int&amp; x):num(num),str(str),a(num),xiu(x)    {        cout&lt;&lt;"---"&lt;&lt;endl;    }};int main(){    int x = 100;    Test t(10,"aa",x);    //Test t = {10};    //t.num = 100;    cout&lt;&lt; t.num &lt;&lt; endl;    cout&lt;&lt;t.xiu&lt;&lt;endl;    x = 1000;    cout&lt;&lt;t.xiu&lt;&lt;endl;}</code></pre><pre><code>    成员的初始化顺序与初始化列表没有关系，而是在类中的定义顺序有关。</code></pre><pre><code>#include &lt;iostream&gt;using namespace std;class A{public:    A(int n)    {        cout&lt;&lt;"A"&lt;&lt;endl;    }};class B{public:    B(int n)    {        cout&lt;&lt;"B"&lt;&lt;endl;    }};class C{public:    C(int n)    {        cout&lt;&lt;"C"&lt;&lt;endl;    }};class Test{public:    A a;    C c;    B b;    //A a;    Test(int c1,int a1,int b1):c(c1),a(a1),b(b1)    {    }};int main(){//    A a1;//    B b1;//    C c1;    Test t(1,2,3);}</code></pre><pre><code>    注意：初始化列表运行类成员变量还没有定义成功。</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 类 </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> 构造函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宣讲会个人体会</title>
      <link href="/2019/09/14/xuan-jiang-hui-ge-ren-ti-hui/"/>
      <url>/2019/09/14/xuan-jiang-hui-ge-ren-ti-hui/</url>
      
        <content type="html"><![CDATA[<h2 id="杭电CVTE宣讲会"><a href="#杭电CVTE宣讲会" class="headerlink" title="杭电CVTE宣讲会"></a>杭电CVTE宣讲会</h2><p>第一次去参加宣讲会，主要分为3大块，公司介绍自己，你提问公司，公司提问你。<br>宣讲会有福利，这次的宣讲会提供了绿卡(免笔试，直接面试，算是个加分吧。通过线上推广集赞和线下现场抢答来获取)。换句话说就是宣讲会表现好是有很大好处的。<br>个人对这家公司介绍后的总结就是福利待遇特别好，养小养老还养你，上班时间不固定(可早可晚)，支持创业。总体感觉很好，过多的个人看法就不提了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 心得/体会 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心得 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下互斥与死锁</title>
      <link href="/2019/09/09/linux-xia-hu-chi-yu-si-suo/"/>
      <url>/2019/09/09/linux-xia-hu-chi-yu-si-suo/</url>
      
        <content type="html"><![CDATA[<h2 id="一、同步、竞争、互斥"><a href="#一、同步、竞争、互斥" class="headerlink" title="一、同步、竞争、互斥"></a>一、同步、竞争、互斥</h2><pre><code>当多个线程同时访问其共享的资源时，需要相互协调，以防止出现数据不一致、不完整的问题，能达到这种状态叫线程同步。而有些资源在同一时刻只有一个线程访问，对于这种资源的访问需要竞争。当资源获取到后，能够防止资源被其他线程抢占（再次获取）的技术叫互斥。</code></pre><h2 id="二、互斥量（锁）"><a href="#二、互斥量（锁）" class="headerlink" title="二、互斥量（锁）"></a>二、互斥量（锁）</h2><pre><code>pthread_mutex_t mutex = PTHREAD_MUTEX_INITALIZER;int pthread_mutex_init (pthread_mutex_t *__mutex, __const pthread_mutexattr_t *__mutexattr)功能：初始化互斥量,使用第二互斥量来初始化第一个互斥量，如果第二个为空，则使用默认参数初始化互斥量,也可以使用宏来初始化。int pthread_mutex_destroy (pthread_mutex_t *__mutex)功能：销毁互斥量注意：互斥量是一个结构体，里面有成员是指针，指向了堆内存数据，需要显式初始化函数以及销毁函数。如果使用堆内存存储互斥量，需要在调用了销毁函数后，再进行free。int pthread_mutex_lock (pthread_mutex_t *__mutex)功能：锁定互斥量，当互斥量是锁定状态，此函数则阻塞（直到互斥量在其他线程中解锁，调用者线程加锁成功才返回）。注意：互斥量一旦加锁，只有它自己能解。int pthread_mutex_trylock (pthread_mutex_t *__mutex)功能：尝试锁定互斥量，能锁就锁，不能锁就返回。int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex, __const struct timespec *__restrict __abstime)功能：在指定时间内锁定一个互斥量(由于系统原因导致不可知锁的状态),而一旦获取锁的状态后立即做出抉择。struct timespec{    __time_t tv_sec;    long int tv_nsec;}int pthread_mutex_unlock (pthread_mutex_t *__mutex)功能：解锁测试：#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;pthread_mutex_t key = PTHREAD_MUTEX_INITIALIZER;pthread_mutex_t mouse = PTHREAD_MUTEX_INITIALIZER;void* ming(void* arg){    pthread_mutex_lock(&amp;key);    usleep(100);    pthread_mutex_lock(&amp;mouse);    printf("键盘和鼠标都拿到了，可以开心的打游戏了\n");    sleep(5);    pthread_mutex_unlock(&amp;mouse);    pthread_mutex_unlock(&amp;key);}void* huang(void* arg){    pthread_mutex_lock(&amp;key);    usleep(100);    pthread_mutex_lock(&amp;mouse);    printf("键盘和鼠标都拿到了，可以开心的做ppt了\n");    sleep(5);    pthread_mutex_unlock(&amp;mouse);    pthread_mutex_unlock(&amp;key);}int main(){    pthread_t pid1;    pthread_create(&amp;pid1,NULL,ming,NULL);    pthread_t pid2;    pthread_create(&amp;pid2,NULL,huang,NULL);    pthread_join(pid1,NULL);    pthread_join(pid2,NULL);}</code></pre><h2 id="三、死锁"><a href="#三、死锁" class="headerlink" title="三、死锁"></a>三、死锁</h2><pre><code>多个线程进行等待对方的资源，在得到所有资源继续运行前，都不会释放自己的资源，这样造成的循环等待现象，称为死锁。构成死锁的四大必要条件：    1、资源互斥    2、占有，还想占有（请求与保持）    3、资源不可剥夺    4、环路等待（循环等待）防止死锁的方法：    构成死锁的四个条件只要破坏其中一个就构不成死锁，死锁一旦形成就无法消除，因此最后的方法就是避免产生死锁。    1、破坏互斥条件，让资源能够共享，但缺点是不通过，因为有些资源不能共享，如打印机。    2、破坏请求并保持，采用预先分配的方法，在进行运行前一次申请好它所需要的所有资源，但缺点是浪费资源。    3、破坏不可剥夺的条件，对已经占用资源的线程发送取消请求，但是实现比较复杂，而且还会破坏业务逻辑。    4、破坏循环等待条件，为每个资源进行编号，采用顺序的资源分配方法，规定每个线程必须按照递增的顺序请求资源，缺点是编号必须相对稳定，增加新资源时会比较麻烦，而且有些特殊的业务逻辑不能完全按照指定的顺序分配资源。避免产生死锁的算法（银行家算法）：    1、申请资源的额度不能超过银行现有资源的总和。    2、分批向银行，但是货款额度不能超过一开始最大需求量总和。    3、银行如果不能满足客户的需要，必须及时给出答复    4、客户必须在规定的时间内还款。如何检测死锁：    1、画出资源分配图，并简化，模拟资源分析的过程。    2、监控线程过程的栈内存使用情况。    3、设计看门狗机制（TCP心跳包）</code></pre><h2 id="四、信号量"><a href="#四、信号量" class="headerlink" title="四、信号量"></a>四、信号量</h2><pre><code>线程的信号量与进程的信号量的机制是一样的，但使用方法不同，用于控制、管理线程间的共享资源。#include &lt;semaphore.h&gt;int sem_init(sem_t *sem, int pshared, unsigned int value);功能：初始化信号量（创建信号量）sem:信号量ID，输出pshared：一般为0（线程之间）进程中使用的。非零表示进程间使用，但Linux不支持。value：信号量的初始化int sem_wait(sem_t *sem);功能：信号量减1，不够减则阻塞（为0时）。int sem_trywait(sem_t *sem);功能：信号量减1，不够减则立即返回-1int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);功能：信号量减1，不够减则阻塞，直到abs_timeout超时返回-1。struct timespec{    __time_t tv_sec;    long int tv_nsec;}int sem_post(sem_t *sem);功能：信号量+1int sem_destroy(sem_t *sem);功能：销毁信号量int sem_getvalue(sem_t *sem, int *sval);功能：获取信号量的值</code></pre><h2 id="五、生产者与消费者模型"><a href="#五、生产者与消费者模型" class="headerlink" title="五、生产者与消费者模型"></a>五、生产者与消费者模型</h2><pre><code>测试代码：#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/time.h&gt;#define HOUSE_MAX 40// 栈结构char house[HOUSE_MAX] = {};// 栈顶下标int top = 0;// 互斥量（确保只有一个线程访问栈顶）pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;// 满仓条件变量（满仓时生产线程睡入）pthread_cond_t full = PTHREAD_COND_INITIALIZER;// 空仓条件变量（空仓时消费线程睡入）pthread_cond_t null = PTHREAD_COND_INITIALIZER;// 显示仓库void show_house(char* who,char* op,char ch){    printf("%s:",who);    for(int i=0; i&lt;=top; i++)    {        printf("%c",house[i]);    }    printf("%s%c\n",op,ch);}// 生产者线程void* product(void* arg){    char* who = (char*)arg;    for(;;)    {        char ch = 'A' + rand()%26;        pthread_mutex_lock(&amp;mutex);        // 醒来后要再次检查是否满仓        while(HOUSE_MAX &lt;= top)        {            printf("%s:满仓\n",who);            pthread_cond_wait(&amp;full,&amp;mutex);        }        show_house(who,"&lt;-",ch);        // 入仓数据        house[top++] = ch;        // 模拟现实情况        usleep(100000);        // 解锁        pthread_mutex_unlock(&amp;mutex);        // 已经确保仓库不空，通知消费        pthread_cond_signal(&amp;null);    }    return NULL;}// 消费者线程void* consume(void* arg){    char* who = (char*)arg;    for(;;)    {        // 加锁        pthread_mutex_lock(&amp;mutex);        // 检查仓库是否空的        while(0 == top)        {            printf("%s:空仓\n",who);            pthread_cond_wait(&amp;null,&amp;mutex);        }        // 消费数据        char ch = house[--top];        show_house(who,"-&gt;",ch);        usleep(100000);        pthread_mutex_unlock(&amp;mutex);        pthread_cond_signal(&amp;full);    }}int main(){    srand(time(NULL));    pthread_t pid[6] = {};    pthread_create(&amp;pid[0],NULL,product,"生产1");    pthread_create(&amp;pid[1],NULL,product,"生产2");    pthread_create(&amp;pid[2],NULL,product,"生产3");    pthread_create(&amp;pid[3],NULL,consume,"消费1");    pthread_create(&amp;pid[4],NULL,consume,"消费2");    pthread_create(&amp;pid[5],NULL,consume,"消费3");    for(int i=0; i&lt;6; i++)    {        pthread_join(pid[i],NULL);    }}</code></pre><h2 id="六、条件变量"><a href="#六、条件变量" class="headerlink" title="六、条件变量"></a>六、条件变量</h2><pre><code>条件变量可以让线程在满足特定的条件下暂停（睡眠），需要与互斥量配合使用。pthread_cond_t cond = PTHREAD_COND_INITIALIZER;int pthread_cond_init (pthread_cond_t *__restrict __cond, __const pthread_condattr_t *__restrict __cond_attr);功能：初始化条件变量cond:待初始化的条件变量cond_attr:条件变量的属性int pthread_cond_destroy (pthread_cond_t *__cond);功能：销毁条件变量int pthread_cond_wait (pthread_cond_t *__restrict __cond, pthread_mutex_t *__restrict __mutex);功能：让调用者线程进入睡眠，并解锁一个互斥量cond：线程睡入的条件变量mutex：线程睡眠前的要解锁的互斥量（是不是锁定状态没有关系）int pthread_cond_signal (pthread_cond_t *__cond);功能：唤醒条件变量中的线程（一个还是多个？）注意：线程醒的前提条件是互斥量必须是解锁状态的，线程醒前会再次加锁，如果不能加锁就不会醒来。int pthread_cond_timedwait (pthread_cond_t *__restrict __cond, pthread_mutex_t *__restrict __mutex, __const struct timespec *__restrict __abstime);功能：让调用者线程进入睡眠，并解锁一个互斥量注意：不是超时测试：#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;// 定义并初始化条件变量pthread_cond_t cond = PTHREAD_COND_INITIALIZER;pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;void* run(void* arg){    printf("我将进入睡眠...\n");    pthread_cond_wait(&amp;cond,&amp;mutex);    printf("我醒了...\n");}int main(){    pthread_t pid;    pthread_create(&amp;pid,NULL,run,NULL);    sleep(3);    pthread_cond_signal(&amp;cond);    pthread_join(pid,NULL);}</code></pre><h2 id="七、哲学家就餐问题"><a href="#七、哲学家就餐问题" class="headerlink" title="七、哲学家就餐问题"></a>七、哲学家就餐问题</h2><pre><code>百度百科参考资料：Linux下的user/include中的pthread.h文件</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 同步 </tag>
            
            <tag> 互斥 </tag>
            
            <tag> 死锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下线程的相关知识</title>
      <link href="/2019/09/09/linux-xia-xian-cheng-de-xiang-guan-zhi-shi/"/>
      <url>/2019/09/09/linux-xia-xian-cheng-de-xiang-guan-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、线程基本概念"><a href="#一、线程基本概念" class="headerlink" title="一、线程基本概念"></a>一、线程基本概念</h2><pre><code>1、线程就是进程中的执行路线，即进程内部的控制序列，或者说是进程的子任务（进程就是正在运行的程序，它是一个资源单位）2、线程就是轻量级的，没有自己独立的内存资源，使用的是进程的代码段、数据段、bss段、堆（注意：没有栈）、环境变量表、命令行参数、文件描述符、信号处理函数、工作目录、用户ID、组ID等资源。3、线程拥有自己独立的栈，也就是有自己独立的局部变量。4、一个进程中可以同时拥有多个线程，即同时被系统调度的多条执行路线，但至少有一个主进程。</code></pre><h2 id="二、线程基本特点"><a href="#二、线程基本特点" class="headerlink" title="二、线程基本特点"></a>二、线程基本特点</h2><pre><code>1、线程是进程的实体，可以作为系统独立的调试和分派基本单位。2、线程有不同的状态，系统提供了多种线程控制的原语（控制方法），比如：创建线程、销毁线程。3、线程不拥有自己的资源（唯一拥有的就是自己的栈空间），只拥有从属于进程的全部资源，所有资源分配都是面向进程的。4、一个进程中可以有多个线程同时执行，它们可以执行相同的代码,也可以执行不同的代码。5、同一进程内的线程都在同一个地址空间下活动（0~4G），相对于多进程，多线程的系统开销小，任务切换快。6、多进程协同工作时需要通信，而多线程间的数据交换不需要依赖类似的IPC的特殊通信机制，简单而高效。7、每个线程拥有自己独立的线程ID、寄存器信息、函数栈等。8、线程之间也存在优先级。***注意：线程与进程的区别？</code></pre><h2 id="三、POSIX线程"><a href="#三、POSIX线程" class="headerlink" title="三、POSIX线程"></a>三、POSIX线程</h2><pre><code>1、早期的UNIX操作系统中没有线程的，而是各计算机厂商提供了自己私有的线程库，不易移植。2、在1995年左右，定义了统一的线程编程接口，POSIX线程，即pthread。3、pthread包含一个头文件pthread.h，一个共享库libpthread.so4、功能：    线程管理：创建/销毁、分离/联合、设置/获取属性    线程同步（互斥）：互斥量（互斥锁），条件变量，信号量</code></pre><h2 id="四、线程函数"><a href="#四、线程函数" class="headerlink" title="四、线程函数"></a>四、线程函数</h2><pre><code>1、线程创建int pthread_create(pthread_t *thread, const pthread_attr_t *attr,  void *(*start_routine) (void *), void *arg);功能：创建线程thread：获取线程IDattr：创建线程所需要的属性设置，如果为NULL按照默认方式创建线程。start routine：线程的入口函数arg：给线程入口函数传递的参数练习1：把TCP的S端的多进程改成多线程2、等待线程结束int pthread_join(pthread_t thread, void **retval);功能：等待线程结束获取线程入口函数的返回值，线程结束时该函数才返回。thread：线程IDretval：指针变量的地址，用于获取线程入口函数的返回值。注意：线程入口函数在返回数据时，不能返回指向私有栈空间的指针，如果获取到的是指向堆的指针，等待者要负责把该空间释放。注意：当主线程结束，子线程会全部结束。3、获取线程IDpthread_t pthread_self(void);功能：返回当前线程的ID4、比较两个线程IDint pthread_equal(pthread_t t1,pthread_t t2);功能：如果两个线程ID是同一个线程，则返回0，否则返回-1。注意：pthread_t不一定是 unsigned long类型，有些系统中它是结构体类型，所以无法使用==比较。5、线程终止void pthread_exit(void *retval);功能：调用者线程结束（从入口函数return）retval：会返回给pthread_join函数的第二个参数。注意：如果是进程的最后一个线程，当调用pthread_exit时进程也就结束了。6、线程分离非分离:线程可以被创建者调用pthread_join等待（回收资源）。分享状态：线程不需要创建者等待，结束后自动释放资源。int pthread_detach(pthread_t thread);功能：使用调用线程与线程ID为thread线程成为分离状态。7、线程取消int pthread_cancel(pthread_t thread);功能：向指定的线程发送取消操作注意：但对方不一定响应int pthread_setcancelstate(int state, int *oldstate);功能：设置调用者线程是否响应取消操作state：    PTHREAD_CANCEL_ENABLE 允许响应    PTHREAD_CANCEL_DISABLE 禁止响应oldstate：获取旧的取消状态8、线程属性typedef union{    char __size[__SIZEOF_PTHREAD_ATTR_T];    long int __align;}pthread_attr_t;猜测：不让手动修改各项线程的各大项属性，而使用pthread_attr_set/get系列函数来操作。int pthread_attr_init(pthread_attr_t *attr);功能：初始化线程属性int pthread_attr_destroy(pthread_attr_t *attr);功能：销毁线程属性int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);功能：设置线程属性中分离标志detachstate：    PTHREAD_CREATE_DETACHED 分离    PTHREAD_CREATE_JOINABLE 不分离int pthread_attr_getdetachstate(pthread_attr_t *attr, int *detachstate);功能：获取线程属性中分离标志int pthread_attr_setscope(pthread_attr_t *attr, int scope);功能：设置线程属性中线程的竞争范围PTHREAD_SCOPE_SYSTEMPTHREAD_SCOPE_PROCESSint pthread_attr_getscope(pthread_attr_t *attr, int *scope);功能：获取线程属性中线程的竞争范围int pthread_attr_setinheritsched(pthread_attr_t *attr, int inheritsched);功能：设置线程属性中线程的调度策略来源    PTHREAD_INHERIT_SCHED 继承创建者    PTHREAD_EXPLICIT_SCHED 单独设置int pthread_attr_getinheritsched(pthread_attr_t *attr, int *inheritsched);int pthread_attr_setschedpolicy(pthread_attr_t *attr, int policy);功能：设置线程属性中线程的调度策略SCHED_FIFO 先进先出策略SCHED_RR 轮转策略SCHED_OTHER 缺省int pthread_attr_getschedpolicy(pthread_attr_t *attr, int *policy);功能：获取线程属性中线程的调度策略int pthread_attr_setschedparam(pthread_attr_t *attr, const struct sched_param *param);功能：设置线程属性中线程的调度参数（优先级别）param：最高级别0int pthread_attr_getschedparam(pthread_attr_t *attr, struct sched_param *param);int pthread_attr_setguardsize(pthread_attr_t *attr, size_t guardsize);功能：设置线程属性中栈尾的警戒区大小int pthread_attr_getguardsize(pthread_attr_t *attr, size_t *guardsize);功能：获取线程属性中栈尾的警戒区大小int pthread_attr_setstackaddr(pthread_attr_t *attr, void *stackaddr);功能：设置线程属性中线程的栈底地址int pthread_attr_getstackaddr(pthread_attr_t *attr, void **stackaddr);功能：获取线程属性中线程的栈底地址int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);功能：设置线程属性中线程的栈空间字节数int pthread_attr_getstacksize(pthread_attr_t *attr, size_t *stacksize);功能：获取线程属性中线程的栈空间字节数使用方法：    1、定义线程属性结构体    pthread_attr_t attr;    2、初始化线程属性结构体    pthread_attr_init(&amp;attr);    3、使用pthread_attr_set系列函数对结构体变量进行设置。    4、在创建线程时（pthread_create函数的第二个参数）中使用线程属性结构变量创建线程。    int pthread_getattr_np(pthread_t thread, pthread_attr_t *attr);    功能：获取指定线程的属性    int pthread_attr_setstack(pthread_attr_t *attr, void *stackaddr, size_t stacksize);    int pthread_attr_getstack(pthread_attr_t *attr, void **stackaddr, size_t *stacksize);</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下系统调用和文件操作</title>
      <link href="/2019/09/09/linux-xia-xi-tong-diao-yong-he-wen-jian-cao-zuo/"/>
      <url>/2019/09/09/linux-xia-xi-tong-diao-yong-he-wen-jian-cao-zuo/</url>
      
        <content type="html"><![CDATA[<h2 id="一、系统调用"><a href="#一、系统调用" class="headerlink" title="一、系统调用"></a>一、系统调用</h2><pre><code>   UNIX/Linux系统绝大部分功能都是通过系统调用实现，比如：open/close...UNIX/Linux把系统调用都封装成了C函数的形式，但他们不是标准C的一部分。标准库中的函数绝大部分时间都工作在用户态，但部分时间也需要切换到内核（进行了系统调用），比如：malloc/free/fread/fwirte/malloc/free。我们自己所编写的代码也可以直接调用系统接口进入内核态（进行系统调用），比如brk/sbrk/mmap/munmap   系统调用的功能代码存在于内核中，接口定义在C库中，该接口通过系统中断实现调用，而不是普通函数进行跳转。注意：从用户态切换到内核态或从内核态返回到用户态都会消耗时间。time a.outreal    0m0.137s    总执行时间 = 用户态 + 内核态 + 切换消耗的时间user    0m0.092s    用户态执行时间sys     0m0.040s    内核态执行时间strace 程序 可以跟踪系统调用</code></pre><h2 id="二、一切皆文件"><a href="#二、一切皆文件" class="headerlink" title="二、一切皆文件"></a>二、一切皆文件</h2><pre><code>在UNIX/Linux系统下，几乎所有资源都是以文件形式提供的，所以在UNIX/Linux系统下一切皆文件，操作系统把它的服务、功能、设备抽象成简单的文件，提供一套简单统一的接口，这样程序就可以像访问磁盘上的文件一样访问串口、终端、打印机、网络等功能。大多数情况下只需要 open/read/write/ioctl/close 就可以实现对各种设备的输入、输出、设置、控制等。UNIX/Linux下几乎任何对象都可以当作特殊类型的文件，可以以文件的形式访问。目录文件    里面记录的是一些文件信息，相关条目。设备文件    在系统的/dev目录下存储了所有的设置文件    stderr      stdin    stdout普通文件        链接文件    管道文件    socket文件</code></pre><h2 id="三、文件相关系统调用"><a href="#三、文件相关系统调用" class="headerlink" title="三、文件相关系统调用"></a>三、文件相关系统调用</h2><pre><code>open        打开或创建文件 create      创建文件close       关闭文件read        读文件write       写文件lseek       设置文件读写位置unlink      删除链接remove      删除文件</code></pre><h2 id="四、文件描述符"><a href="#四、文件描述符" class="headerlink" title="四、文件描述符"></a>四、文件描述符</h2><pre><code>文件描述符是一个非负整数，表示一个打开的文件，由系统调用open/create/socket返回值。为什么使用文件描述符而不像标准库那样使用文件指针？因为记录文件相关信息的结构存储在内核中，为了不暴露内存的地址，因此文件结构指针不能直接给用户操作，内核中记录一张表，其中一列是文件描述符，对应一列文件结构指针，文件描述符就相当于获取文件结构指针的下标。内核中已经有三个已经打开的文件描述符,它们的宏定义在：    stdin  0    STDIN_FILENO    stdout 1    STDOUT_FILENO    stderr 2    STDERR_FILENO0,1,2 都代表的是终端dup 复制文件描述符dup2 复制指定的文件描述符</code></pre><h2 id="五、open-creat-close"><a href="#五、open-creat-close" class="headerlink" title="五、open/creat/close"></a>五、open/creat/close</h2><pre><code>#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;int open(const char *pathname, int flags);功能：打开文件pathname：文件的路径flags：打开的权限    O_RDONLY, 只读    O_WRONLY, 只写    O_RDWR,   读写    O_NOCTTY, 当打开的是终端设备文件，不要把该文件当作主控终端。     O_TRUNC,  清空    O_APPEND, 追加返回值：文件描述符int open(const char *pathname, int flags, mode_t mode);flags：打开的权限    O_CREAT,  文件不存在则创建    O_EXCL,   如果文件存在，则创建失败mode：设置文件的权限    S_IRWXU  00700 user (file owner) has  read,  write  and  execute permission    S_IRUSR  00400 user has read permission    S_IWUSR  00200 user has write permission    S_IXUSR  00100 user has execute permission    S_IRWXG  00070 group has read, write and execute permission    S_IRGRP  00040 group has read permission    S_IWGRP  00020 group has write permission    S_IXGRP  00010 group has execute permission    S_IRWXO  00007 others have read, write and execute permission    S_IROTH  00004 others have read permission    S_IWOTH  00002 others have write permission    S_IXOTH  00001 others have execute permissionint close(int fd);功能：关闭打开的文件</code></pre><h2 id="六、read-write"><a href="#六、read-write" class="headerlink" title="六、read/write"></a>六、read/write</h2><pre><code>#include &lt;unistd.h&gt;ssize_t read(int fd, void *buf, size_t count);功能：从文件中读取数据到内存fd：文件描述符，open函数的返回值buf：数据的存储位置count：读取的字节数返回值：成功读取到的字节数ssize_t write(int fd,const void *buf, size_t count);功能：把数据写入到文件fd：文件描述符，open函数的返回值buf：要写入的数据内存首地址count：要写入的字节数返回值：成功写入的字节数注意：如果把结构体以文本形式写入到文件，需要先把结构体转换成字符串</code></pre><h2 id="七、lseek"><a href="#七、lseek" class="headerlink" title="七、lseek"></a>七、lseek</h2><pre><code>off_t lseek(int fd, off_t o_fset, int whence);功能：设置文件位置指针o_fset:偏移值whence：    SEEK_SET    SEEK_CUR    SEEK_END返回值：文件指针的位置练习1：实现一个Linux系统下计算文件大小的函数，使用系统调用完成。练习2：实现带覆盖检查的cp命令。</code></pre><h2 id="八、dup-dup2"><a href="#八、dup-dup2" class="headerlink" title="八、dup/dup2"></a>八、dup/dup2</h2><pre><code>int dup(int oldfd);功能：复制文件描述符，操作系统会从末的文件描述符中选择一个返回。oldfd:被复制的文件描述符int dup2(int oldfd, int newfd);功能：复制指定的文件描述符，如果newfd已经被使用，则先关闭，再复制。</code></pre><h2 id="九、标准IO与系统IO比较"><a href="#九、标准IO与系统IO比较" class="headerlink" title="九、标准IO与系统IO比较"></a>九、标准IO与系统IO比较</h2><pre><code>练习3：分别使用标准IO（文件读写open）比较系统IO（fopen等）随机写入1000000个整数到文件，比较哪一种更快，为什么？因为标准IO使用了缓冲技术，当数据写入时并没有立即把数据交给内核，而是先存放在缓冲区中，当缓冲区满时，会一次性把缓冲区中的数据交给内核写到文件中，这样就减少了内核态与用户态的切换次数。而系统IO每写一次数据就要进入一次内核态，这样就浪费了大量时间进行内核态与用户态的切换，因此用时更长如果为系统IO，设置更大的缓冲区，它会比标准IO更快</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 系统调用 </tag>
            
            <tag> 文件操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下库、静态库、共享库</title>
      <link href="/2019/09/09/linux-xia-ku-jing-tai-ku-gong-xiang-ku/"/>
      <url>/2019/09/09/linux-xia-ku-jing-tai-ku-gong-xiang-ku/</url>
      
        <content type="html"><![CDATA[<h2 id="五、库"><a href="#五、库" class="headerlink" title="五、库"></a>五、库</h2><p>库就是目标文件的集合，我们把不需要升级更新维护的代码打包合并在一起方便使用，也可以对源文件进行保密。</p><p>静态库在使用时是把被调用的代码复制到调用模块中,然后再执行程序时，静态库就不需要了。</p><p>静态库的执行速度快，但占用空间大，当库中的内容发生变化时，需要重新编译出新的程序，因此不能轻易修改库中的内容，</p><p>而共享库只是在调用模块中嵌入调用代码的在库的相对位置的地址,当执行程序时，共享库会把程序一起加载到内存中，</p><p>当执行到调用共享库中代码的指令时跳转到共享中执行，执行完毕后再跳转回来。</p><p>占用空间小，方便更新（共享库发生变化后，程序不需要再次编译），相对于静态库执行效率略低。</p><p>静态库的扩展名为.a，共享库（动态库）的扩展名为.so</p><p>当静态库和动态库同时存在，优先调用动态库，调用静态库需要在编译时加-static</p><h2 id="六、静态库："><a href="#六、静态库：" class="headerlink" title="六、静态库："></a>六、静态库：</h2><h3 id="1、创建静态库"><a href="#1、创建静态库" class="headerlink" title="1、创建静态库"></a>1、创建静态库</h3><pre><code>编写源代码：vi .c/.h编译源代码：gcc -c xxx.c -&gt; xxx.o打开生成静态库：ar -r libxxx.a x1.o x2.o ...ar命令的一些参数：-r 把目标文件添加到静态库中，已经存在的更新-q 将目标文件追加到静态库的末尾-d 从静态库中删除目标文件-t 显示静态库中有哪些目标文件-x 把静态库拆分成目标文件</code></pre><h3 id="2、调用静态库"><a href="#2、调用静态库" class="headerlink" title="2、调用静态库"></a>2、调用静态库</h3><pre><code>直接调用：调用者要和库在同一路径下gcc main.c libxxx.a设置环境：设置方法与C_INCLUDE_PATH类似1、打开vim ~/.bashrc 文件2、在文件末尾，添加一行export LIBRARY_PATH=$LIBRARY_PATH:库文件的路径3、重新加载配置文件 source ~/.bashrc4、编译时要指定库名gcc main.c -lmath设置编译参数：-L路径gcc main.c -L路径 -lmath</code></pre><h3 id="3、运行"><a href="#3、运行" class="headerlink" title="3、运行"></a>3、运行</h3><p>在编译时已经把被调函数的二进制复制到可执行文件中了，在执行时不在需要静态库文件。</p><h2 id="七、共享库"><a href="#七、共享库" class="headerlink" title="七、共享库"></a>七、共享库</h2><h3 id="1、创建共享库"><a href="#1、创建共享库" class="headerlink" title="1、创建共享库"></a>1、创建共享库</h3><pre><code>编写源代码: vi .c/.h编译出位置无关目标文件：gcc -c -fpic xxx.c -&gt; xxx.o链接生成共享库：gcc -shared x1.o x2.o ... -o libxxx.so</code></pre><h3 id="2、调用共享库"><a href="#2、调用共享库" class="headerlink" title="2、调用共享库"></a>2、调用共享库</h3><p>直接调用：调用者要和库在同一路径下</p><pre><code>gcc main.c libxxx.so设置环境：设置方法与C_INCLUDE_PATH类似1、打开vim ~/.bashrc 文件2、在文件末尾，添加一行export LIBRARY_PATH=$LIBRARY_PATH:库文件的路径3、重新加载配置文件 source ~/.bashrc4、编译时要指定库名gcc main.c -lmath设置编译参数：-L路径gcc main.c -L路径 -lmath</code></pre><h3 id="3、运行-1"><a href="#3、运行-1" class="headerlink" title="3、运行"></a>3、运行</h3><p>在使用共享库时，调用者只是记录了被调代码在库的位置，因此在执行时需要共享库同时被加载。</p><p>操作系统会根据LD_LIBRARY_PATH环境变量的设置来加载共享库</p><h2 id="八、动态加载共享库"><a href="#八、动态加载共享库" class="headerlink" title="八、动态加载共享库"></a>八、动态加载共享库</h2><pre><code>#include &lt;dlfcn.h&gt;</code></pre><h3 id="1、加载共享库"><a href="#1、加载共享库" class="headerlink" title="1、加载共享库"></a>1、加载共享库</h3><pre><code>void *dlopen(const char *filename, int flag);filename：共享库的库名，或路径flag:    RTLD_LAZY 使用时才加载    RTLD_NOW 立即加载返回值：共享库的句柄（类似文件指针）</code></pre><h3 id="2、获取标识符地址并使用"><a href="#2、获取标识符地址并使用" class="headerlink" title="2、获取标识符地址并使用"></a>2、获取标识符地址并使用</h3><pre><code>void *dlsym(void *handle, const char *symbol);handle：共享库的句柄symbol：标识符的名字返回值：标识符在共享库中的位置（地址，可以解引用，或跳转过去）。</code></pre><h3 id="3、卸载共享库"><a href="#3、卸载共享库" class="headerlink" title="3、卸载共享库"></a>3、卸载共享库</h3><pre><code>int dlclose(void *handle);handle：共享库的句柄返回值：成功返回0，失败返回-1</code></pre><h3 id="4、获取错误信息"><a href="#4、获取错误信息" class="headerlink" title="4、获取错误信息"></a>4、获取错误信息</h3><pre><code>char *dlerror(void);返回值：会把在使用共享库的过程中出现的错误，以字符串形式返回</code></pre><h2 id="九、辅助工具"><a href="#九、辅助工具" class="headerlink" title="九、辅助工具"></a>九、辅助工具</h2><pre><code>nm：查看目标文件、可执行文件、静态库、共享库的中的符号列表ldd：查看可执行程序所依赖的共享库有哪些strip：减肥，去除掉目标文件、可执行文件、静态库和共享库中的符号列表、调试信息。objdump 显示二进制模块的反汇编信息</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 库 </tag>
            
            <tag> 静态库 </tag>
            
            <tag> 共享库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下GNU编译器</title>
      <link href="/2019/09/09/linux-xia-gnu-bian-yi-qi/"/>
      <url>/2019/09/09/linux-xia-gnu-bian-yi-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="GNU编译器"><a href="#GNU编译器" class="headerlink" title="GNU编译器"></a>GNU编译器</h2><p><img src="https://img-blog.csdnimg.cn/20190804160321940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lrYXJvc181MjE=,size_10,color_FFFFFF,t_50" alt="在这里插入图片描述"></p><pre><code>1、支持众多编程语言、平台2、构建过程（C代码是如何变成可执行文件的）。    第一步，预处理. 这一步处理 头文件、条件编译指令和宏定义。    第二步，编译. 将第一步产生的文件连同其他源文件一起编译成汇编代码。    第三步，汇编。将第二步产生的汇编源码转换为 object file.    第四步，链接. 将第三步产生的一些object file 链接成一个可执行的文件。    预处理：把程序员所编译的C代码翻译成标准的C代码    汇编：把预处理后的C代码翻译成汇编代码    编译：把会标代码翻译成二进制指令    链接：把若干个目标文件合并成一个可执行文件3、gcc -v 查看版本4、文件后缀    .h   头文件    .gch 头文件的编译结果，一般不要保留。    .c   源文件    .i   预处理文件    .s   汇编文件    .o   目标文件    .a   静态库文件    .so  共享库文件5、参数    -E  预处理    -S  汇编    -c  编译（只生成目标文件）    -o  指定编译结果的名字    -Wall   产生尽可能多的警告    -Werror 把警告当作错误处理    -x  指定编译的语言    -g  生成调试信息    -On 优化等级    -D  编译时定义宏    -l  链接里加库    -I  指定头文件的查找路径，配置环境变量        1、打开 vim ~/.bashrc        2、在文件末尾，添加一行 export C_INCLUDE_PATH=$C_INCLUDE_PATH:NEW_PATH        3、重新加载配置文件 source ~/.bashrc        注意：如果要删除环境变量需要在~/.bashrc文件中删除环境变量后，退出终端重新打开。        考题1：#include &lt;&gt; / #include "" 区别？        考题2：头文件中可以编写哪些内容？        考题3：头文件的作用？            1、说明对应的.c文件的内容有哪些（声明函数、全局变量）。            2、定义结构、联合、枚举、宏            3、类型重定义            虽然函数可以隐式声明，但并不一定准确，而且非常有可能造成严重错误。6、预处理指令    #include    文件包含，区别""和&lt;&gt;的区别    #define     定义宏常量或宏函数        #       把标识符转换成字符串        ##      合并标识符    #undef      删除宏    #line       指定当前行的行号    #if            条件编译    #ifndef        常用于头文件卫士    #ifdef            #elif    #endif    #error      在编译期间产生错误    #warning    在编译期间产生警告    #pragma        #pragma GCC dependency "文件"  用于监控文件，防止所依赖的文件，修改后而不知道        #pragma GCC poison 标识符      用于禁用某些标识符        #pragma pack(n)                设置结构、联合的补齐和对齐字节数            n的值必须比默认的要小            对齐边界必须是2的较小次方</code></pre><p><img src="https://img-blog.csdnimg.cn/20190804160756901.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2019080416081380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lrYXJvc181MjE=,size_10,color_FFFFFF,t_50" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190804160835724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lrYXJvc181MjE=,size_10,color_FFFFFF,t_50" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190804160917830.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lrYXJvc181MjE=,size_10,color_FFFFFF,t_50" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190804160947726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lrYXJvc181MjE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>思考：<br>    头文件的作用是什么？<br>    编译时头文件找不到怎么办？</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GNU </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络通信TCP/UDP</title>
      <link href="/2019/09/09/wang-luo-tong-xin-tcp-udp/"/>
      <url>/2019/09/09/wang-luo-tong-xin-tcp-udp/</url>
      
        <content type="html"><![CDATA[<h2 id="一、网络通信的基本概念"><a href="#一、网络通信的基本概念" class="headerlink" title="一、网络通信的基本概念"></a>一、网络通信的基本概念</h2><pre><code>1、TCP和UDP的区别    TCP（Transmission Control Protocol）：传输控制协议，面向连接的服务（类似打电话），安全、可靠（三次握手、响应+重传、四次挥手），速度相对较慢，一般应用在对安全性、完整性有严格要求的场景：文件传输（ftp）、SMTP、HTTP        三次握手：            A要知道，A能到B,B能到A            B要也要知道，A能到B，B能到A                         A 你听得到吗 -&gt;       B(此时B知道了A能到B)        （A能到B且B能到A）A &lt;- 我能听到，你叫   B                         A 我也能听到-&gt;        B（此时B知道了B也能到A）        四次挥手：            目的是保证关闭前发送完所有未发送的数据包（应用层已经交给底层了，但底层还没有完全发送出去）。            A 发送关闭请求 -&gt; B            A &lt;- 发送请求相应 B                B检查 是否有未发送完成的数据                &lt;- 可以关闭   B            A 发送关闭消息-&gt;  B    UDP（User Datagram Protocol）：用户数据报文协议，面向无连接的服务（发短信）0，不保证安全、可靠，但大多数情况下是可靠的，相对较快，流媒体（在线视频、音频）。2、消息流    应用层-&gt;表示层-&gt;会话层-&gt;网络层-&gt;传输层-&gt;数据链路层-&gt;物理层-&gt;数据链路层-&gt;传输层-&gt;网络层    -&gt;会话层-&gt;表示层-&gt;应用层3、消息包当socket收到一个要发送的数据时，会先把数据进行拆分成bit流，然后再组成（防丢失）数据包（可能会丢包）。</code></pre><h2 id="二、套接字"><a href="#二、套接字" class="headerlink" title="二、套接字"></a>二、套接字</h2><pre><code>socket是一种接口机制，可以让程序无论使用什么端口、协议、都可以从socket进出数据，它负责了进程与协议之间的连接。1、编程模型    点对点（p2p）：一对一通信    客户机/服务器（C/S）：一对多通信2、函数    int socket(int domain, int type, int protocol);    功能：创建socket描述符，可以把socket当作文件来看待，发送数据就是写文件，接收数据就是读文件。    domain:地址类型        AF_UNIX/AF_LOCAL/AF_FILE    本地通信（进程间通信）        AF_INET                     基本32IP地址通信，IPv4 Internet protocols        AF_INET6                    基本128IP地址通信，IPv6，IPv6 Internet protocols    type:通信协议        SOCK_STREAM     数据流协议，TCP        SOCK_DGRAM      数据报协议，UDP    protocol：特别通信协议，给0即可。    返回值：socket描述符，类似文件描述符3、通信地址    注意：函数接口定义的是sockaddr，而实际提供的是sockaddr_un或sockaddr_in    struct socketaddr{        sa_family_t sa_family;        char sa_data[14];    }    struct sockaddr_un {        __SOCKADDR_COMMON(sun_); /* AF_UNIX */地址类型 参看domain参数         char sun_path[108]; /* pathname */socket文件的路径    };    struct sockaddr_in{        __SOCKADDR_COMMON(sin_);        in_port_t sin_port;     // 端口号 大端字节序 参看联合        struct in_addr sin_addr // ip地址 大端4字节整数    }    struct in_addr{        in_addr_t s_addr; //     }4、绑定    socket描述符与物理通信载体（网卡或socket文件）绑定在一起。    int bind(int sockfd, const struct sockaddr *addr,socklen_t addrlen);    sockfd：socket描述符：socket函数的返回值    addr：通信地址结构体，实际给的是sockaddr_un或sockaddr_in，需要强制类型转换。    addrlen：通信地址结构体类型的字节数，使用sizeof计算。5、连接    int connect(int sockfd, const struct sockaddr *addr,socklen_t addrlen);    sockfd：socket描述符    addr：通信目标地址    addrlen：通信地址结构体类型的字节数，使用sizeof计算。    返回值：在不同的编程模型下返回值意义不同，在本地通信        返回加0，失败返回-1。6、数据接收与发送：read/write    ssize_t recv(int sockfd, void *buf, size_t len, int flags);    ssize_t send(int sockfd, const void *buf, size_t len, int flags);    recv／send与read/write功能一样，flags多了是否阻塞的功能（0阻塞，1不阻塞）。7、关闭套接字：close    如果是网络通信，端口号并不会立即回收，大概会占用3分钟左右。8、字节序转换#include &lt;arpa/inet.h&gt;    uint32_t htonl(uint32_t hostlong);    功能：把32位本机字节序转换成32位的网络字节序    uint16_t htons(uint16_t hostshort);    功能：把16位本机字节序转换成16位的网络字节序    uint32_t ntohl(uint32_t netlong);    功能：把32位网络字节序转换成32位的本机字节序    uint16_t ntohs(uint16_t netshort);    功能：把16位网络字节序转换成16位的本机字节序9、ip地址转换#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;    int inet_aton(const char *cp, struct in_addr *inp);    功能：把点分十进制的ip地址（字符串）转换成32位无符号整数，使用指针获取。    in_addr_t inet_addr(const char *cp);    功能：把点分十进制的ip地址（字符串）转换成32位无符号整数，使用返回值直接返回。    char *inet_ntoa(struct in_addr in);    功能：32位无符号整数表示的ip地址，转换成点分十进制的ip地址（字符串）。10、本地通信编程模型    进程A                      进程B    创建套接字（AF_LOCAL）      创建套接字（AF_LOCAL）     准备地址（sockaddr_un）     准备地址（sockaddr_un）    绑定（自己的socket/地址）    连接（connect，连接进程A的地址）    接收数据                    发送数据    关闭套接字</code></pre><h2 id="三、基于TCP协议的C-S模型"><a href="#三、基于TCP协议的C-S模型" class="headerlink" title="三、基于TCP协议的C/S模型"></a>三、基于TCP协议的C/S模型</h2><pre><code>int listen(int sockfd, int backlog);    功能：设置等待连接的最大数量    sockfd:被监听的socket描述符    backlog:等待连接的最大数量（排队的数量）int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);    功能：等待连接sockfd连接    addr：获取连接的地址    addrlen：设置连接地址结构体的长度    返回值：专门用于通信的描述符编程模型：    Server                                  Client    创建socket套接字                         创建socket套接字    准备地址（sockaddr_in,本机地址）          准备地址（服务器地址）    绑定（bind）                             。。。    监听（listen）                           。。。    等待连接（accept、fork）                 连接（connect）    接收请求(read/recv)                      发送请求（write/send）    响应请求(write/send)                     接收响应（read/recv)                        关闭(close)                              关闭（close）</code></pre><h2 id="四、基于UDP协议的C-S模型"><a href="#四、基于UDP协议的C-S模型" class="headerlink" title="四、基于UDP协议的C/S模型"></a>四、基于UDP协议的C/S模型</h2><pre><code>ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,  const struct sockaddr *dest_addr, socklen_t addrlen);功能：UDP协议专用的数据发送函数    sockfd：套接字描述符    buf：待发送的缓冲区首地址    len：待发送的数据字节数    flags：0阻塞，1不阻塞    dest_addr：目标计算机地址（发送）    addrlen：地址结构体的字节数    返回值：成功发送的字节数ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);功能：UDP协议专用的数据接收函数    sockfd：套接字描述符    buf：数据存储位置     len：最大接收字节数    flags：0阻塞，1不阻塞    src_addr：获取发送者的地址    addrlen：设置地址结构体的字节数    返回值：成功接收的字节数。编程模型：Server                                  Client创建套接字（socket）                     创建套接字（socket）   准备地址（本机地址sockaddr_in）           准备地址（目标机地址sockaddr_in）绑定（bind（sockfd+addr））              。。。接收请求（recvfrom）                     发送请求（sendto）响应请求（sendto）                       接收响应（recvfrom）关闭套接字（close）                      关闭套接字（close）注意：从服务器到客户端返回的路线是UDP协议自己设计的。</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络通信 </tag>
            
            <tag> TCP </tag>
            
            <tag> UDP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++操作符重载相关知识</title>
      <link href="/2019/09/05/c-cao-zuo-fu-chong-zai-xiang-guan-zhi-shi/"/>
      <url>/2019/09/05/c-cao-zuo-fu-chong-zai-xiang-guan-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、操作符函数重载"><a href="#一、操作符函数重载" class="headerlink" title="一、操作符函数重载"></a>一、操作符函数重载</h2><pre><code>什么是操作符函数：在C++中针对类类型的对象的运算符，由于它们肯定不支持真正的运算操作，因此编译器会将它们翻译成函数，这种就叫做操作符函数（运算符函数）。编译器把运算翻译成运算符函数，可以针对自定义的类类型设计它独有的运算功能。其实各种运算符已经具备一些功能，再次实现它的就是叫作运算符重载。双目运算符：    a+b    成员函数        a.operator+(b);    全局函数        operator+(a,b);单目运算符：    !a    成员函数        a.operator!(void);    全局函数        operator!(a);</code></pre><h2 id="二、双目操作符函数重载"><a href="#二、双目操作符函数重载" class="headerlink" title="二、双目操作符函数重载"></a>二、双目操作符函数重载</h2><pre><code>成员函数：const 类对象 operator#(const 类&amp; that) const{    return 类(参数#参数);}注意：双目录运算符的运算结果是个右值，返回值应该加 const ，然后为了const对象能够调用，参数应写const，函数也应该具备const属性。全局函数：const 类 operator#(const 类&amp; a,const 类&amp; b){}注意：全局函数不是成员函数，可能会需要访问到类的私有成员，解决这种问题可以把函数声明为类的友元函数（友元不是成员）。友元：在类的外部想访问类的私有成员（public/protected/private）时，需要把所在的函数声明为友元，但是友元只是朋友，因此它只有访问权，没有实际的拥有权（其根本原因是它没有this指针）。友元声明：把函数的声明写一份到类中，然后在声明前加上friend 关键字。使用友元即可把操作符函数定义为全局的，也可以确保类的封装性。注意：友元函数与成员函数不会构成重载关系，因此它们不在同一个作用域内。</code></pre><h2 id="三、赋值类型的双目操作符"><a href="#三、赋值类型的双目操作符" class="headerlink" title="三、赋值类型的双目操作符"></a>三、赋值类型的双目操作符</h2><pre><code>成员    类 operator#(void)    {    }全局    类 operator#(const 类&amp; that)    {    }1、获取单参构造成赋值运算的调用方式。String str = "xxx"; // 会调用单参构造，而不调用赋值运算符str = "hhh";2、左操作数据不能具有const属性    1.成员函数不能是常函数    2.全局函数第一个参数不能有const属性3、返回值应该都（成员/全局）具备const属性</code></pre><h2 id="四、单目操作符函数重载"><a href="#四、单目操作符函数重载" class="headerlink" title="四、单目操作符函数重载"></a>四、单目操作符函数重载</h2><pre><code>-,~,!,&amp;,*,-&gt;,++,--成员    const 类 operator#(void) const    {    }全局    const 类 operator#(const 类&amp; that)    {    }前++/--    类&amp; operator#(void)    {    }    类&amp; operator#(类&amp; that)    {    }后++/--(哑元)    const 类&amp; operator#(int)    {    }    const 类&amp; operator#(类&amp; that,int)    {    }</code></pre><h2 id="五、输入输出操作符重载"><a href="#五、输入输出操作符重载" class="headerlink" title="五、输入输出操作符重载"></a>五、输入输出操作符重载</h2><pre><code>cout 是 ostream 类型的对象，cin 是 istream 类型的对象。如果&lt;&lt;/&gt;&gt;运算实现为成员函数，那么调用者应该是ostream/istream,而我们无权增加标准库的代码，因此输入/输出运算符只能定义为全局函数。ostream&amp; operator&lt;&lt;(ostream&amp; os,const 类&amp; n){}istream&amp; operator&gt;&gt;(istream&amp; os,类&amp; n){}</code></pre><h2 id="六、特殊操作符的重载（笔试面试比较重要）"><a href="#六、特殊操作符的重载（笔试面试比较重要）" class="headerlink" title="六、特殊操作符的重载（笔试面试比较重要）"></a>六、特殊操作符的重载（笔试面试比较重要）</h2><pre><code>1、下标操作符 []，常用于在容器类型中以下标方式获取元素。类型&amp; operator[](int i){}2、函数操作符()，一个类如果重载函数操作符，那么它的对象就可以像函数一样使用，参数的个数、返回值类型，可以不确定，它是唯一一个可以参数有缺省参数的操作符。</code></pre><pre><code>#include &lt;iostream&gt;#include &lt;stdlib.h&gt;using namespace std;class Array{    int* arr;    size_t len;public:    Array(size_t len):len(len)    {        arr = new int[len];    }    void operator()(void)    {        cout&lt;&lt;"emmm"&lt;&lt;endl;    }    int&amp; operator[](int i)    {        if(i &lt; 0 || i &gt;= len)        {            cout&lt;&lt;"下标错误"&lt;&lt;endl;            exit(0);        }        return arr[i];    }};int main(){    Array arr(100);    for(int i=0; i&lt;10; i++)    {        arr[i] = i;        cout&lt;&lt; arr[i] &lt;&lt; endl;    }    arr();}</code></pre><pre><code>3、解引用操作符*，成员访问操作符-&gt;    如果一个类重载了*和-&gt;，那么它的对象就可以像指针一样使用。    所谓的智能指针就是一种类对象，它支持解引用和成员访问操作符。4、智能指针    常规指针的缺点：        当一个常规指针离开它的作用域时，只有该指针所占用的空间会被释放，而它指向的内存空间能否被释放就不一定了，在一些特殊情况（人为、业务逻辑特殊）free或delete没有执行，就会形成内存泄漏。    智能指针的优点：        智能指针是一个封装了常规指针的类类型对象，当它离开作用域时，它的析构函数会自动执行，它的析构函数会负责释放常规指针所指向的动态内存（以正确方式创建的智能指针，它的析构函数才会正确执行）。    智能指针和常规指针的相同点：都支持*和-&gt;运算。    智能指针和常规指针的不同点：        任何时候，一个对象只能使用一个智能指针来指向，而常规指针可以指向多次。        只能指针的赋值操作需要经过拷贝构造和赋值构造特殊处理（深拷贝）。</code></pre><pre><code>#include &lt;iostream&gt;using namespace std;class Int{public:    int val;    Int(int val=0):val(val){ }    void set_val(int val)    {        this-&gt;val = val;    }    int get_val(void)    {        return val;    }    Int&amp; operator=(const int val)    {        this-&gt;val = val;        return *this;    }    ~Int(void)    {        cout&lt;&lt;"我是Int的析构函数"&lt;&lt;endl;    }    friend ostream&amp; operator&gt;&gt;(ostream&amp; os,Int&amp; n);};ostream&amp; operator&lt;&lt;(ostream&amp; os,Int&amp; n){    return os&lt;&lt;n.val;}class IntPointer{    Int* ptr;public:    IntPointer(Int* ptr):ptr(ptr){ }    Int&amp; operator*(void)    {        return *ptr;    }    ~IntPointer(void)    {        delete ptr;    }};int main(){    Int* num =new Int(100);    IntPointer p = num;    *p = 20;    cout&lt;&lt;*p &lt;&lt;endl;    *p = 10;    cout&lt;&lt;*p &lt;&lt;endl;}</code></pre><pre><code>auto_ptr:标准库中封装好的智能指针，实现了常规指针的基本功能，头文件 #include &lt;memory&gt;    用法：auto_ptr&lt;指向的类型&gt; 指针变量名(对象的地址)    auto_ptr的局限性：        不能跨作用域使用，一旦离开作用域指针变量会释放它指向的对象也会释放。        不能放入标准容器。        不能指向对象数组。</code></pre><pre><code>#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;class A{public:    A(void)    {        cout&lt;&lt;"构造"&lt;&lt;endl;    }    ~A(void)    {        cout&lt;&lt;"析构"&lt;&lt;endl;    }    void show(void)    {        cout&lt;&lt;"A's show"&lt;&lt;endl;    }};int main(){    auto_ptr&lt;A&gt; ptr(new A);    (*ptr).show();}</code></pre><pre><code>5、new/delete/new[]/delete[]运算符重载    1.C++缺省的堆内存管理器速度较慢，重载new/delete底层使用malloc/free可以提高运行速度。    2.new在失败会产生异常，而每次使用new时为了安全都应该进行异常捕获，而重载new操作符只需要在操作符函数中进行一次错误处理即可。    3.在一些占字节数比较小的类，频繁使用new，可能会产生大量的内存碎片，而重载new操作符后，可以适当的扩大每次申请的字节数，减少内存碎片产生的机率。    4.重载 new/delete 可以记录堆内存使用的信息    5.重载 delete 可以检查到释放内存失败时的信息，检查到内存泄漏。</code></pre><h2 id="七、重载操作符的限制"><a href="#七、重载操作符的限制" class="headerlink" title="七、重载操作符的限制"></a>七、重载操作符的限制</h2><pre><code>1、不能重载的操作符    域限定符 ::    直接成员访问操作符 .    三目操作符 ?:    字节长度操作符 sizeof    类型信息操作符 typeid2、重载操作符不能修改操作符的优先级3、无法重载所有基本类型的操作符运算4、不能修改操作符的参数个数5、不能发明新的操作符</code></pre><h2 id="关于操作符重载的建议："><a href="#关于操作符重载的建议：" class="headerlink" title="关于操作符重载的建议："></a>关于操作符重载的建议：</h2><pre><code>1、在重载操作符时要根据操作符实际的功能和意义来确定具体参数，返回值，是否具有const属性，返回值是否是引用或者临时对象。2、重载操作符要符合情理（要有意义），要以实际用途为前提。3、重载操作符的意义是为了让对象的操作更简单、方便，提高代码的可读性，而不是为了炫技。4、重载操作符要与默认的操作符的功能、运算规则一致，不要出现反人类的操作。#define ture 0#define false 1</code></pre><p>相关测试代码：</p><pre><code>#include &lt;iostream&gt;using namespace std;class Point{    int x;    int y;public:    Point(int _x=0,int _y=0)    {        x = _x;        y = _y;    }/*    void show(void) const    {        cout&lt;&lt; "(x:" &lt;&lt;x &lt;&lt;",y:" &lt;&lt;y&lt;&lt; ")"&lt;&lt;endl;    }*/    friend const Point operator+(const Point&amp; a,const Point&amp; b);    friend const Point operator-(const Point&amp; a,const Point&amp; b);    friend const Point operator*(const Point&amp; a,int b);    friend const Point operator*(int a,const Point&amp; b);    const Point operator/(const int that) const    {        return Point(x/that,y/that);    }/*    const Point operator+(const Point&amp; that) const    {        return Point(that.x+x,that.y+y);    }*/    const Point&amp; operator+=(const Point&amp; that)    {        x += that.x;        y += that.y;        cout&lt;&lt;"___";        return *this;    }    Point operator-(void)    {        return Point(-x,-y);    }    // 前++    Point&amp; operator++(void)    {        x++;        y++;        return *this;    }    // 后++ (哑元)/*    Point operator++(int)    {        Point temp(x,y);        x++;        y++;        return temp;    }*/    friend Point operator++(Point&amp; that,int);//友元    Point operator--(int)    {        Point temp(x,y);        x--;        y--;        return temp;    }    friend ostream&amp; operator&lt;&lt;(ostream&amp; os,const Point&amp; p);    friend istream&amp; operator&gt;&gt;(istream&amp; is,Point&amp; p);};ostream&amp; operator&lt;&lt;(ostream&amp; os,const Point&amp; p){    return os &lt;&lt;p.x&lt;&lt;","&lt;&lt;p.y;}istream&amp; operator&gt;&gt;(istream&amp; is,Point&amp; p){    cout &lt;&lt; "请输入x的值:";    is &gt;&gt; p.x;    cout&lt;&lt;"请输入y的值：";    is &gt;&gt; p.y;    return is;}Point operator++(Point&amp; that,int){    Point temp(that.x,that.y);    that.x++;    that.y++;    return temp;}const Point operator+(const Point&amp; a,const Point&amp; b){    return Point(a.x+b.x,a.y+b.y);}const Point operator-(const Point&amp; a,const Point&amp; b){    return Point(a.x-b.x,a.y-b.y);}const Point operator*(const Point&amp; a,int b){    return Point(a.x*b,a.y*b);}const Point operator*(int a,const Point&amp; b){    return Point(a*b.x,a*b.y);}int main(){    Point p(3,9);    Point p1(1,3);    Point p2 = p1+p+p1;    cout&lt;&lt;"+:";    cout&lt;&lt;p2&lt;&lt;endl;    Point p4(6,6);    cin&gt;&gt;p4;    cout&lt;&lt;p4&lt;&lt;endl;//    p2.show();    p2 = p2-p1;    cout&lt;&lt;"-:";    cout&lt;&lt;p2&lt;&lt;endl;//    p2.show();    p2 = p1*3;    cout&lt;&lt;"*:";    cout&lt;&lt;p2&lt;&lt;endl;//    p2.show();    p2 = 3*p1;//    p2.show();    cout&lt;&lt;p2&lt;&lt;endl;    cout&lt;&lt;(-p1)&lt;&lt;endl;//    (-p1).show();    p2 = p1;//    p2.show();//    (++p1).show();    cout&lt;&lt;(++p1)&lt;&lt;endl;//    (p2++).show();    cout&lt;&lt;"p2:"&lt;&lt;(p2++)&lt;&lt;endl;    cout&lt;&lt;"p2:"&lt;&lt;p2&lt;&lt;endl;//    p2.show();    cout&lt;&lt;"p2:"&lt;&lt;(p2--)&lt;&lt;endl;    cout&lt;&lt;"p2:"&lt;&lt;p2&lt;&lt;endl;//    (p2--).show();//    p2.show();    p2 = p2/3;//    p2.show();    cout&lt;&lt;"p2:"&lt;&lt;p2&lt;&lt;endl;}</code></pre><p>如有错误，望指出，谢谢~</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UML相关知识</title>
      <link href="/2019/09/04/uml-xiang-guan-zhi-shi/"/>
      <url>/2019/09/04/uml-xiang-guan-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、UML概述"><a href="#一、UML概述" class="headerlink" title="一、UML概述"></a>一、UML概述</h2><pre><code>1、什么是UML    统一建模语言（Unified Modeling Language）。用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的开发方法。UML展现了一系列最佳工程实践，这些最佳实践在对大规模，复杂系统进行建模方面，特别是在软件架构层次已经被验证有效。    项目开发的说明书（设计图）。2、UML是做什么的    帮助建立软件开发过程和各种模型    主要目的是为了让开发者之间进行有效的交流。        开发者与设计者之间的交流        开发者与开发者之间的交流        开发者与管理者之间的交流    适合大型项目和大型团队的开发3、UML的应用领域    UML的目标是以面向对象的方式来描述任何类型的系统，常用于建立软件的模型。4、我对UML的看法    不建议用UML生成代码。    没有完美的UML图，够用就行，图是死的，人是活的。    UML主要功能是为了更好的让开发团队与用户之间进行沟通交流。    先结对学习UML目的以应用、看懂为主(有利于后期工作)，以画图为辅。    但需要长期学习，为后期成为系统分析师、架构师、产品经理、项目经理打下基础。</code></pre><h2 id="二、Rational-Rose四种视图与UML的8中图形关系"><a href="#二、Rational-Rose四种视图与UML的8中图形关系" class="headerlink" title="二、Rational Rose四种视图与UML的8中图形关系"></a>二、Rational Rose四种视图与UML的8中图形关系</h2><pre><code>    Rose启动后自动创建四种视图：        用例视图： Use Case View            帮助理解和使用系统，这种图展示了系统的参与者和用例是怎么相互作用的，包括了系统中的所有角色。            用例图：Use Case Digram            时序图：Sequence Digram            协作图：Collaboration Digram            活动图：Activity Digram            这种视图的主要使用都是用户、分析人员、项目管理人员。        逻辑视图： Logical View            逻辑视图关注的是系统如何实现用例中提出的功能，它提供系统的详细图形，描述了组件间如何关联。            类图：Call Digram            状态图：Statechart Dirgam            这种视图的主要使用者是开发人员，开发人员包括：程序员、需求分析师、测试工程师、项目经理。        构件视图： Component View            这种视图关注的是代码模板间的关系，通过组件视图可以知道哪些代码是组件，哪些是代码库，哪些是运行组件，会默认有一个Component图表。            这种视图的主要使用者是负责控制代码、编译、部署应用程序的人员。        部署视图： Deployment View            这种视图关注的是系统的实际部署，进程和设备间的实际连接。            这种视图的使用者是用户和软件的发布人员。</code></pre><h2 id="三、用例图：详细表示所有的用例需求，不考虑细节"><a href="#三、用例图：详细表示所有的用例需求，不考虑细节" class="headerlink" title="三、用例图：详细表示所有的用例需求，不考虑细节"></a>三、用例图：详细表示所有的用例需求，不考虑细节</h2><pre><code> 1、用例图的作用        主要用它来描述需求，画图时要从用户的角度出发，主要用于与用户之间的交流。    2、用例图的要点        正确反应用户的需求        每个用例的内部实现        细节不是本阶段要考虑的问题    3、用例图包括        参与者        用例        用例之间的关系    4、如何确定参与者        谁使用系统        谁负责启动、关闭系统        谁查询数据        谁提供数据        谁安装、升级系统    5、什么是用例        是系统的使用过程，一个用例就是一个功能需求。</code></pre><h2 id="四、类图：主要表示类与类之间的关系，不用详细考虑类的属性和方法"><a href="#四、类图：主要表示类与类之间的关系，不用详细考虑类的属性和方法" class="headerlink" title="四、类图：主要表示类与类之间的关系，不用详细考虑类的属性和方法"></a>四、类图：主要表示类与类之间的关系，不用详细考虑类的属性和方法</h2><pre><code>    1、类图的主要作用        主要用来描述类的内部结构和类与类之间的关系。        类图中不显示暂时性的消息，是面向对象剑魔时的主要组成部分。    2、类图主要包括        名称：类名        属性：类的成员变量            访问权限            变量名            类型        操作：类的成员函数            访问权限            函数名            参数名            参数类型            返回值类型        职责：说明此类具体负责的任务，解决什么问题    3、类之间的关系        继承关系：空心箭头实线来表示继承关系，子类指向父类            一个类Test继承Base类的属性和行为，并可以增加自己的属性和行为。        实现关系：空心箭头虚线来表示继承关系，子类指向父类            一个类Test继承一个抽象类，父类中的函数定义为纯虚函数，子类继承后覆盖所有纯虚函数。        依赖关系：箭头和虚线来表示依赖关系，依赖者指向被依赖者            一个类A中使用到类B（类A中的函数的参数或返回值类型是类B），这种关系是一种偶然、临时的，是一种非常弱的关系。        关联关系：箭头和实线来表示关联关系，依赖者指向被依赖者            是一种强依赖关系，类A的属性（成员变量）是类B。        聚合关系：实心菱形和箭头实线来表示聚合关系，菱形指向整体，箭头指向部分。            聚合关系是一种关联关系的特例，它体现的是整体与部分。            整体与部分之间是可分离，它们可以具有各自的生命周期。            从代码层面来讲与关联是一致的。        组合关系：实心菱形和箭头实线来表示组合关系，菱形指向整体，箭头指向部分。            组合关系也是一种聚合关系的特例，这种关系比聚合更强，也称为强聚合，同样也体现出整体与部分，但此时的整体与部分是不可分隔的。            从代码层面来讲与关联是一致的。        从代码实现层面只有继承、包含、依赖。    用例图和类表示对象之间消息的发送顺序，值考虑正确情况。</code></pre><h2 id="五、时序图：主要表示对象之间消息的发送顺序，只考虑正确情况。"><a href="#五、时序图：主要表示对象之间消息的发送顺序，只考虑正确情况。" class="headerlink" title="五、时序图：主要表示对象之间消息的发送顺序，只考虑正确情况。"></a>五、时序图：主要表示对象之间消息的发送顺序，只考虑正确情况。</h2><pre><code>用来表示对象之间的关系，同时强调对象之间的交互。时序图向用户表示时间随着时间的推移，清晰的可视化轨迹。时序图用来表示项目中的某个操作中如何进行的，具体的步骤是什么。</code></pre><h2 id="六、状态图"><a href="#六、状态图" class="headerlink" title="六、状态图"></a>六、状态图</h2><pre><code>用来表示对象的状态变化，用于帮助开发人员理解系统中对象的行为。主要有状态，生命周期，条件，状态转换，事件和动作。</code></pre><h2 id="七、活动图"><a href="#七、活动图" class="headerlink" title="七、活动图"></a>七、活动图</h2><pre><code>活动图的本质就是流程图，它描述了系统的活动、判断点和分支。侧重于操作而不是对象，重点表示逻辑变化。一个动作的流程图一般包括起点、终点、操作。泳道：用于多种角色参与一个过程，一个活动只能属于一个泳道。</code></pre><h2 id="八、协作图"><a href="#八、协作图" class="headerlink" title="八、协作图"></a>八、协作图</h2><pre><code>主要用来描述对象之间的交互关系，强调参与交互的各对象的组织。需要按照组织对控制流程进行建模时选择画协作图。协作图与时序图的区别：    时序图描述了交互过程中的时间顺序，但没有表达对象之间的关系。    协作图描述了对象间的关系但时间顺序必须从时序图中获得。合格的协作图和时序图主义相同，可互换，而不丢失信息。</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> UML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的项目的相关问题</title>
      <link href="/2019/09/04/wo-de-xiang-mu-de-xiang-guan-wen-ti/"/>
      <url>/2019/09/04/wo-de-xiang-mu-de-xiang-guan-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>由于个人编程是，使用的自己的getch.h头文件，导致可能部分项目无法成功通过编译。<br>Linux系统，需要将getch.h添加到user/include下<br>Windows系统，需要将getch.h头文件换为conio.h</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 相关问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中的虚函数表、强制类型转换、I/O流等</title>
      <link href="/2019/09/03/c-zhong-de-xu-han-shu-biao-qiang-zhi-lei-xing-zhuan-huan-i-o-liu-deng/"/>
      <url>/2019/09/03/c-zhong-de-xu-han-shu-biao-qiang-zhi-lei-xing-zhuan-huan-i-o-liu-deng/</url>
      
        <content type="html"><![CDATA[<h2 id="一、虚函数表"><a href="#一、虚函数表" class="headerlink" title="一、虚函数表"></a>一、虚函数表</h2><pre><code>什么是虚函数表，在C++的类中，一旦成员函数中有虚函数，这个类中就会多一个虚函数表指针，这个指针指向一个虚函数表，表里面记录了这个类中所有的虚函数，当这个类被继承，它的子类中也会有一个虚函数表（不管子类中有没有虚函数），如果子类的成员函数中有函数签名与父类的虚函数一样，就会用子类中的函数体寒它在虚函数表中的位置，这样就达到了覆盖的效果。当通过类指针或引用调用函数时，会根据对象中实际的虚函数表记录来调用函数，这样就达到了多态的效果。</code></pre><h2 id="二、虚析构"><a href="#二、虚析构" class="headerlink" title="二、虚析构"></a>二、虚析构</h2><pre><code>当使用delete释放一个父类指针时，不管实际指向的对象是子类还是父类都只会调用父类的析构函数（多态肯定会出现的问题）。如果子类的析构函数有需要负责释放的内存，就会造成内存泄漏。为了解决这个问题，可以把父类的析构函数设置为虚函数，析构函数进行覆盖时不会比较函数名。当父类的析构函数为虚函数时，通过父类指针或引用释放子类对象时，会自动调用子类的析构函数，子类的析构函数执行完成后也会调用父类的析构函数。注意：析构函数可以是虚函数，但构造函数不行</code></pre><h2 id="三、强制类型转换"><a href="#三、强制类型转换" class="headerlink" title="三、强制类型转换"></a>三、强制类型转换</h2><pre><code>注意：C++中为了兼容C语言，(目标类型)源类型 依然可以继续使用，但C语言的强制类型转换安全性差，因此建议使用C++中的强制类型转换。注意：C++之父认为如果代码设计的完善，根本不需要用到强制类型转换，而C++的强制类型转换之所以设计的很复杂，是为了让程序员多关注代码本身的设计，尽量少使用。C++中的强制类型转换保证没有很大安全隐患。static_cast&lt;目标类型&gt;(源类型)   编译器会对源类型和目标类型做兼容性检查，不通过则报错。dynamic_cast&lt;目标类型&gt;(源类型)  编译器会对源类型和目标类是否同为指针或引用，并且存在多态型的继承关系。const_cast&lt;目标类型&gt;(源类型)    编译器会对源类型和目标类检查，是否同为指针或引用，除了常属性外其他必须完全相同，否则报错。reinterpret_cast&lt;目标类型&gt;(源类型)  编译器会对源类型和目标类是否为指针或整数进行检查，也就是说把整数转换成指针或把指针转换为整数。</code></pre><p>拓展：<br>    静态编译：指针或引用的目标是确定的，在编译时期就确定了所有的类型检查、函数调用。<br>    动态编译：指针或引用的目标是不确定的（多态），只有在函数调用的时候才确定具体是哪一个子类。</p><h2 id="四、I-O流"><a href="#四、I-O流" class="headerlink" title="四、I/O流"></a>四、I/O流</h2><pre><code>I/O流的打开模式：    ios::in     以读权限打开文件，不存在则失败，存在不清空    ios::out    以写权限打开文件，不存在则创建，存在则清空    ios::app    打开文件用于追加，不存在则创建，存在不清空    ios::binary 以二进制模式进行读写    ios::ate    打开时定位到文件末尾    ios::trunc  打开文件时清空fstream/ifstream/ofstream 类用于进行文件操作。    构造函数或成员函数 open 用于打开文件    good成员函数检查流是否可用    eof成员函数用于输入流是否结束操作符 &gt;&gt;  用于从文件中读取数据到变量 操作符 &lt;&lt;  用于输出数据到文件IO流有一系列格式化控制函数，类似：左对齐、右对齐、宽度、填充、小数点位数。</code></pre><pre><code>#include &lt;iostream&gt;#include &lt;fstream&gt;using namespace std;int main(){    fstream fsi("test.txt",ios::in);    //fs.open("test.txt",ios::in);    if(!fsi.good())    {        cout &lt;&lt;"打开失败"&lt;&lt;endl;    }    else    {        cout &lt;&lt;"打开成功"&lt;&lt;endl;    }    string str,s1,s2,s3;    int num = 0;/*    fsi &gt;&gt; str;    //读到空格或换行就停止    fsi &gt;&gt; num &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; s3;    cout&lt;&lt;str&lt;&lt;"-"&lt;&lt;num&lt;&lt;"-"&lt;&lt;s1&lt;&lt;"-"&lt;&lt;s2&lt;&lt;"-"&lt;&lt;s3&lt;&lt;endl;*/    string arr[10];    int i = 0;    while(1)    {        fsi &gt;&gt; arr[i];        if(arr[i].size() == 0)        {            break;        }        i++;    }    for(int j=0; j&lt;i; j++)    {        cout &lt;&lt; arr[j] &lt;&lt;"-";    }    fstream fso("test.txt",ios::out);    fso &lt;&lt; "hehe" &lt;&lt; " " &lt;&lt; 100 &lt;&lt;" " &lt;&lt;"adsadsad"&lt;&lt;endl;}</code></pre><pre><code>二进制读写：read/write    read (char_type *__s,streamsize __n)    write (char_type *__s,streamsize __n)gcount成员函数可以获取上次流的二进制读写操作的字节数。随机读写：    seekp (off_type,ios_base::seekdir)    功能：设置文件的位置指针。    off_type：偏移值        正值向右，负值向左    seekdir：基础位置        ios::beg    文件开头        ios::cur    当前位置        ios::end    文件末尾</code></pre><pre><code>#include &lt;iostream&gt;#include &lt;fstream&gt;using namespace std;int main(){    fstream fs("test.txt",ios::in);    if(!fs.good())    {        cout &lt;&lt; "文件打开失败" &lt;&lt; endl;        return -1;    }    // 调整文件的位置指针到末尾    fs.seekp(0,ios::end);    cout &lt;&lt; "文件的字节数：" &lt;&lt; fs.tellp() &lt;&lt; endl;    fs.close();}</code></pre><pre><code>练习：使用C++标准IO，实现带覆盖检查的cp命令。    ./cp src dest</code></pre><pre><code>#include &lt;iostream&gt;#include &lt;fstream&gt;using namespace std;int main(int argc,char* argv[])// 写的有点问题0.0{    if(argc != 3)    {        cout &lt;&lt; "命令错误" &lt;&lt; endl;    }    // 读写    fstream fi(argv[1],ios::in);    fstream fo(argv[2],ios::out);    if(!fi.good())    {        cout &lt;&lt; "源文件不存在" &lt;&lt; endl;    }    cout &lt;&lt; "是否要覆盖目标文件,y/n" &lt;&lt; endl;    while(1)    {        string a;        cin &gt;&gt; a;        if(a == "y")        {            break;        }        else if(a == "n")        {            return 0;        }        else        {            cout &lt;&lt; "指令错误" &lt;&lt; endl;            continue;        }    }    while(1)    {        string str;        fi &gt;&gt; str;        if(str.size() == 0)        {            break;        }        fo &lt;&lt; str &lt;&lt;" "; // 文件末尾多个空格，需要删除，并且没有换行功能    }}</code></pre><h2 id="五、类型信息-typeid"><a href="#五、类型信息-typeid" class="headerlink" title="五、类型信息 typeid"></a>五、类型信息 typeid</h2><pre><code>用于获取数据的类型信息。name成员函数，可以获取类型的名字，内建类型名字使用缩写。同时还支持 == != 用来比较是否是同一种类型。如果用于判断父子类的指针或引用，它不能准确判断出实际的对象类型。但可以判断出具有多态继承关系的父子类的指针或引用，它的实际对象。</code></pre><pre><code>#include &lt;iostream&gt;#include &lt;typeinfo&gt;using namespace std;class Base{public:    virtual ~Base(void)    {    }};class Test:public Base{};int main(){    Base b;    Test t;    cout &lt;&lt; typeid(b).name() &lt;&lt; endl;    cout &lt;&lt; (typeid(t) == typeid(b)) &lt;&lt; endl;    cout &lt;&lt; endl;    Base* p = new Test;    cout &lt;&lt; (typeid(*p) == typeid(Test)) &lt;&lt; endl;    cout &lt;&lt; (typeid(p) == typeid(Test*)) &lt;&lt; endl;}</code></pre><pre><code>扩展：    sudo find / -name filename    sudo find / | grep "std"    grep 'Base' *               当前目录查找包含此字符的文件    grep -r 'Base' *            当前目录及所有子级目录，查找包含此字符的文件    grep -r 'Base' * dir        指定目录下及所有子级目录，查找包含此字符的文件</code></pre><h2 id="六、异常处理"><a href="#六、异常处理" class="headerlink" title="六、异常处理"></a>六、异常处理</h2><pre><code>抛异常    throw 数据    抛异常对象    抛基本类型    注意：不能抛出局部对象的指针或引用（构造函数和析构函数不能抛出异常）。    注意：如果异常没有被捕获处理，程序就会停止。捕获异常try{    可以抛出异常的代码}catch(类型 变量名) // 根据数据类型进行捕获{    处理异常，如果无法处理可以继续抛出异常}注意：捕获异常的顺序是自上而下的，而不是最精准的匹配，针对子类异常捕获时要放在父类的前面。函数的异常声明：    返回值类型 函数名(参数列表)throw(类型1,类型2,...)    注意：如果不写异常声明表示什么类型的异常都可能抛出。    注意：如果写了异常声明表示只抛出某些类型的异常，一旦超出异常声明的范围，程序会直接停止，无法捕获。    注意：throw() 表示什么类型都不会抛出设计异常类：</code></pre><pre><code>      class Error      {          int errno;          char errmsg[255];      public:          Error(int errno = -1,const char* msg = "未知错误")          {              this-&gt;errno = errno;              strcpy(errmsg,msg);          }          int getError(void)          {              return errno;          }          const char* getErrmsg(void)          {              return errmsg;          }      }</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中STL相关知识</title>
      <link href="/2019/08/31/c-zhong-stl-xiang-guan-zhi-shi/"/>
      <url>/2019/08/31/c-zhong-stl-xiang-guan-zhi-shi/</url>
      
        <content type="html"><![CDATA[<p><strong>STL介绍</strong><br>    STL标准模板库，由惠普实验室提供，里面集成了常用的数据结构类模板和算法函数模板等。<br>    容器：用来存储各种类型数据的数据结构。<br>    迭代器：类似于专门用来指向容器成员的指针，用来遍历、操作、管理容器中的成员，可以大大提高容器的访问速度。<br>    算法：STL实现了常见的排序、查找算法。</p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/20190827150134261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lrYXJvc181MjE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="List：双端链表容器"><a href="#List：双端链表容器" class="headerlink" title="List：双端链表容器"></a>List：双端链表容器</h2><pre><code>iterator：用来指向容器中的元素    begin() 获取指向第一个元素的迭代器    end() 获取指向最后一个元素的下一个位置相关使用参考：https://blog.csdn.net/Ikaros_521/article/details/100091859</code></pre><p><img src="https://img-blog.csdnimg.cn/20190827150153998.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lrYXJvc181MjE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="vector：向量容器，俗称数组"><a href="#vector：向量容器，俗称数组" class="headerlink" title="vector：向量容器，俗称数组"></a>vector：向量容器，俗称数组</h2><pre><code>    #include &lt;iostream&gt;    #include &lt;vector&gt;    using namespace std;    void show(vector&lt;int&gt;&amp; arr)    {        for(int i=0; i&lt;arr.size(); i++)        {            cout &lt;&lt; arr[i] &lt;&lt; " ";        }        cout &lt;&lt; endl;    }    int main()    {        // 创建向量，设置容量并初始化        vector&lt;int&gt; arr(12,0);        show(arr);        // 向量支持[]运算符，所以被称为数组        for(int i=0; i&lt;10; i++)        {            arr[i] = i;        }        show(arr);        vector&lt;int&gt; arr1(10,0);            // 支持比较运算符        cout &lt;&lt; (arr[0]==arr1[0]) &lt;&lt; endl;        // at成员函数,相当于[]操作        for(int i=0; i&lt;arr.size(); i++)        {            cout &lt;&lt; arr.at(i) &lt;&lt; " ";        }        cout &lt;&lt; endl;        // 获取向量的容量         cout &lt;&lt; arr.capacity() &lt;&lt; endl;    }</code></pre><p><img src="https://img-blog.csdnimg.cn/20190827150209482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lrYXJvc181MjE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>  <img src="https://img-blog.csdnimg.cn/2019082715022572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lrYXJvc181MjE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="stack、queue：栈和队列"><a href="#stack、queue：栈和队列" class="headerlink" title="stack、queue：栈和队列"></a>stack、queue：栈和队列</h2><p>   <img src="https://img-blog.csdnimg.cn/20190827150318915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lrYXJvc181MjE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="double-ended-queues：双端队列，用法与向量基本一致，但可以在头和尾快速插入和删除元素"><a href="#double-ended-queues：双端队列，用法与向量基本一致，但可以在头和尾快速插入和删除元素" class="headerlink" title="double-ended queues：双端队列，用法与向量基本一致，但可以在头和尾快速插入和删除元素"></a>double-ended queues：双端队列，用法与向量基本一致，但可以在头和尾快速插入和删除元素</h2><pre><code>    #include &lt;iostream&gt;    #include &lt;deque&gt;    using namespace std;    int main()    {        deque&lt;int&gt; d(10,0);        for(int i=0; i&lt;d.size(); i++)        {            d[i] = i;        }        for(int i=0; i&lt;d.size(); i++)        {            cout &lt;&lt; d[i] &lt;&lt; " ";        }        cout &lt;&lt; endl;    }</code></pre><p><img src="https://img-blog.csdnimg.cn/20190827150335763.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lrYXJvc181MjE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="set：集合容器，集合中的数据会自动排序，不能重复（赋重复值也没用）。"><a href="#set：集合容器，集合中的数据会自动排序，不能重复（赋重复值也没用）。" class="headerlink" title="set：集合容器，集合中的数据会自动排序，不能重复（赋重复值也没用）。"></a>set：集合容器，集合中的数据会自动排序，不能重复（赋重复值也没用）。</h2><pre><code>    #include &lt;iostream&gt;    #include &lt;set&gt;    using namespace std;    int main()    {        int arr[5] = {4,3,2,2,5};        set&lt;int&gt; s;        // 在集合中插入元素        s.insert(arr,arr+5);        set&lt;int&gt;::iterator it;        for(it=s.begin(); it!=s.end(); it++)        {            cout &lt;&lt; *it &lt;&lt; " ";        }        // 返回某个值元素的个数        cout &lt;&lt; endl &lt;&lt; s.count(2) &lt;&lt;" "&lt;&lt;s.count(1)&lt;&lt; endl;        // 返回指向大于（或等于）某值的第一个元素的迭代器        cout &lt;&lt; *s.lower_bound(1) &lt;&lt; endl;    }</code></pre><p><img src="https://img-blog.csdnimg.cn/20190827150349668.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lrYXJvc181MjE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="map：是一种关联容器，在其他编程语言中叫字典，C-中叫映射，以key-value键值对的方式进行存储，key的值不能重复。"><a href="#map：是一种关联容器，在其他编程语言中叫字典，C-中叫映射，以key-value键值对的方式进行存储，key的值不能重复。" class="headerlink" title="map：是一种关联容器，在其他编程语言中叫字典，C++中叫映射，以key/value键值对的方式进行存储，key的值不能重复。"></a>map：是一种关联容器，在其他编程语言中叫字典，C++中叫映射，以key/value键值对的方式进行存储，key的值不能重复。</h2><pre><code>    #include &lt;iostream&gt;    #include &lt;map&gt;    using namespace std;    int main()    {        map&lt;int,string&gt; m;        // 插入元素        m.insert(make_pair(10010,"hehe"));        m.insert(make_pair(10011,"haaa"));        m.insert(make_pair(10012,"xixi"));        m.insert(make_pair(10013,"ohho"));        m.insert(make_pair(10013,"ohho"));        cout &lt;&lt; m.size() &lt;&lt; endl;        cout &lt;&lt; (*m.find(10011)).second &lt;&lt; endl;        map&lt;int,string&gt;::iterator it;        for(it=m.begin(); it!=m.end(); it++)        {            cout&lt;&lt; (*it).first &lt;&lt; " " &lt;&lt; (*it).second &lt;&lt; endl;        }    }</code></pre><p><img src="https://img-blog.csdnimg.cn/20190827150410951.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lrYXJvc181MjE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="multimap：多重映射，它与map很像，区别是它的key的值可以重复。"><a href="#multimap：多重映射，它与map很像，区别是它的key的值可以重复。" class="headerlink" title="multimap：多重映射，它与map很像，区别是它的key的值可以重复。"></a>multimap：多重映射，它与map很像，区别是它的key的值可以重复。</h2><pre><code>    #include &lt;iostream&gt;    #include &lt;map&gt;    using namespace std;    int main()    {        multimap&lt;int,string&gt; mm;        // 插入元素        mm.insert(make_pair(10010,"ha1"));        mm.insert(make_pair(10012,"ha2"));        mm.insert(make_pair(10010,"ha3"));        mm.insert(make_pair(10013,"ha4"));        mm.insert(make_pair(10010,"ha5"));        cout &lt;&lt; mm.size() &lt;&lt; endl;        multimap&lt;int,string&gt;::iterator it;        // 查找一个元素        it = mm.find(10010);        // 返回指定元素出现的次数        for(int i=0; i&lt;mm.count(10010); i++)        {            cout &lt;&lt; (*it).second &lt;&lt; endl;            it++;        }    }</code></pre><p><img src="https://img-blog.csdnimg.cn/20190827150451820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lrYXJvc181MjE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="multiset：多重集合，它与set很像，区别是它的值可以重复。"><a href="#multiset：多重集合，它与set很像，区别是它的值可以重复。" class="headerlink" title="multiset：多重集合，它与set很像，区别是它的值可以重复。"></a>multiset：多重集合，它与set很像，区别是它的值可以重复。</h2><pre><code>    #include &lt;iostream&gt;    #include &lt;set&gt;    using namespace std;    int main()    {        int arr[10] = {1,3,5,3,2,5,7,6,3,9};        multiset&lt;int&gt; ms(arr,arr+10);        cout &lt;&lt; ms.size() &lt;&lt; endl;        cout &lt;&lt; ms.count(3) &lt;&lt; endl;        multiset&lt;int&gt;::iterator it;        for(it=ms.begin(); it!=ms.end(); it++)        {            cout &lt;&lt; (*it) &lt;&lt; " ";        }    }</code></pre><p><img src="https://img-blog.csdnimg.cn/20190827150513935.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lrYXJvc181MjE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="priority-queue：优先队列，它会根据元素的比较结果进行排序。"><a href="#priority-queue：优先队列，它会根据元素的比较结果进行排序。" class="headerlink" title="priority_queue：优先队列，它会根据元素的比较结果进行排序。"></a>priority_queue：优先队列，它会根据元素的比较结果进行排序。</h2><pre><code>#include &lt;iostream&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;queue&gt;using namespace std;int com(int&amp; a,int&amp; b){    if(a &gt; b)        return 1;    else if(a &lt; b)        return -1;    else        return 0;}int main(){    srand(time(NULL));    priority_queue&lt;int&gt; pq;    for(int i=0; i&lt;10; i++)    {        int val = rand()%100;        cout &lt;&lt; val &lt;&lt; " ";        pq.push(val);    }    cout &lt;&lt; pq.size() &lt;&lt; endl;    while(!pq.empty())    {        cout &lt;&lt; pq.top() &lt;&lt; " ";        pq.pop();    }}</code></pre><p>   总结：<br>    1、vector和deque是支持[]运算，因此基本不需要迭代器，其他容器一律使用迭代器进行遍历。<br>    2、stack、queue、priority_queue容器没有迭代器。<br>    3、set、multiset、priority_queue会对元素进行排序，因它存储元素要支持比较运算符。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中的模板</title>
      <link href="/2019/08/31/c-zhong-de-mo-ban/"/>
      <url>/2019/08/31/c-zhong-de-mo-ban/</url>
      
        <content type="html"><![CDATA[<h2 id="一、为什么使用模板"><a href="#一、为什么使用模板" class="headerlink" title="一、为什么使用模板"></a>一、为什么使用模板</h2><pre><code>1、C/C++是一种静态类型语言（预处理-&gt;汇编-&gt;编译-&gt;链接），好处是速度快，缺点是实现通用代码麻烦。例如：实现支持所有类型的快速排序。2、借助函数重载实现通用代码，好处是实现简单，但代码段会增加。3、借助宏函数实现通用代码，类型检查不严格。4、借助回调函数实现通用代码，使用麻烦。5、由于以上原因C++之父在C++实现了模板技术，让C++能够支持泛型编程。</code></pre><a id="more"></a><h2 id="二、函数模板"><a href="#二、函数模板" class="headerlink" title="二、函数模板"></a>二、函数模板</h2><h3 id="1、函数模板的定义"><a href="#1、函数模板的定义" class="headerlink" title="1、函数模板的定义"></a>1、函数模板的定义</h3><pre><code>  template &lt;typename 类型参数1,typename 类型参数2,...&gt;  类型参数1 函数名(参数类型2 参数名)  {      return 返回值;  }  template &lt;typename T&gt;  T find(T* arr,size_t len)  {     return val;  }可以用任何标识符作为类型参数名，但使用‘T’ 是约定俗成的，它表示调用这个函数时所指定的任意类型。</code></pre><h3 id="2、函数模板的使用"><a href="#2、函数模板的使用" class="headerlink" title="2、函数模板的使用"></a>2、函数模板的使用</h3><pre><code>    C++编译的编译器并不是把模板编译成一个可以处理任何类型的单一实体，而是根据模板的使用者的参数，产生不同的函数的实体。    根据具体类型代表模板参数生成函数实体过程叫实例化。模板是在使用时才实例化，可以自动实例化，也可以手动实例化（在函数调用时函数名与小括号之间加&lt;类型参数&gt;)。每个函数模板都会进行二次编译，第一次编译在实例化之前，检查模板代码本身是否正确，第二次是实例化过程中，结合所使用类型参数，再次检查模板代码，是否所有的代码都有效。  注意：第二次编译才会生成二进制指令，第一次编译仅仅是在编译器内部生成一个用于描述模板的数据结构。</code></pre><pre><code>#include &lt;iostream&gt;using namespace std;template &lt;typename T,typename T1&gt;T Max(T val1,T1 val2){    return val1 &gt; val2 ? val1 : val2;}class A{    int val;public:    A(int val=0):val(val) {}    bool operator&gt;(A&amp; that)    {        return val &gt; that.val;    }};int main(){    cout &lt;&lt; Max('a',100) &lt;&lt; endl;    cout &lt;&lt; Max(100,99) &lt;&lt; endl;    cout &lt;&lt; Max(3.14,2.18) &lt;&lt; endl;    A a1,a2;    Max(a1,a2);}</code></pre><h3 id="3、函数模板的隐式推断"><a href="#3、函数模板的隐式推断" class="headerlink" title="3、函数模板的隐式推断"></a>3、函数模板的隐式推断</h3><pre><code>    函数模板虽然可以手动实例化，但使用麻烦，因此一般都根据参数类型进行隐式推断模板的参数。    注意：不能隐式推断的三种情况    1、函数参数与模板参数类型没有关系    2、不允许隐式类型转换    3、返回值类型不能隐式推断</code></pre><pre><code>#include &lt;iostream&gt;using namespace std;char arr[10];template &lt;typename T&gt;T Min(T v1,T v2){    cout &lt;&lt; "T" &lt;&lt; endl;    return v1 &lt;v2 ? v1 : v2;}char Min(char ch1,char ch2){    cout &lt;&lt; "char" &lt;&lt; endl;    return ch1 &lt; ch2 ? ch1 : ch2;}template &lt;typename T,typename R&gt;R func(T a){    return 10;}int main(){    //cout &lt;&lt; Min(3.14,12) &lt;&lt; endl;    cout &lt;&lt; Min('a','h') &lt;&lt; endl;    cout &lt;&lt; Min&lt;int&gt;(3.14,12) &lt;&lt; endl;    long temp = func&lt;int,long&gt;(100);}</code></pre><h3 id="4、函数模板与默认形参之间有冲突。"><a href="#4、函数模板与默认形参之间有冲突。" class="headerlink" title="4、函数模板与默认形参之间有冲突。"></a>4、函数模板与默认形参之间有冲突。</h3><h3 id="5、普通函数与同名的模板函数构成重载，编译器会优先调用普通函数，如果实现一个与模板函数功能一致的普通函数，那么这叫做模板函数的特化。"><a href="#5、普通函数与同名的模板函数构成重载，编译器会优先调用普通函数，如果实现一个与模板函数功能一致的普通函数，那么这叫做模板函数的特化。" class="headerlink" title="5、普通函数与同名的模板函数构成重载，编译器会优先调用普通函数，如果实现一个与模板函数功能一致的普通函数，那么这叫做模板函数的特化。"></a>5、普通函数与同名的模板函数构成重载，编译器会优先调用普通函数，如果实现一个与模板函数功能一致的普通函数，那么这叫做模板函数的特化。</h3><pre><code>注意：一般char*类型都需要特化。</code></pre><h2 id="三、类模板"><a href="#三、类模板" class="headerlink" title="三、类模板"></a>三、类模板</h2><h3 id="1、类模板的定义"><a href="#1、类模板的定义" class="headerlink" title="1、类模板的定义"></a>1、类模板的定义</h3><pre><code> template &lt;typename M,typename R,typename A,typename O...&gt; class Test { public:     M val;     Test(A a)     {         O var;     }     R func(void)     {     } };</code></pre><h3 id="2、类模板的使用"><a href="#2、类模板的使用" class="headerlink" title="2、类模板的使用"></a>2、类模板的使用</h3><pre><code>    类模板的参数不支持隐式推断，必须显示指定类型参数。    类名&lt;类型...&gt; 对象;类模板分为两步进行实例化：    编译期：编译器将类模板实例化类，并生成类对象创建指令。    运行期：处理器执行类对象创建指令，将类实例化为对象。    类模板也是一种静态多态。类模板中，只有那些被调用的成员函数才实例化出代码，即产生二进制指令（调用谁实例化谁）。</code></pre><h3 id="3、类模板中的静态成员"><a href="#3、类模板中的静态成员" class="headerlink" title="3、类模板中的静态成员"></a>3、类模板中的静态成员</h3><pre><code>    静态成员需要在类外定义，这一点不改变，但与普通类的定义不同。    template &lt;typename ...&gt; 类型 类名&lt;...&gt;::成员名;</code></pre><pre><code>#include &lt;iostream&gt;using namespace std;template &lt;typename A&gt;class Test{public:    static A a;    static int b;    Test(A arg)    {        cout &lt;&lt; arg &lt;&lt; endl;    }};template&lt;typename A&gt; A Test&lt;A&gt;::a;template&lt;typename A&gt; int Test&lt;A&gt;::b;int main(){    //Test* t = new Test(100);    Test&lt;int&gt; t(100);}</code></pre><h3 id="4、递归实例化"><a href="#4、递归实例化" class="headerlink" title="4、递归实例化"></a>4、递归实例化</h3><pre><code>    类模板的参数可以是任何类型，只有该类型提供类模板所需要的功能。    类模板的实例化已经是一个有效的类型了，因此它也可以当作类模板的参数，这种叫作递归实例化。    Vectors&lt;Vectors&lt;int&gt;&gt; //二维数组    Test&lt;Test&lt;int&gt;&gt;</code></pre><h3 id="5、类的局部特化"><a href="#5、类的局部特化" class="headerlink" title="5、类的局部特化"></a>5、类的局部特化</h3><pre><code>    当类的某个成员函数不能通用，需要对特殊类型(char*)实现一个特殊版本，这叫类的局部特化。    template&lt;&gt; 类型 返回值类型 类名&lt;类型&gt;::函数名(参数)    {    }    注意：在类外实现</code></pre><h3 id="6、全类特化"><a href="#6、全类特化" class="headerlink" title="6、全类特化"></a>6、全类特化</h3><pre><code>    当需要针对某种类型对类全部实现一个特殊版本，这种叫类的全类特化。template &lt;&gt; 类名&lt;类型&gt;{    ...};</code></pre><pre><code>#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;template &lt;typename T&gt;class Compare{    T a,b;public:    Compare(T a,T b):a(a),b(b) { }    const T&amp; max(void)    {        return a &gt; b ? a : b;    }    const T&amp; min(void)    {        return a &lt; b ? a : b;    }};/*template&lt;&gt; const char* const&amp; Compare&lt;const char*&gt;::max(void){    cout &lt;&lt; "------" &lt;&lt; endl;    if(1 == strcmp(a,b))        return a;    else        return b;}*/template&lt;&gt; class Compare&lt;const char*&gt;{    const char* str1;    const char* str2;public:    Compare(const char* str1,const char* str2)    {        this-&gt;str1 = str1;        this-&gt;str2 = str2;    }    const char* max(void)    {        if(1 == strcmp(str1,str2))            return str1;        else            return str2;    }    const char* min(void)    {        if(1 == strcmp(str1,str2))            return str2;        else            return str1;    }};int main(){    Compare&lt;const char*&gt; com("ad","adf");;    cout &lt;&lt; com.max() &lt;&lt; endl;}</code></pre><h3 id="7、类模板的缺省值"><a href="#7、类模板的缺省值" class="headerlink" title="7、类模板的缺省值"></a>7、类模板的缺省值</h3><pre><code>    类模板的类型参数可以设置默认值类型，规则与函数的默认形参基本一致（设置缺省值类型靠右）。    后面的类型参数可以使用前面的类型，但前面不能使用后面的。</code></pre><h3 id="8、普通数据也可以作为模板参数"><a href="#8、普通数据也可以作为模板参数" class="headerlink" title="8、普通数据也可以作为模板参数"></a>8、普通数据也可以作为模板参数</h3><pre><code>template &lt;typename T,类型 B&gt;{   int arr[B];}给类模板一个数据，在类中就可以像使用宏明一样使用参数。注意：实例化类中提供的数据必须是常量。</code></pre><pre><code>#include &lt;iostream&gt;#include &lt;typeinfo&gt;using namespace std;template &lt;typename A=int,typename B=A&gt;class Test{public:    Test(void)    {        cout &lt;&lt; typeid(A).name() &lt;&lt; " " &lt;&lt; typeid(B).name() &lt;&lt; endl;    }};int main(){    Test&lt;&gt; t;}</code></pre><h2 id="模板的技巧"><a href="#模板的技巧" class="headerlink" title="模板的技巧"></a>模板的技巧</h2><pre><code>1、typename可以用class代替2、不能直接使用模板父类的成员#include &lt;iostream&gt;using namespace std;template &lt;class T&gt;class Base{public:     void func(void)    {        cout &lt;&lt; "bbbb" &lt;&lt; endl;    }};template &lt;typename T&gt;class Test:public Base&lt;T&gt;{public:    Test(void)    {        Base&lt;T&gt;::func();    }};int main(){    Test&lt;int&gt; t;}3、在类模板中可以定义虚函数（多态），但虚函数不能是模板函数。</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中类的继承(二)</title>
      <link href="/2019/08/31/c-zhong-lei-de-ji-cheng-er/"/>
      <url>/2019/08/31/c-zhong-lei-de-ji-cheng-er/</url>
      
        <content type="html"><![CDATA[<h2 id="一、子类的构造、析构、拷贝"><a href="#一、子类的构造、析构、拷贝" class="headerlink" title="一、子类的构造、析构、拷贝"></a>一、子类的构造、析构、拷贝</h2><pre><code>1、子类的构造在执行它的构造函数前会根据继承表的顺序执行父类的构造函数。    默认执行父类的无参构造    显示调用有参构造，在子类的构造函数后，初始化列表中显示调用父类的有参构造函数。</code></pre><a id="more"></a><pre><code>2、子类在它的析构执行完后，会根据继承表的顺序，逆顺序执行父类的析构函数。    注意：父类的指针可以指向子类对象，当通过父类指针释放对象时，只会调用父类的析构函数，而这种析构方式有可能造成内存泄漏。3、当使用子类对象来初始化新的子类对象时，会自动调用子类缺省的拷贝构造函数，并且会先调用父类缺省的拷贝构造函数。    如果子类中实现的拷贝构造，需要显式调用父类拷贝构造，否则就会调用无参构造。</code></pre><h2 id="二、私有继承、保护继承"><a href="#二、私有继承、保护继承" class="headerlink" title="二、私有继承、保护继承"></a>二、私有继承、保护继承</h2><pre><code>使用 private 方式继承父类，公开的变成私有，其他的不变（有争议），这种继承方式防止父类的成员扩散。使用 protected 方式继承父类，公开成员在子类中会变成保护的，其他不变，这种继承方式可以有效防止父类的成员扩散。子类以私有或保护方式继承父类，会禁止向上造型（子类的指针或引用不能隐式转换成父类的指针或引用，要想实现多态只能以公开方式继承父类）。</code></pre><pre><code>#include &lt;iostream&gt;using namespace std;class Base{    int a;public:    int b;protected:    int c;};class A:private Base{public:    A(void)    {//        cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; " " &lt;&lt; c &lt;&lt; endl;    }};class B:public A{public:    B(void)    {        cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; " " &lt;&lt; c &lt;&lt; endl;    }};int main(){    Base* p = new A;//    A a;//    Base a;//    cout &lt;&lt; a.a &lt;&lt; " " &lt;&lt; a.b &lt;&lt; " " &lt;&lt; a.c &lt;&lt; endl;}</code></pre><h2 id="三、多重继承、钻石继承、虚继承"><a href="#三、多重继承、钻石继承、虚继承" class="headerlink" title="三、多重继承、钻石继承、虚继承"></a>三、多重继承、钻石继承、虚继承</h2><h3 id="1、多重载继承"><a href="#1、多重载继承" class="headerlink" title="1、多重载继承"></a>1、多重载继承</h3><pre><code>在C++中一个子类可以有多个父类，在继承表中按照顺序继承多个父类中的属性和行为，并按照顺序表，调用父类的构造函数。按照从低到高的地址顺序排序父类，子类中会标记每个父类存储位置。当子类指针转换成父类的隐式指针时候，编译器会自动计算父类中的内容在子类中的位置，地址会自动进行偏移计算。</code></pre><pre><code>#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;class A{public:    int a;};class B{public:    int b;};class C{public:    int c;};class Test:public A,public B,public C{public:    Test(void)    {        a = 1;        b = 2;        c = 3;    }};int main(){    Test* p = new Test;    A* ap = p;    B* bp = p;    C* cp = p;    printf("%p %p %p  p:%p\n",ap,bp,cp,p);    cout &lt;&lt; ap-&gt;a &lt;&lt; " " &lt;&lt; bp-&gt;b &lt;&lt; " " &lt;&lt; cp-&gt;c &lt;&lt; endl;}</code></pre><h3 id="2、名字冲突"><a href="#2、名字冲突" class="headerlink" title="2、名字冲突"></a>2、名字冲突</h3><pre><code>如果父类中有同名的成员，可以正常继承，但如果直接使用，会造成歧义，需要 类名::成员名 进行访问。</code></pre><pre><code>#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;class A{public:    int num;};class B{public:    int num;};class C{public:    int num;};class Test:public A,public B,public C{public:    Test(void)    {        cout &lt;&lt; A::num &lt;&lt; endl;    }};int main(){    Test* p = new Test;}</code></pre><h3 id="3、钻石继承"><a href="#3、钻石继承" class="headerlink" title="3、钻石继承"></a>3、钻石继承</h3><pre><code>假如有一个类A，类B继承类A，类C也继承类A，类D继承B和C。一个子类继承多个父类，这些父类有一个共同的祖先，这种继承叫钻石继承。注意：钻石继承不会导致继承错误，但访问祖先类中的成员时每次需要使用 类名::成员名 ，重点是这种继承会造成冗余。</code></pre><h3 id="4、虚继承-virtual"><a href="#4、虚继承-virtual" class="headerlink" title="4、虚继承 virtual"></a>4、虚继承 virtual</h3><pre><code>当进行钻石继承时，祖先类中的内容会有冗余，而进行虚继承后，在子类中的内容只会保留一份。注意：但使用虚继承时，子类中会多了一些内容（指向从祖先类继承来的成员）。</code></pre><h3 id="5、构造函数"><a href="#5、构造函数" class="headerlink" title="5、构造函数"></a>5、构造函数</h3><pre><code>一旦进行了虚继承祖先类的构造函数只执行一次，由孙子类直接调用，祖先类的有参构造也需要在孙子类中显示调用。</code></pre><h3 id="6、拷贝构造"><a href="#6、拷贝构造" class="headerlink" title="6、拷贝构造"></a>6、拷贝构造</h3><pre><code>在虚拟继承（钻石）中祖先类拷贝构造也由孙子类直接调用，子类中不再调用祖先类的拷贝构造，在手动实现的拷贝构造时（深拷贝），祖先类中的内容也由孙子类负责拷贝，同理赋值构造也一样。</code></pre><pre><code>#include &lt;iostream&gt;using namespace std;class A{public:    int a;    A(void)    {        cout &lt;&lt; "A类的构造函数" &lt;&lt; endl;    }    A(int num)    {        cout&lt;&lt;"A有参构造"&lt;&lt;endl;    }};class B:virtual public A{public:    B(void)    {        cout&lt;&lt;"B的构造"&lt;&lt;endl;    }};class C:virtual public A{public:    C(void)    {        cout &lt;&lt; "C的构造" &lt;&lt; endl;    }};class D:virtual public B,virtual public C{public:    D(void)    {        cout &lt;&lt; "D的构造" &lt;&lt; endl;    }};int main(){    //A a;    //B b;    //C c;    D d;//    cout &lt;&lt;sizeof(A) &lt;&lt;" "&lt;&lt; sizeof(B) &lt;&lt;" "&lt;&lt;sizeof(C)&lt;&lt;" " &lt;&lt;sizeof(D)&lt;&lt; endl;//    cout &lt;&lt; d.B::a &lt;&lt; endl;}</code></pre><h2 id="四、虚函数、覆盖、多态"><a href="#四、虚函数、覆盖、多态" class="headerlink" title="四、虚函数、覆盖、多态"></a>四、虚函数、覆盖、多态</h2><h3 id="1、虚函数"><a href="#1、虚函数" class="headerlink" title="1、虚函数"></a>1、虚函数</h3><pre><code>类的成员函数前加 virtual 这种函数就叫做虚函数。</code></pre><h3 id="2、覆盖"><a href="#2、覆盖" class="headerlink" title="2、覆盖"></a>2、覆盖</h3><pre><code>子类会覆盖父类的虚函数。</code></pre><h3 id="3、多态"><a href="#3、多态" class="headerlink" title="3、多态"></a>3、多态</h3><pre><code>当子类覆盖了父类的虚函数时，通过父类指针指向子类对象时，调用虚函数，会根据具体的对象是谁来决定执行谁的函数，这就是多态。</code></pre><pre><code>#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;using namespace std;class Base{public:    virtual void func(void)    {        cout &lt;&lt; "我是Base的func函数"&lt;&lt;endl;    }};class A:public Base{public:    void func(void)    {        cout&lt;&lt;"我是类A的func函数" &lt;&lt; endl;    }};class B:public Base{public:    void func(void)    {        cout&lt;&lt;"我是类B的func函数" &lt;&lt; endl;    }};class C:public Base{public:    void func(void)    {        cout&lt;&lt;"我是类C的func函数" &lt;&lt; endl;    }};int main(){/*覆盖    A* a = new A;    Base* p = a;    Base* b = new Base;    b-&gt;func(); // 并没有消失    a-&gt;func(); // 调用子类函数    p-&gt;func(); // 如果父类的函数是虚函数，调用子类函数*/    srand(time(NULL));    // 这就是多态    Base* arr[] = {new A,new B,new C};    arr[rand()%3]-&gt;func();}</code></pre><h2 id="五、覆盖和多态的条件"><a href="#五、覆盖和多态的条件" class="headerlink" title="五、覆盖和多态的条件"></a>五、覆盖和多态的条件</h2><h3 id="1、覆盖的条件"><a href="#1、覆盖的条件" class="headerlink" title="1、覆盖的条件"></a>1、覆盖的条件</h3><pre><code>    必须是虚函数    必须是父子类之间    函数签名必须相同（参数列表完全一致，const属性也会影响覆盖的结果）    返回值必须是同类型或父子类（子类的返回值要能向父类隐式转换）    访问属性不会影响覆盖    常函数属性也会影响覆盖</code></pre><pre><code>#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;using namespace std;class Base{public:    virtual Base* func(void)    //virtual void func(void)    {        cout &lt;&lt; "我是Base的func函数"&lt;&lt;endl;    }};class A:public Base{public:    A* func(void)    //在覆盖版本的函数中，所得到的this指针依然是实际对象地址，依然能够调用子类中的函数。    //void func(int num,char* str)    {        cout&lt;&lt;"我是类A的func函数" &lt;&lt; endl;    }};int main(){    A* a = new A;    Base* p = a;    p-&gt;func();}    </code></pre><h3 id="2、重载、隐藏、覆盖（重写）的区别"><a href="#2、重载、隐藏、覆盖（重写）的区别" class="headerlink" title="2、重载、隐藏、覆盖（重写）的区别"></a>2、重载、隐藏、覆盖（重写）的区别</h3><pre><code>    重载：同一作用域下的同名函数，函数签名不同（类型、个数、顺序、常函数等），构成重载关系。    覆盖：符合一系列条件。    隐藏：父子类之间的同名成员如果没有形成覆盖，且能通过编译，必定构成隐藏。</code></pre><h3 id="3、多态的条件"><a href="#3、多态的条件" class="headerlink" title="3、多态的条件"></a>3、多态的条件</h3><pre><code>    1.父子类之间有的函数有覆盖关系。    2.父类的指针或引用指向子类的对象。</code></pre><h3 id="4、在构造、析构函数中调用虚函数"><a href="#4、在构造、析构函数中调用虚函数" class="headerlink" title="4、在构造、析构函数中调用虚函数"></a>4、在构造、析构函数中调用虚函数</h3><pre><code>    在父类的构造函数中调用虚函数，此时子类还没有创建完成（回顾构造函数的调用过程），因此只能调用父类的虚函数，而不是覆盖版本的虚函数。    在父类的析构函数中调用虚函数，此时子类已经释放完成，因此只能调用父类的虚函数，而不是覆盖版本的虚函数。</code></pre><pre><code>#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;using namespace std;class Base{public:    Base(void)    {        func();    }    virtual void func(void)    {        cout &lt;&lt; "我是Base的func函数"&lt;&lt;endl;    }    ~Base(void)    {        func();    }};class A:public Base{public:    A(void)    {        func();    }    void func(void)    {        cout&lt;&lt;"我是类A的func函数" &lt;&lt; endl;    }    ~A(void)    {        func();    }};int main(){    A aa;//    A* a = new A;//    Base* p = a;//    p-&gt;func();}</code></pre><h2 id="六、纯虚函数和抽象类"><a href="#六、纯虚函数和抽象类" class="headerlink" title="六、纯虚函数和抽象类"></a>六、纯虚函数和抽象类</h2><h3 id="1、纯虚函数"><a href="#1、纯虚函数" class="headerlink" title="1、纯虚函数"></a>1、纯虚函数</h3><pre><code>在虚函数的声明的后面添加=0，这种虚函数就叫做纯虚函数，可以不实现，但如果实现必须在类外（只能在父类的构造函数、析构函数中调用）。virtual 返回值 函数名(参数) = 0;</code></pre><pre><code>#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;class Base{public:    Base(void)    {        func();    }    // 纯虚函数    virtual void func(void) = 0;    ~Base(void)    {        func();    }};class A:public Base{public:    void func(void)    {        cout &lt;&lt; "我是纯虚函数的覆盖"&lt;&lt;endl;    }};void Base::func(void){    cout&lt;&lt; "我是虚函数" &lt;&lt; endl;}int main(){    A a;    a.func();    //Base b;    //b.func();}</code></pre><h3 id="2、抽象类"><a href="#2、抽象类" class="headerlink" title="2、抽象类"></a>2、抽象类</h3><pre><code>成员函数中有纯虚函数，这种类叫抽象类，抽象类不能实例化（不能创建对象）。抽象类必须被继承且纯虚函数被覆盖后，由子类实例化对象。如果继承抽象类，但没有覆盖纯虚函数，那么子类也将成为抽象类，不能实例化。</code></pre><h3 id="3、纯抽象类"><a href="#3、纯抽象类" class="headerlink" title="3、纯抽象类"></a>3、纯抽象类</h3><pre><code>所有成员函数都是纯虚函数，这种只能被继承的类叫纯抽象类。这种类一般用来设计接口，这种类在子类被替换后不需要修改或少量的修改即可继续使用。</code></pre><pre><code>#include &lt;iostream&gt;using namespace std;class Base{public:    virtual void show(void) = 0;};class A:public Base{public:    void show(void)    {        cout &lt;&lt; "我是类A的show函数" &lt;&lt; endl;    }};class B:public Base{public:    void show(void)    {        cout &lt;&lt; "我是类B的show函数" &lt;&lt; endl;    }};class C:public Base{public:    void show(void)    {        cout &lt;&lt; "我是类C的show函数" &lt;&lt; endl;    }};enum ClassType{typeA,typeB,typeC};// 工厂类模式Base* creat_object(ClassType type){    switch(type)    {        case typeA: return new A;        case typeB: return new B;        case typeC: return new C;        default: return NULL;    }}int main(){    Base* p = creat_object(typeA);    p-&gt;show();}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 类 </tag>
            
            <tag> 继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中类的继承(一)</title>
      <link href="/2019/08/31/c-zhong-lei-de-ji-cheng-yi/"/>
      <url>/2019/08/31/c-zhong-lei-de-ji-cheng-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、类的继承"><a href="#一、类的继承" class="headerlink" title="一、类的继承"></a>一、类的继承</h2><pre><code>1、共性与个性    表达不同类型事物之间公有的属性和行为。    个性用于刻画每种事物特有的属性和行为。2、共性表示为父类（基类），个性表示为子类（派生类）。    子类继承自父类    基类派生出子类</code></pre><a id="more"></a><h2 id="二、继承的基本语法"><a href="#二、继承的基本语法" class="headerlink" title="二、继承的基本语法"></a>二、继承的基本语法</h2><pre><code>1、继承表一个子类可以同时继承零到多个父类，每个父类的继承方式可以相同也可以不同。class 子类：继承方式1 父类1,继承方式2 父类2,...{}2、继承方式    public 公有继承：父类的特性可通过子类向外扩展。    private 私有继承：父类的特性只能为子类所有。    protected 保护继承：父类的特性只能在继承链内扩展。</code></pre><h2 id="三、继承的基本特点"><a href="#三、继承的基本特点" class="headerlink" title="三、继承的基本特点"></a>三、继承的基本特点</h2><pre><code>1、公共特点（所有继承都有的特点）    子类对象可以当作父类对象使用，子类对象与父类没有本质上的区别。    子类的逻辑空间小于父类，但它的物理空间要大于等于父类。    子类对象 IS A 父类对象2、向上和向下转换（造型）    从子类到父类：子类的指针或引用可以隐式转换成父类的指针或引用，这是一种缩小类型的转换，对于编译器来说是安全的。    从父类到子类：父类的指针或引用不可以转换成子类的指针或引用，这是一种扩大类型的转换，在编译器看来是危险的。（子类的指针指向父类的对象，不安全）    编译器仅仅是检查指针或引用的数据类型，而对实际引用的目标对象不关心（构成多态的基础）。    类型一致：父类的指针或引用实际的目标类型是否需要转换成实际的指针或引用由程序自己决定。3、子类会继承父类的所有成员（公有，私有，保护）4、子类会隐藏父类的同名成员    1.可以通过域限定符 父类::隐藏成员 进行访问父类中的隐藏成员    2.可以使用父类的指针或引用来指向子类对象，然后访问父类中的隐藏成员。5、虽然子类继承所有父类中的成员，但不能访问父类中的私有成员。</code></pre><h2 id="四、继承方式影响访问控制"><a href="#四、继承方式影响访问控制" class="headerlink" title="四、继承方式影响访问控制"></a>四、继承方式影响访问控制</h2><p><img src="https://img-blog.csdnimg.cn/20190819182508729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lrYXJvc181MjE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190819164034499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lrYXJvc181MjE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><pre><code>#include &lt;iostream&gt;using namespace std;class A{private:    int a;    friend void f_show(A a);public:    int b;    A(void)    {        a = 1;        b = 2;        c = 3;        cout&lt;&lt;"A构造"&lt;&lt;endl;    }    void show(void)    {        cout &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt;endl;    }protected:    int c;};void f_show(A a){    cout&lt;&lt;  a.a&lt;&lt;a.b&lt;&lt;a.c &lt;&lt;endl;}class B:public A{public:    int b;    B(void)    {        b = 4;        //cout &lt;&lt; a &lt;&lt; endl;        cout&lt;&lt;"B构造 "&lt;&lt;" "&lt;&lt;b&lt;&lt;" "&lt;&lt;c&lt;&lt;endl;    }    void show(void)    {        cout&lt;&lt; A::b &lt;&lt; " "&lt;&lt; b&lt;&lt;" "&lt;&lt; c &lt;&lt;endl;    }};/*class B:private A{};class B:protected A{};*/int main(){    B b;    // 子类的指针或引用可以隐式转换成父类的指针或引用    A* a = &amp;b;    A aa;    f_show(aa);    cout&lt;&lt;b.b&lt;&lt;endl;    a-&gt;show();    b.show();    //cout&lt;&lt;b.c&lt;&lt;endl;    b.A::show();    // 父类的指针或引用不能转换成子类的指针或引用    //error  B* p = a;    cout&lt;&lt; sizeof(B)&lt;&lt;endl;}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 类 </tag>
            
            <tag> 继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言基础知识</title>
      <link href="/2019/08/29/c-yu-yan-ji-chu-zhi-shi/"/>
      <url>/2019/08/29/c-yu-yan-ji-chu-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="C语言关键字："><a href="#C语言关键字：" class="headerlink" title="C语言关键字："></a>C语言关键字：</h2><pre><code>unsigned signed bool void char short int long double float struct enum union typedef sizeofif else for switch case default while do break continue gotoextern register volatile auto const static return</code></pre><a id="more"></a><h2 id="常用的Linux系统命令："><a href="#常用的Linux系统命令：" class="headerlink" title="常用的Linux系统命令："></a>常用的Linux系统命令：</h2><pre><code>touch/cat/more/head/tall/rm/cp/mvmkdir/rmdir/cd/ls/tarifconfig/ping/telnet/ssh/ftp</code></pre><h2 id="vim文本编辑器："><a href="#vim文本编辑器：" class="headerlink" title="vim文本编辑器："></a>vim文本编辑器：</h2><pre><code>在终端下依靠键盘操作使用的文本编辑器。三大主要模式：正常模式、插入模式、命令模式常用快捷键：Ctrl+x Ctrl+z Ctrl+c教程：vimtutor</code></pre><h2 id="C语言介绍："><a href="#C语言介绍：" class="headerlink" title="C语言介绍："></a>C语言介绍：</h2><pre><code>发明C语言的目的是什么长盛不衰优缺点、特点C语言三剑客：《C语言陷阱和缺陷》、《C和指针》、《C专家编程》、《C程序设计语言》、</code></pre><p>《C Primer Plus》、《必然》、《白说》</p><h2 id="编译器介绍："><a href="#编译器介绍：" class="headerlink" title="编译器介绍："></a>编译器介绍：</h2><pre><code>编译器就一个特殊的程序，把负责把C代码（文本文件）编译成可执行的二进制文件。它由：预处理器、编译器、链接器组成常用的参数：-E -c -S -o -std -l -D -Werror -WallE    激活预处理；头文件、宏等展开（.i文件）S    激活预处理、编译；生成汇编代码（.s文件）c    激活预处理、编译、汇编；生成目标文件（.o文件）o    生成目标Wall    打开编译告警（所有）g    嵌入调试信息，方便gdb调试《程序员的自我修养》</code></pre><h2 id="数据类型："><a href="#数据类型：" class="headerlink" title="数据类型："></a>数据类型：</h2><pre><code>整型：unsigned、signedchar,short,int,long,long long实型：float,double,long double字符：char布尔：bool取值范围：char,short,int各类型的字节数：各类型的占位符：long double（%LF）</code></pre><h2 id="进制转换："><a href="#进制转换：" class="headerlink" title="进制转换："></a>进制转换：</h2><pre><code>为什么需要二进制：因为现在的计算机由大规模集成电路构成，计算单元只能识别高低电流这种数据，因此只能使用二进制数据。为什么需要八进制：为了方便记录二进制，由于历史原因八进制数据还在使用。为什么需要十六进制：相当于升级版的八进制，由于计算机的高速发展，八进制已经无法满足需要。十进制转换成二进制：    求余：把十进制数据不停的用2求余，逆序记录求余的结果。        189 % 2 = 1        94 % 2 = 0        47 % 2 = 1        23 % 2 = 1        11 % 2 = 1        5 % 2 = 1        2 % 2 = 0        1 % 2 = 1        10111101    求权：128 64 32 16 8 4 2 1二进制转换成十进制：    2的不同次方相加。二进制转换成八进制：三位二进制转换成一位八进制    10 111 101 = 0275    128 56 5 = 189二进制转化成十六进制：四位二进制转换成一位十六进制    10 &lt;=&gt; a    1011 1101 = 0xbd0b10111101 二进制0275 八进制0xbd 十六进制数据在内存是如何存储的：    数据分为原码、反码、补码，内存中存储的是数据的补码。原码：数据直接转换成的二进制（无论正负）反码：将原码按位求反得到反码补码：    正：原码    负：反码+1补码：10111101 char    10111100    01000011 -67</code></pre><h2 id="常量与变量"><a href="#常量与变量" class="headerlink" title="常量与变量"></a>常量与变量</h2><pre><code>常量：程序运行过程中不可改变的数据    字面值    100 int类型    100L long    100U unsigned int    100LU unsigned long    100LL long long    100LLU unsigned long long    3.14 double    3.14F float    3.14LF long double    枚举值    宏常量    具有const属性的被初始化过的全局变量变量：类型 变量名；注意：取名规则，见名知意    容器、数据</code></pre><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><pre><code>if else,switch,for,while,do while,break,continue,goto注意：大括号不要省略，分号不要多加《C语言编码规范-华为》《C++语言编程规范-谷歌》如何判断XX类型是否是“零值”?float,bool,int,char,int* p;if(0.000001 &gt; f &amp;&amp; f &gt;-0.000001)if(flag)if(0 == num)if('\0' == ch)if(NULL = p)阅读、安全角度思考。</code></pre><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><pre><code>C语言中只有一维数组，多维数组都是使用一维数组模拟的。数组的越界：一切正常、段错误、脏数据。char str[11] = "hello,world";变长数组：数据的长度填写变量，编译时不能确定，程序运行期间可以变化，而执行数组定义语句时长度才固定下来。    优点:可根据实际情况定义数组的长度，从而节约内存    缺点：不能初始化。int arr[10];arr &lt;=&gt; int *int arr[3][4]arr &lt;=&gt; int (*)[4];</code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><pre><code>函数是C语言中管理代码的最小单位，命名空间独立，栈空间独立。函数被调用时开辟栈内存，函数结束后释放栈内存。声明：返回值 函数名（类型1，类型2，...）;定义：返回值 函数名（类型1 参数名1，类型2 参数名2，...){    函数体}注意:函数的定义如果出现调用之前，声明可以忽略注意：调用函数时如果没有找到函数声明，也没有定义，编译器也不报错，而是先猜测函数的格式，链接时在尝试寻找函数的定义。    return 语句只是把数据存储到一个特定的位置，当函数运行结束后，调用者就可以从这个位置获取到返回值。        函数有返回值（格式），而没写return语句，调用者会得到一个不确定的返回值。常见编译错误：    隐式声明函数，没有找到函数声明和定义。1    undefined reference to '',有函数声明，但无函数定义函数的本质：函数就是存储在代码段中的一段数据（二进制指令的集合），函数名就是这段数据的开始位置    因此函数名就是地址，可以定义指向这段数据的指针变量，    返回值 （*函数指针） （类型1，类型2，...）；    函数的传参：        1、只能值传递（内存拷贝），使用指针可提高效率（const int *）        2、函数之间共享变量，全局变量（尽量少用），指针（注意安全）        3、数组当作函数的参数时就蜕变成了指针（长度丢失），额外增加一个参数传递数组长度。</code></pre><h2 id="修饰变量的关键字"><a href="#修饰变量的关键字" class="headerlink" title="修饰变量的关键字"></a>修饰变量的关键字</h2><pre><code>auto：用来修饰自动创建、释放的变量（局部变量、块变量），不加就代表加。    注意：静态变量、全局变量不能用它来修饰。static：    限制作用域：全局变量、普通函数    改变存储位置：把局部变量、块变量的存储位置由栈改为bss、data    延长生命周期：把局部变量、块变量的生命周期延长与全局变量一样。    static int fun(void);const：为数据提供一种"保护"机制,变量被它修饰后就不能显示修改。    也可以修饰函数的参数、返回值等。    const int fun(void);volatile:告诉编译器此变量的值不稳定、易变（不优化变量的取值）。    多线程共享变量、硬件编程（裸机、驱动）register:申请把变量的存储位置改为寄存器，但申请不一定成功    注意：被它修饰过的变量不能取地址extern：声明变量，用于不同.c之间共享全局变量（只能解决编译时问题）注意：全局变量、局部变量、块变量的变量名可以同名，由于作用域不同，会互相屏蔽。    块变量 &gt; 局部变量 &gt; 全局变量 （块变量屏蔽同名的局部变量）</code></pre><h2 id="程序在内存的分段："><a href="#程序在内存的分段：" class="headerlink" title="程序在内存的分段："></a>程序在内存的分段：</h2><pre><code>代码段 test：存储的是代码所编译成的二进制指令、字符串字面值、常量    具有只读属性，一旦修改会发生段错误。全局数据段 data：初始化过的全局变量、静态变量bss段（静态数据段）：未初始化的全局变量、静态变量    程序运行前会清理为0；栈 stack：存储局部变量、块变量、大小有限，安全。    由操作系统管理，以函数为单位使用（函数调用结束后自动释放）。堆 heap：一般由程序员手动管理（让系统去映射)，与指针配合使用，足够大，使用麻烦，释放的时间受控制    但不安全，容易产生内存碎片、内存泄漏。</code></pre><h2 id="指针："><a href="#指针：" class="headerlink" title="指针："></a>指针：</h2><pre><code>什么是指针：指针是一种数据类型（无符号整数，代表内存编号），使用它定义指针变量。    0~4G（32个1）4294967295 byte什么情况下使用指针：    1、函数之间共享变量（全局变量有命名冲突，不会被释放，浪费内存)    2、优化传递效率        因为C语言采用的是值传递（内存拷贝），会随着变量字节数的增加而降低运行效率。        而传递变量的地址，永远只拷贝4|8字节。        void func(const int * p);        但使用指针变量的值可能会被修改，可以配合const进行保护。        3、配合堆内存如何使用指针：    定义：类型 *变量名_p;        1、与普通变量一样，默认值不确定，为了安全一般初始化NULL。        2、一个*只能定义一个指针变量            int *p1,*p2;        3、指针变量与普通的用法不同，为了避免混用，一般从名字上加以区别。        4、指针变量的类型决定了解决引用时访问的字节数。    赋值：变量名_p = 地址；        int* p = NULL;        1、注意地址的类型        2、void*可以与任意类型的指针进行自动转换（C++中不可以)        3、要保障地址与物理内存有对应关系（映射过）。    解引用：*p；        根据指针变量中存储的内存编号，而访问内存中的数据。        这个过程可以会有段错误，但这是由于赋值了有问题的地址。使用指针要注意的问题：    1、野指针：指向的目标不确定，解引用时不一定会出错，但未知的危险最可怕。        而且野指针一旦产生就无法分辨，而预防的方法就是不制造野指针。        1、定义指针时一定要初始化。        2、指向的目标被释放后，要及时置空。        3、不要指向随时可能被释放的目标。    2、空指针：指针变量的值等于NULL，对这个地址解引用访问时，一定会产生段错误。        因为它存储的是操作系统重启时所需要的数据。        而预防的方法就是解引用前判断（来历不明） if（NULL == p）指针的运算：    指针+/-整数 = 指针+/-(宽度)*整数    指针-指针 = (指针-指针)/宽度指针与数组名：    1、数组名就一个特殊的地址，它就代表数组的第一个元素的首地址，也能当指针使用。        arr[i] &lt;=&gt; *(地址+i);        因此指针也能使用[]运算符    2、指针与目标内存是指向关系，而数组名是对应关系。    3、数组当函数的参数就蜕变为了指针变量，长度丢失，安全性不保障。        void fun(int* const arr,size_t len);指针与const的配合使用：    const int* p;    int const * p;    int * const p;    const int * p;    int const * const p;指针的高级应用：    指针数组：可以把无序的离散的数据，归纳到一起。    数组指针：专门指向数组指针    二级指针：指向指针的指针    函数指针：指向函数的指针</code></pre><h2 id="字符串："><a href="#字符串：" class="headerlink" title="字符串："></a>字符串：</h2><pre><code>由字符组成的串型数据结构，它的结束标志是'\0'。字符串存在的形式：    字符数组：char arr[5] = {'a','b','c','d'};        一般存储在栈，也可以存储在堆。        要考虑'\0'的位置    字符串字面值：由双引号包括的若干个字符，"hehe"。        以地址形式存在，需要使用const char* str;指针指向。        数据存在只读段，如果强行修改只会出现段错误。        背后隐藏着'\0';    char str[] = "hehe";    一般使用字符串字面值来初始化字符数组。字符串的输出：    printf %s,puts,fprintf字符串的输入：    scanf %s:不能输入空格    gets:不限制长度    fgets：可能会接受到'\n',或者输入缓冲区中残留数据字符串常见的操作：    strlen/strcat/strcpy/strcmp    strncat/strncpy/strncmp    memset/memcpy/strstr/strchr    sprintf/sscanf 用于拼接/解析字符串，非常好用    字符数据 -&gt; 数据 计算 数据 -&gt; 字符数据</code></pre><h2 id="堆内存管理"><a href="#堆内存管理" class="headerlink" title="堆内存管理"></a>堆内存管理</h2><pre><code>C语言中没有内存管理的语句，只能借助标准库中的函数进行管理堆内存。void *malloc(size_t size);void free(void *ptr);void *calloc(size_t nmemb, size_t size);void *realloc(void *ptr, size_t size);当向malloc首次申请内存时，malloc手中也没有内存，malloc会向系统申请，系统会映射33页内存交给malloc管理，之后再向malloc申请内存，malloc会直接从33页内存中分配，直到33页用完，再向操作系统申请。    访问malloc分配的内存时，可以越界，但不要超过33页范围。内存泄漏：    1、指针管理失误，指向其他位置。    2、free语句没有执行到。    3、free语句忘记写。    就内存没释放，有申请新内存，导致可用的内存越来越少，速度越来越慢。    前提：程序没有结束，当程序结束后属于它的所有资源都会被系统回收。内存碎片：    已经释放的内存，但不能被再次使用，这叫内存叫做内存碎片。       内存碎片不是错误，它是由于内存的释放时间和分配时间不协调造成的。       内存碎片无法避免（天然形成的），只能尽量减少：           1、尽量使用栈内存，只有在数据量比较多的时候再使用堆内存。           2、尽量申请大块内存自己管理。           3、不要频繁的申请释放内存。</code></pre><h2 id="预处理指令："><a href="#预处理指令：" class="headerlink" title="预处理指令："></a>预处理指令：</h2><pre><code>把C代码翻译成标准的C代码叫预处理、负责翻译的程序叫预处理器、被翻译的代码叫预处理指令。查看预处理的结果：    gcc -E code.c 直接查看预处理的结果    gcc -E code.c -o code.i 把预处理的结果保存到文件中宏定义：    宏常量：用一个有意义的单词代表一个字面值数据在代码中使用，在预处理时把单词替换成数据        优点：提高可读性、安全、扩展方便    宏函数：宏函数不是真正的函数，是带参数的宏，只是使用的方法类似函数        预处理时参数会代入到表达式中，宏名会替换成后面的表达式。        优点:运行速度快（没有参数传递），类型通用，只有极精简的代码段才适合定义宏函数        缺点：不会进行类型检查，也没有返回值，只有一个计算结果，大量使用会增加代码段的冗余。    预定义的宏：        __FILENAME__        __func__        __DATE__        __TIME__        __LINE__    条件编译：        #if        #elif        #else        #endif        #ifndef        #ifndef        头文件卫士</code></pre><h2 id="复合数据类型："><a href="#复合数据类型：" class="headerlink" title="复合数据类型："></a>复合数据类型：</h2><pre><code>结构 struct设计数据类型typedef struct Student{    char name[20];    char sex;    short age:1;}Student;定义结构变量    Student stu;    Student* stup = malloc(sizeof(Student));访问结构成员    stu.name,stu.sex,stu.age    stup-&gt;name,stup-&gt;sex,stup-&gt;age计算结构的字节数：    注意：成员的顺序不同会影响结构的字节数。    对齐：假定从零地址开始，每成员的起始地址编号，必须是它本身字节数的整数倍。    补齐：结构的总字节数必须是它最大成员的整数倍。    注意：在Linux系统下计算补齐、对齐时，成员超过4字节按4字节计算联合 union    从语法上来说与结构的用法基本类似，每个成员都从零地址开始，所有成员共有一块内存。    1、使用联合判断大小端    2、联合的总字节数计算，不需要对齐，但有补齐枚举 enum    值受限的int类型，把变量合法的值列举出来，除此以外不能等于其他的值    枚举值是常量，可以直接使用在case后，常与switch语句配合使用</code></pre><h2 id="文件操作："><a href="#文件操作：" class="headerlink" title="文件操作："></a>文件操作：</h2><pre><code>文件分类：    文本文件：记录的是字符串的二进制    二进制文件：直接把数据补码记录到文件中文件打开：    FILE *fopen(const char *path, const char *mode);    "r"    以只读方式打开文件，如果文件不存在则打开失败，返回值为空。    "r+" 在"r"的基础上增加写权限。    "w" 以只写方式打开文件，如果文件不存在则创建，如果文件存在则把内容清空。    "w+" 在"w"的基础上增加读取权限。    "a" 以只写方式打开文件，如果文件不存在则创建，如果文件存在则把内容保留，与"w"区别是当有新数据写入，会追加到文件的末尾。    "a+" 在"a"的基础上增加读权限。     "b" 在linux系统下没有用，表示以二进制格式打开文件。        在Windows系统下不加b '\n' 写到文件中 系统会写入'\n\r',加b则写'\n'时只写入'\n'.读写文本内容：    int fprintf(FILE *stream, const char *format, ...);    功能：把数据以文本形式写入到文件中    stream：文件指针，fopen函数的返回值    format：格式化控制符，点位符等    ...：要写入的变量。    返回值：成功写入的变量个数。        int fscanf(FILE *stream, const char *format, ...);    功能：从文件中读取数据到变量，要求文件的内容是字符。    stream：文件指针，fopen函数的返回值    format：格式化控制符，点位符等    ...：变量的地址    返回值：成功读取到返回0，失败返回-1。        读写二进制内容：    size_t fwrite(const void *ptr, size_t size, size_t nmemb,FILE *stream);    功能：内存中的数据，以二进制形式写入到文件中。    ptr：要写入的内存的首地址    size：要写入的字节数    nmemb：要写入的次数    stream：文件指针，fopen函数的返回值    返回值：成功写入的次数        size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);    功能：从文件中以二进制方式读取数据到内存中。    ptr：用来存放数据的内存首地址    size：要读取的字节数    nmemb：要读取的次数    stream：文件指针，fopen函数的返回值    返回值：成功读取的次数文件位置指针：    每个打开的文件系统都会用一个指针记录着它的读写位置，这个指针指向哪里，    接下来对文件的读取就会从哪里继续，指针的位置会随着文件的读写自动发生变化文件结构体中有一个成员记录文件的读写位置，称它位文件位置指针，有些情况下需要调整它的位置，获取到正确的数据。    int fseek(FILE *stream, long offset, int whence);    功能：根据基础位置＋偏移值调整文件指针的位置。    stream：文件指针，fopen函数的返回值    offset：可以为正负,正往右(偏移值)    whence：(基础位置)        SEEK_SET 文件头        SEEK_CUR 当前位置        SEEK_END 文件尾    long ftell(FILE *stream);    功能：返回文件位置指针所在的位置。    void rewind(FILE *stream);    功能：把文件位置指针调整到开头文件关闭：    int fclose(FILE *fp);    功能：把文件关闭，以释放相关资源，避免数据丢失。</code></pre><h2 id="多文件编程："><a href="#多文件编程：" class="headerlink" title="多文件编程："></a>多文件编程：</h2><pre><code>随着代码量的增加，不得不把代码分成若干个.c文件编写，这样能够给文件。。。但缺点是不方便编译，需要借助编译脚本。如何进行多文件编译：根据功能、责任分成若干个.c文件，然后为每个.c文件配备一个辅助文件.h然后单独编译每个.c文件，    生成目标文件.o，然后再把.o文件合并成可执行文件。头文件中应该写什么：    1、头文件卫士    2、宏常量、宏函数    3、结构、联合、枚举的设计    4、变量、函数的声明    5、static函数的实现</code></pre><h2 id="编译脚本："><a href="#编译脚本：" class="headerlink" title="编译脚本："></a>编译脚本：</h2><pre><code>把用于编译的命令记录到文件中（makefile/Makefile），在终端里执行make程序时，make程序会自动读取当前目录中的。。。make程序会监控每个文件的最后修改时间，如果没有被修改的文件不需要重新编译，这样可以节约大量的时间注意：一定要使用tab缩进</code></pre><h2 id="GDB调试："><a href="#GDB调试：" class="headerlink" title="GDB调试："></a>GDB调试：</h2><pre><code>1、设置ubuntu系统，当段错误时产生core    ulimit -c unlimited2、编译时增加-g参数3、再次执行新编译的程序，重新产生core文件4、gdb a.out core 进行调试    run/where</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础知识(三)</title>
      <link href="/2019/08/29/c-ji-chu-zhi-shi-san/"/>
      <url>/2019/08/29/c-ji-chu-zhi-shi-san/</url>
      
        <content type="html"><![CDATA[<h2 id="一、this指针"><a href="#一、this指针" class="headerlink" title="一、this指针"></a>一、this指针</h2><pre><code>类的成员变量单独存储在每个类对象中，成员函数存储在代码段中，所有的类对象共享一份成员函数。成员函数是如何区别调用它的是哪个类对象的？答：借助了this指针，类的每个成员函数都有一个隐藏的参数this指针，它指向类对象。</code></pre><a id="more"></a><pre><code>类的构造函数中也同样有this指针，指向的就是正在构造的这个对象。在类中（成员、构造、析构函数）对成员变量、成员函数的访问都是借助了this指针。this指针是隐藏的，但也可以显示使用：    1、参数与成员一样时，使用this可以区别出成员与参数名。    2、在成员函数中如果想返回当前对象的指针、引用等，可以使用this指针实现。    3、将this指针作为函数的参数，从一个对象传递给另一个其它类对象，可以实现对象间的交互。</code></pre><pre><code>#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;class User{    char name[20];    char pass[7];public:    User(const char* name,const char* pass)    {        strcpy(this-&gt;name,name);        strcpy(this-&gt;pass,pass);        //show();    }    User&amp; func(void)    {        return *this;    }    void show(void)//隐藏this指针    {        cout&lt;&lt; name &lt;&lt; " "&lt;&lt; pass &lt;&lt;endl;    }    User* this = const this;};int main(){    User u1("aaa","123");    User u2("bbb","321");    User&amp; u3 = u1.func();    u1.show();    u2.show();    u3.show();}</code></pre><h2 id="二、常函数"><a href="#二、常函数" class="headerlink" title="二、常函数"></a>二、常函数</h2><pre><code>在函数的参数列表与函数体之间有const修饰的函数，这个const其实就是在修饰this指针。不能在常函数内修改成员变量的值，普通成员函数可以调用常函数，而常函数只能调用常函数。如果在常函数中真的需要修改某个成员变量的数据，那么需要这个成员被 mutable修饰。</code></pre><pre><code>mutable char name[20];void show(void) const//隐藏this指针{    strcpy(name,"------");    cout&lt;&lt; name &lt;&lt; " "&lt;&lt; pass &lt;&lt;endl;}</code></pre><p>   普通函数不能声明为常函数（因为没有this指针）。</p><h2 id="三、析构函数"><a href="#三、析构函数" class="headerlink" title="三、析构函数"></a>三、析构函数</h2><pre><code>1、特殊的成员函数     ~类名(void)    {    }    没有参数、没有返回值、不能重载2、谁来调用    析构函数会在销毁对象时自动调用，在对象的整个生命周期内最多被调用一次。3、析构函数负责什么    负责释放在构造函数期间获取的所有资源，它的执行过程：    1.先执行析构函数本身代码    2.调用成员类的析构函数    3.调用父类的析构函数</code></pre><pre><code>#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;using namespace std;class A{public:    A(void)    {        cout &lt;&lt; "A 's 构造" &lt;&lt;endl;    }    ~A(void)    {        cout&lt;&lt;"A 's 析构"&lt;&lt;endl;    }};class B{public:    B(void)    {        cout &lt;&lt; "B 's 构造" &lt;&lt;endl;    }    ~B(void)    {        cout&lt;&lt;"B 's 析构"&lt;&lt;endl;    }};class User : public A{    char* name;    char* pass;    B b;    //char name[20];    //char pass[10];public:    User(const char* name,const char* pass)    {        this-&gt;name = new char[strlen(name)+1];        strcpy(this-&gt;name,name);        this-&gt;pass = new char[strlen(pass)+1];        strcpy(this-&gt;pass,pass);        cout&lt;&lt; "构造"&lt;&lt;endl;        cout&lt;&lt;"-----"&lt;&lt;endl;    }/*    User(void)    {        cout&lt;&lt;"构造"&lt;&lt;endl;    }*/    ~User(void)    {        delete name;        delete pass;        cout&lt;&lt;"析构"&lt;&lt;endl;    }};int main(){    User* u1 = new User("asd","ads");    //exit(0);    delete u1;    //User u2;}</code></pre><p>   4.缺省的析构函数<br>        如果一个类没有实现析构函数，编译器会自动生成一个具有析构函数功能的二进制指令，它负责释放编译器能够看得到的资源（成员变量、类成员、弗雷成员），这就是缺省析构。<br>        如果类中没有动态资源，也不需要做善后工作，缺省析构就完全共用了，不需要再实现新析构函数。<br>        注意：缺省析构无法释放动态资源（堆内存）【堆内存是动态资源，动态资源不一定是堆内存】</p><p>   类对象的创建过程与释放过程。</p><pre><code>    创建：分配内存（对象）-&gt; 父类构造-&gt; 成员构造-&gt; 自己构造        父类构造：按照继承表从左到右依次构造。        成员构造：按照声明顺序从上至下依次构造。    释放：自己析构-&gt; 成员析构-&gt; 父类析构-&gt; 释放内存（对象）        成员析构：按照声明顺序从下到上依次构造。        父类析构：按照继承表从右到左依次构造。</code></pre><h2 id="四、拷贝构造"><a href="#四、拷贝构造" class="headerlink" title="四、拷贝构造"></a>四、拷贝构造</h2><pre><code>拷贝构造又称为复制构造，是一种特殊的构造函数，它是使用一个现有的旧对象构造一个新的对象时调用的函数，只有一个引用型的参数（对象本身）。类名(类&amp; ){}拷贝构造的参数应该加 const 保护，但编译器并没有强行限制。编译器会自己生成一个拷贝构造函数，它负责把旧对象中的所有数据拷贝给新创建的对象。深拷贝与浅拷贝的区别：    如果类成员有指针，浅拷贝只拷贝指针变量的值，而深拷贝指针变量所指向的目标。什么情况下需要实现拷贝构造：    当类成员中没有指针成员，此时默认的拷贝构造（浅拷贝）就无法完成任务，需要自己动手实现拷贝构造（深拷贝）。什么情况下会调用拷贝构造：    1、使用旧对象给新对象赋值时    User user1 = user;    2、使用对象当作函数的参数，当调用函数时，就会一起调用拷贝构造。</code></pre><pre><code>#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;class User{    char* name;    char pass[7];    int id;public:    User(const char* name,const char* pass)    {        this-&gt;name = new char[strlen(name)+1];        strcpy(this-&gt;name,name);        strcpy(this-&gt;pass,pass);    }    void show(void)    {        cout&lt;&lt;name &lt;&lt;" " &lt;&lt;pass &lt;&lt;endl;    }    ~User(void)    {        cout&lt;&lt;"析构"&lt;&lt;&amp;name &lt;&lt;endl;        delete[] name;    }    User(User&amp; that)    {        name = new char[strlen(that.name)];        strcpy(name,that.name);        strcpy(pass,that.pass);        cout &lt;&lt; "我是拷贝构造" &lt;&lt; endl;    }};void func(User&amp; user){    user.show();}int main(){    User u1("a","aa");    u1.show();    // 调用拷贝构造    User u2 = u1;    u2.show();    func(u1);}</code></pre><h2 id="五、赋值构造（赋值运算符）"><a href="#五、赋值构造（赋值运算符）" class="headerlink" title="五、赋值构造（赋值运算符）"></a>五、赋值构造（赋值运算符）</h2><pre><code>当一类对象给另一个类对象赋值时，就会调用赋值构造void opeator = (类&amp;){}什么时会调用：对象 = 对象；编译器会生成一个缺省的赋值构造，它负责把一个对象的内存拷贝给另一个对象。什么情况需要实现赋值构造：    当需要深拷贝时，需要自己动手实现赋值构造，也就是拷贝构造与赋值构造需要同时实现。编译器会自动生成四个成员函数：构造、析构、赋值构造、拷贝构造。    </code></pre><pre><code>#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;class User{    char* name;    char pass[7];public:    User(const char* name,const char* pass)    {        this-&gt;name = new char[strlen(name)+1];        strcpy(this-&gt;name,name);        strcpy(this-&gt;pass,pass);    }    void show(void)    {        cout&lt;&lt;name &lt;&lt;" " &lt;&lt;pass &lt;&lt;endl;    }    ~User(void)    {        cout&lt;&lt;"析构"&lt;&lt;&amp;name &lt;&lt;endl;        delete[] name;    }    User(User&amp; that)    {        name = new char[strlen(that.name)];        strcpy(name,that.name);        strcpy(pass,that.pass);        cout &lt;&lt; "我是拷贝构造" &lt;&lt; endl;    }    User&amp; operator = (const User&amp; that)    {        cout&lt;&lt; this &lt;&lt;" "&lt;&lt; &amp;that &lt;&lt; endl;        if(this != &amp;that)        {            cout&lt;&lt;"我是赋值构造"&lt;&lt;endl;            // 释放旧空间            delete[] name;            // 申请新空间            name = new char[strlen(that.name)+1];            // 拷贝内容            strcpy(name,that.name);            strcpy(pass,that.pass);            /*            User temp(that);            swap(name,temp.name);            */        }        return *this;    }};int main(){    User u1("a","aa");    User u2("bbbb","bb");    User u3("ccc","cc");    //赋值构造    u1 = u1;    //u2 = u1 = u3;    u1.show();    u2.show();    u3.show();}</code></pre><h2 id="六、关于拷贝构造、赋值构造的建议"><a href="#六、关于拷贝构造、赋值构造的建议" class="headerlink" title="六、关于拷贝构造、赋值构造的建议"></a>六、关于拷贝构造、赋值构造的建议</h2><pre><code>1、缺省的拷贝构造、赋值构造函数不光会拷贝本类的数据，也会调用成员类对象和父类的拷贝构造和赋值构造，而不是单纯的按字节复制，因此尽量少用指针成员。2、在函数参数中，尽量使用类指针或引用来当参数（不要直接使用类对象），减少调用拷贝构造和赋值构造的机会，也可以降低数据传递的开销。3、如果由于特殊原因无法实现完整的拷贝构造、赋值构造，建议将它们私有化，防止误用。4、一旦为一个类实现了拷贝构造，那么也一定要实现赋值构造。（&lt;=&gt;）</code></pre><h2 id="七、静态成员"><a href="#七、静态成员" class="headerlink" title="七、静态成员"></a>七、静态成员</h2><pre><code>类成员一旦被 static 修饰就会变成静态成员，而是单独一份存储在bss或data内存段中，所有的类对象共享（静态成员属于类，而不属于某个对象）。静态成员在类内声明，但必须在类外定义、初始化。与成员函数一样需要加“类名::”限定符表示它属于哪个类，但不需要再额外增加 static. 成员函数也可以被static修饰，这种函数叫静态成员函数，这种成员没有this指针，因此在静态函数中不能直接访问类的成员，但可以直接访问静态成员，但可以直接访问静态成员变量、静态成员函数。静态成员变量、函数依然受访问控制限定符的影响。因为在代码编译完成后，静态成员已经定义完成（有了存储空间），一次可以不用活类对象而直接调用，类名::静态成员名静态成员变量可以被当做全局变量来使用（访问限定符必须是public），静态成员函数可以当作类的接口，实现对类的管理。</code></pre><h2 id="八、单例模式"><a href="#八、单例模式" class="headerlink" title="八、单例模式"></a>八、单例模式</h2><pre><code>什么是单例模式，只能创建出一个类对象（只有一实际的实例）的叫单例模式。单例模式的应用场景：    Windows系统的任务管理器    Linux/Unix系统的日志系统    网站的访问计数器    服务端程序的连接池、线程池、数据池获取单一对象的方法：    1、定义全局（C语言），但不受控制，防君子不能防小人。    2、专门写一个类，把类的构造函数设置私有，借助静态成员函数提供一个接口，以此来获取唯一的实例。C++如何实现单例：    1、禁止类的外部创建类对象：构造函数设置私有    2、类自己维护一个唯一的实例：使用静态指针指向    3、提供一个获取实例的方法：静态成员函数获取静态指针</code></pre><p>   饿汉模式：<br>        将单例类的唯一实例对象定义为成员变量，当程序开始运行时，实例对象就已经创建完成<br>        优点：加载进程时，静态创建单例对象，线程安全。<br>        缺点：无论使用与否，总要创建，浪费内存。</p><pre><code>#include &lt;iostream&gt;using namespace std;class Singleton{private:    Singleton(void)    {    }    static Singleton object;public:    static Singleton get_object(void)    {        return object;    }    void show(void)    {        cout&lt;&lt; "我是对象："&lt;&lt;&amp;object &lt;&lt;endl;    }};Singleton Singleton::object;int main(){    Singleton sig = Singleton::get_object();    Singleton sig1 = Singleton::get_object();    sig.show();    sig1.show();}</code></pre><p>   懒汉模式：<br>        用静态成员指针来指向单例类的唯一实例对象，只有真正调用获取实例的静态接口时，实例对象才被创建。<br>        优点：什么时候用什么时候创建，节约内存。<br>        缺点：在第一次调用获取实例对象的静态接口时，才真正创建，如果在多线程操作情况下有可能被创建出多个实例对象（虽然可能性很低），存在线程不安全问题。</p><pre><code>#include &lt;iostream&gt;#include &lt;pthread.h&gt;using namespace std;//pthread_mutex_lock = PTHREAD_MUTEX_INITIALIZER;class Singleton{private:    Singleton(void)    {    }    static Singleton* object;public:    static Singleton&amp; get_object(void)    {        if(NULL == object)        {            object = new Singleton;        }        return *object;    }    void show(void)    {        cout&lt;&lt; "我是对象："&lt;&lt;object &lt;&lt;endl;    }};Singleton* Singleton::object;int main(){    Singleton sig = Singleton::get_object();    Singleton sig1 = Singleton::get_object();    sig.show();    sig1.show();}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础知识(二)</title>
      <link href="/2019/08/29/c-ji-chu-zhi-shi-er/"/>
      <url>/2019/08/29/c-ji-chu-zhi-shi-er/</url>
      
        <content type="html"><![CDATA[<h2 id="十、函数重载（重载、隐藏、重写）"><a href="#十、函数重载（重载、隐藏、重写）" class="headerlink" title="十、函数重载（重载、隐藏、重写）"></a>十、函数重载（重载、隐藏、重写）</h2><pre><code>1、函数重载    在同一作用域下，函数名相同，参数列表不同的函数，构成重载关系。</code></pre><a id="more"></a><pre><code>#include &lt;iostream&gt;using namespace std;void f(const int* p){    cout&lt;&lt;"f const"&lt;&lt;endl;}void f(int* p){    cout&lt;&lt;"f"&lt;&lt;endl;}int main(){    const int num = 0;    f(&amp;num);}</code></pre><p>   2、重载实现的机制<br>        C++代码在编译时会把函数的参数类型添加到参数名中，借助这个方式来实现函数重载，也就是C++的函数在编译期间经历换名的过程。<br>    因此，C++代码不能调用C函数（C语言编译器编译出的函数）<br>    3、extern “C” {}<br>        告诉C++编译器按照C语言的方式声明函数，这样C++就可以调用C编译器编译出的函数了（C++目标文件可以与C目标文件合并生成可执行程序）。<br>        如果C想调用C++编译出的函数，需要将C++函数的定义用extern “C”包括一下。<br>        注意：如果两个函数名一样，一定会冲突。<br>    4、重载和作用域<br>        函数的重载关系发生在同一作用域下，不同作用域下的同名函数，构成隐藏关系。<br>    5、重载解析<br>        当调用函数时，编译器根据实参的类型和形参的匹配情况，选择一个确定的重载版本，这个过程叫重载解析。<br>        实参的类型和形参的匹配情况有三种：<br>            1、编译器找到与实参最佳的匹配函数，编译器将生成调用代码。<br>            2、编译找不到匹配函数，编译器将给出错误信息。<br>            3、编译器找到多个匹配函数，但没有一个最佳的，这种错误叫二义性。<br>        在大多数情况下编译器都能立即找到一个最佳的调用版本，但如果没有，编译就会进行类型提升，这样备选函数中就可能具有多个可调用<br>的版本，这样就可能产生二义性错误。<br>    6、确定存在函数的三个步骤<br>        1）候选函数<br>        函数调用的第一步就是确定所有可调用的函数的集合（函数名、作用域），该集合中的函数就是候选函数。<br>        2）选择可行函数<br>        从候选函数中选择一个或多个函数，选择的标准是参数个数相同，而且通过类型提升实参可被隐式转换为形参。<br>        3）寻找最佳匹配<br>        优先每个参数都完全匹配的方案，其次参数完全匹配的个数，再其次是浪费内存的字节数。<br>    7、指针类型会对函数重载造成影响<br>        C++函数的形参如果是指针类型，编译时函数名中会追加Px。</p><pre><code>#include &lt;iostream&gt;using namespace std;void sum(short a,short b){    cout&lt;&lt; a+b &lt;&lt; "  3" &lt;&lt; endl;}void sum(int a,short b){    cout&lt;&lt; a+b &lt;&lt; "  1" &lt;&lt; endl;}void sum(short a,long b){    cout &lt;&lt; a+b &lt;&lt;"  2"&lt;&lt; endl;}int main(){    short a=3, b=7;    sum(a,b);}</code></pre><h2 id="十一、默认形参"><a href="#十一、默认形参" class="headerlink" title="十一、默认形参"></a>十一、默认形参</h2><pre><code>1、在C++中函数的形参可以设置默认值，调用函数，如果没有提供实参数，则使用默认形参。2、如果形参只有一部分设置了默认形参，则必须靠右排列。3、函数的默认形参是在编译阶段确定的，因此只能使用常量、常量表达式、全局变量数据作为默认值。4、如果函数的声明和定义需要分开，那么默认形参设置在声明、定义，还是声明定义都需要设置。5、默认形参会对函数重载造成影响，设置默认形参时一定要慎重。</code></pre><pre><code>#include &lt;iostream&gt;using namespace std;void fun(int b,int a=100);int main(){    fun(10,20);    fun(50);}void fun(int b,int a){    cout &lt;&lt;"b:" &lt;&lt; b &lt;&lt; endl;    cout &lt;&lt;"a:" &lt;&lt; a &lt;&lt; endl;}</code></pre><h2 id="十二、内联函数"><a href="#十二、内联函数" class="headerlink" title="十二、内联函数"></a>十二、内联函数</h2><pre><code>1、普通函数调用时是生成调用指令（跳转），然后当代码执行到调用位置时跳转到函数所在的代码段执行。2、内联函数就把函数编译好的二进制指令直接复制到函数的调用位置。3、内联函数的优点就是提高程序的运行速度（因为没有跳转，也不需要返回），但这样会导致可执行文件增大（冗余），也就是牺牲空间来换取时间。4、内联分为显示内联和隐式内联    显示内联：在函数前 inline（C语言C99标准也支持）    隐式内联：结构、类中内部直接定义的成员函数，则该类型函数会被优化成内联函数。5、宏函数在调用时会把函数体直接替换到调用位置，与内联函数一样也是使用空间来换取时间，所以宏函数与内联函数的区别（优缺点）？    1.宏函数不是真正的函数，只是代码替换，不会有参数压栈、出栈以及返回值，也不会检查参数类型，因此所有类型都能使用，但这样会有安全隐患。    2.内联函数是真正的函数，被调用时会进行传参，会进行压栈、出栈，可以有返回值，并会严格检查参数类型，这样就不能通用，如果被多种类型调用需要重载。6、内联适用的条件    由于内联会造成可执行文件变大，并增加内存开销，因此只有频繁调用的简单函数适合作为内联。    调用比较少的复杂函数，内联后并不显著提高性能，不足以抵消牺牲空间带来的损失，所以不适合内联。    带有递归特性和动态绑定特性的函数，无法实施内联，因此编译器会忽略声明部分的inline关键字。</code></pre><h2 id="十三、引用"><a href="#十三、引用" class="headerlink" title="十三、引用"></a>十三、引用</h2><pre><code>引用就是取艺名（别名）。</code></pre><pre><code>#include &lt;iostream&gt;using namespace std;int main(){    int wqq = 18;    int&amp; xiu = wqq;    //int&amp; xiu; 不存在空引用,错误    //int const &amp; xi = 20; 无名对象    cout &lt;&lt; wqq &lt;&lt;" "&lt;&lt;xiu&lt;&lt;endl;}</code></pre><pre><code>1、引用的基本特性    引用就是取别名，声明一个标识符为引用，就表示该标识符是另一个对象的外号。    1）引用必须初始化，不存在空引用，但有悬空引用（变量死了，名还留着）。    2）可以引用无名对象和临时对象，但必须使用常引用。    3）引用不能更换目标    引用一旦完成了定义和初始化就和普通变量名一样，它就代表了目标，一经引用终身不能再引用其他目标。2、引用型参数    引用当作函数的参数能达到指针同样的效果，但不具备指针的危险，还比指针方便。    引用可以非常简单的实现函数间共享变量的目的，而且是否使用引用由被调函数说了算。    引用当作函数的参数还能提高传递参数效率，指针至少还需要4字节内存，而引用只需要增加一条标识符与内存之间的绑定（映射）。3、引用型返回值    不要返回局部变量的引用，会造成悬空引用。    如果返回值是一个临时值（右值），如果非要使用引用接收的话，必须使用常引用。注意：C++中的引用时一种取别名的机制，而C语言中的指针是一种数据类型（代表内存编号的无符号整数）。练习1：实现一个C++版本的swap函数。指针和引用的相同点和不同点：    相同点：跨函数共享变量，优化传参效率，避免传参的时候调用拷贝构造    不同点：指针有自己的存储空间，借助指针可以使用堆内存，引用不行。引用取别名，指针是数据类型。指针可以为空，引用不可以为空。指针可以不初始化，引用必须初始化。指针可以改变指向，引用不能引用其他对象（可以定义指针的指针，不能定义引用的引用。可以定义指针的引用，不能定义引用的指针。可以定义指针的数组，但不能定义引用的数组。可以定义数组的引用）。</code></pre><pre><code>#include &lt;iostream&gt;using namespace std;void swap(int&amp; a,int&amp; b) //引用{    int temp = a;    a = b;    b = temp;}int main(){    int a=3,b=4;    swap(a,b);    cout&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;endl;}</code></pre><h2 id="十四、C-的内存管理"><a href="#十四、C-的内存管理" class="headerlink" title="十四、C++的内存管理"></a>十四、C++的内存管理</h2><pre><code>1、new/delete C++具备申请/释放堆内存功能的运算符    相当于C语言中的malloc和free。    new 类型：会自动计算类型所需要字节数，然后从堆中分配对应字节数的内存，并返回内存的首地址（具备类型）。    delete 指针：会自动释放堆内存。    注意：new/delete与malloc/free不能混用，因为new和delete会自动调用类、结构的构造函数、析构函数。2、数组的分配与释放    new 类型[n]； n表示数组长度，如果类、结构会自动调用n次构造函数。    delete[] 指针；通过new[] 分配的内存，必须通过delete[]释放。    new[] 返回值前4个字节中存放着数组的长度。3、重复释放    delete/delete[]不能重复释放同一块内存。    delete/delete[]释放野指针的后果不确定，但释放空指针是安全的。</code></pre><pre><code>#include &lt;iostream&gt;using namespace std;struct Student{    Student(void)    {        cout&lt;&lt;"我是构造函数，创建对象时，我就会执行" &lt;&lt; endl;    }    ~Student(void)    {        cout&lt;&lt; "我是析构函数，释放对象时，我就会执行" &lt;&lt; endl;    }};int main(){    int* p = new int;    *p = 10;    cout&lt;&lt; *p &lt;&lt;endl;    Student stu;    Student* s = new Student;    delete(s);    cout &lt;&lt; endl;    Student* a = new Student[3];    p = (int*)a;    cout &lt;&lt; *(p-1) &lt;&lt; endl;    delete[] a;    }</code></pre><p>   4、内存分配失败<br>        当分配的内存过大，没有能满足需求的整块内存就会抛出异常，std::bad_alloc。<br>        new/delete和C语言的malloc/free的相同点和不同点（区别）？<br>        不同点：<br>            身份     运算符               标准库函数<br>            参数     类型（自动计算）      字节数（手动计算）<br>            返回值   带类型的地址          void*地址<br>            调用构造 自动调用              不能调用构造/析构函数<br>            出错     抛出异常              返回NULL<br>        相同点：<br>            1、都能管理堆内存<br>            2、不能重复释放<br>            3、可以释放NULL</p><p>   注意：在C++中尽量使用引用、new/delete</p><pre><code>#include &lt;iostream&gt;using namespace std;int main(){    int *p = NULL;    try{        p = new int[~0];    }    catch(std::bad_alloc&amp; ex)    {        cout &lt;&lt; "error" &lt;&lt; endl;    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础知识(一)</title>
      <link href="/2019/08/29/c-ji-chu-zhi-shi-yi/"/>
      <url>/2019/08/29/c-ji-chu-zhi-shi-yi/</url>
      
        <content type="html"><![CDATA[<p>思考题：C与C++的区别？</p><h2 id="一、C-介绍"><a href="#一、C-介绍" class="headerlink" title="一、C++介绍"></a>一、C++介绍</h2><pre><code>本贾尼·斯特劳斯特卢普，与1979年4月份贝尔实验室的本贾尼博士在分析UNIX系统分布内核流量分析时，希望有一种有效的更加模块化的工具。1979年10月完成了预处理器Cpre，为C增加了类机制，也就是面向对象，1983年完成了C++的第一个版本，C with classes也就是C++。C++与C的不同点：1、C++完全兼容C的所有语法（内容）2、支持面向对象的编程思想3、支持运算符重载4、支持泛型编程、模板5、支持异常处理6、类型检查严格</code></pre><a id="more"></a><h2 id="二、第一个C-程序"><a href="#二、第一个C-程序" class="headerlink" title="二、第一个C++程序"></a>二、第一个C++程序</h2><pre><code>1、文件扩展名    .cpp .cc .C .cxx2、编译器    g++ 大多数系统需要额外安装，Ubuntu系统下的安装命令：        sudo apt-get update        sudo apt-get install g++    gcc也可以继续使用，但需要增加参数 -xC++ -lstdc++3、头文件    #include &lt;iostream&gt;    #include &lt;stdio.h&gt; 可以继续使用，但C++建议使用 #include &lt;cstdio&gt;4、输入/输出    cin &lt;&lt; 输入数据    cout &gt;&gt; 输出数据    cin/cout会自动识别类型    scanf/printf可以继续使用    注意：cout和cin是类对象，而scanf/printf是标准库函数。5、增加了名字空间    std::cout    using namespace std;</code></pre><h2 id="三、名字空间"><a href="#三、名字空间" class="headerlink" title="三、名字空间"></a>三、名字空间</h2><pre><code>1、什么是名字空间在C++中经常使用多个独立开发的库来完成项目，由于库的作者或开发人员没见过面，因此命名冲突在所难免。2、为什么需要名字空间在项目中函数名、全局变量、结构、联合、枚举、类，非常有可能名字冲突，而名字空间就对这些命名进行逻辑空间划分（不是物理单元划分），为了解决命名冲突，C++之父为防止命名冲突给C++设计一个名字空间的机制。通过使用namespace XXX把库中的变量、函数、类型、结构等包含在名字空间中，形成自己的作用域，避免名字冲突。namespace xxx{}// 没有分号注意：名字空间也是一种标识符，在同一作用域下不能重名。3、同名的名字空间有自动合并（为了声明和定义可以分开写）同名的名字空间中如果有重名的依然会命名冲突4、名字空间的使用方法::域限定符空间名::标识符 // 使用麻烦，但是非常安全using namespace 空间名; 把空间中定义的标识符导入到当前代码中    不建议这样使用，相当于把垃圾分类后，又倒入同一个垃圾车，依然会冲突</code></pre><pre><code>#include &lt;iostream&gt;namespace test{int cout = 100;int cin = 99;}int main(){    std::cout&lt;&lt;test::cout&lt;&lt;' '&lt;&lt;test::cin&lt;&lt;std::endl;}</code></pre><p>   5、无名名字空间<br>    不属于任何名字空间中的标识符，隶属于无名名字空间。<br>    无名名字空间中的成员使用 ::标识符 进行访问。<br>    如何访问被屏蔽的全局变量。</p><p>   6、名字空间的嵌套<br>    名字空间内部可以再定义名字空间，这种名字空间嵌套<br>    内层的名字空间与外层的名字空间的成员，可以重名，内层会屏蔽外层的同名标识符。<br>    多层的名字空间在使用时逐层分解。</p><pre><code>    n1::n2::num;    namespace n1    {        int num = 1;        namespace n2        {               int num = 2;            namespace n3            {            }        }    }</code></pre><p>   7、可以给名字空间取别名<br>    由于名字空间可以嵌套，这样就会导致在使用内层成员时过于麻烦，可以给名字空间取别名来解决这类问题。<br>    namespace n123 = n1::n2::n3;</p><h2 id="四、C-的结构"><a href="#四、C-的结构" class="headerlink" title="四、C++的结构"></a>四、C++的结构</h2><p>   1、不再需要 typedef ，在定义结构变量时，可以省略struct关键字<br>    2、成员可以是函数（成员函数），在成员函数中可以直接访问成员变量，不需要.或-&gt;，但是C的结构成员可以是函数指针。<br>    3、有一些隐藏的成员函数（构造、析构、拷贝构造、赋值构造）。<br>    4、可以继承，可以设置成员的访问权限（面向对象）。</p><pre><code>#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;struct Man{    char id[18];};struct Student:public Man{    char name[20];    char sex;    short age;    Student(void)    {        cout&lt;&lt; "我被调用了..." &lt;&lt; endl;    }    void show(void)    {        cout &lt;&lt; "我是秀" &lt;&lt; name &lt;&lt; " " &lt;&lt; sex &lt;&lt; " " &lt;&lt; age &lt;&lt; endl;    }};int main(){    Student stu;    strcpy(stu.name,"hehe");    stu.sex = 'm';    stu.age = 12;    strcpy(stu.id,"1235214141231");    cout &lt;&lt; stu.name &lt;&lt; " " &lt;&lt; stu.sex &lt;&lt; " " &lt;&lt; stu.age &lt;&lt; endl;    cout&lt;&lt;stu.id&lt;&lt;endl;    stu.show();}</code></pre><h2 id="五、C-的联合"><a href="#五、C-的联合" class="headerlink" title="五、C++的联合"></a>五、C++的联合</h2><p>   1、不再需要 typedef ，在定义结构变量时，可以省略union关键字<br>    2、成员可以是函数（成员函数），在成员函数中可以直接访问成员变量，不需要.或-&gt;，但是C的结构成员可以是函数指针。<br>    3、有一些隐藏的成员函数（构造、析构、拷贝构造、赋值构造）。</p><pre><code>#include &lt;iostream&gt;using namespace std;union Data{    char ch[5];    int num;    Data(void)    {        cout&lt;&lt;"我被调用了？"&lt;&lt;endl;    }    void show(void)    {        cout &lt;&lt; ch &lt;&lt;" " &lt;&lt; num &lt;&lt; endl;    }    ~Data(void)    {        cout&lt;&lt;"析构"&lt;&lt;endl;    }};int main(){    Data d;    d.show();    cout &lt;&lt; sizeof(d) &lt;&lt; endl;}</code></pre><h2 id="六、C-的枚举"><a href="#六、C-的枚举" class="headerlink" title="六、C++的枚举"></a>六、C++的枚举</h2><p>   1、定义、使用方法与C语言基本一致。<br>    2、类型检查比C语言更严格</p><pre><code>#include &lt;iostream&gt;using namespace std;enum Color{    RED,    YELLOW,    BLUE,    WHITE,    BLACK};int main(){    Color r;    r = BLUE;    //r = 0; error 类型检查更严格    cout &lt;&lt; r &lt;&lt; endl;}</code></pre><h2 id="七、C-的布尔类型"><a href="#七、C-的布尔类型" class="headerlink" title="七、C++的布尔类型"></a>七、C++的布尔类型</h2><p>   1、C++具有真的布尔类型，bool是C++中的关键字，在C语言中使用布尔类型需要导入头文件stdbool.h（在C11中bool应该是数据类型了）。<br>    2、在C++中 true false 是关键字，而在C语言中不是。<br>    3、在C++中 true false 是1字节，而C语言中是4字节。</p><pre><code>#include &lt;iostream&gt;using namespace std;int main(){    bool flag = 0;    cout &lt;&lt; flag &lt;&lt; " " &lt;&lt; sizeof(flag) &lt;&lt; endl;}</code></pre><h2 id="八、C-的void"><a href="#八、C-的void" class="headerlink" title="八、C++的void*"></a>八、C++的void*</h2><p>   1、C语言中void* 可以与任意类型指针 自动转换。</p><pre><code>#include &lt;stdio.h&gt;int main(){    void* p = NULL;    char* p1 = p;    int* p2 = p;    double* p3 = p;    p = p1;    p = p3;}</code></pre><p>   2、C++中void<em>不能给其他类型的指针直接赋值，必须强制类型转换，但其他类型的指针可以自动给void</em>赋值。<br>    3、C++为什么这样修改void*？<br>        为了更安全，所以C++类型检查更严格。<br>        C++可以自动识别类型，对万能指针的需求不再那么强烈。</p><h2 id="九、操作符别名"><a href="#九、操作符别名" class="headerlink" title="九、操作符别名"></a>九、操作符别名</h2><p>   某些特殊语言的键没有~,&amp;符合，所以C++标准委员会为了让C++更有竞争力，为符号定义了一些别名，让这些小语种也可以愉快编写C++代码</p><pre><code>and       &amp;&amp;or      ||not     !{       &lt;%    }       %&gt;#       :%</code></pre><pre><code>%:include &lt;iostream&gt;using namespace std;int main()&lt;%    cout &lt;&lt; "hello" &lt;&lt;endl;%&gt;</code></pre><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&amp;id=28481591&amp;auto=1&amp;height=66"></iframe><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/08/28/hello-world/"/>
      <url>/2019/08/28/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
